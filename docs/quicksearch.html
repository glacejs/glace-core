<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"globals_index.js.html":{"id":"globals_index.js.html","title":"Source: globals/index.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/index.js &quot;use strict&quot;; /** * Contains global framework functions and helpers. * * @module */ var util = require(&quot;util&quot;); var chai = require(&quot;chai&quot;); var sinon = require(&quot;sinon&quot;); chai.use(require(&quot;chai-as-promised&quot;)); chai.use(require(&quot;chai-datetime&quot;)); chai.use(require(&quot;chai-fs&quot;)); chai.use(require(&quot;chai-string&quot;)); chai.use(require(&quot;sinon-chai&quot;)); require(&quot;../matcher&quot;); var CONF = require(&quot;../config&quot;); var plugins = require(&quot;../plugins&quot;); var Steps = require(&quot;../steps&quot;); var ScopeType = require(&quot;../testing&quot;).ScopeType; if (CONF.report.deepErrors) { chai.config.truncateThreshold = 0; } /** * `chaijs` `expect` function. * * @global * @function * @arg {*} actualValue - Some actual value which should be checked. * @see {@link http://chaijs.com/|chaijs} to get more details about * `expect` usage. * @example expect(1).to.be.equal(1); expect(2).to.be.gte(0); */ global.expect = chai.expect; /** * `SinonJS` is pretty nice lib for mocking. * * @global */ global.sinon = sinon; var stubObject = (obj, returns, processed) =&gt; { processed = processed || []; processed.push(obj); for (var prop in obj) { if (prop.startsWith(&quot;__&quot;) || [&quot;prototype&quot;, &quot;constructor&quot;].includes(prop)) { continue; } if (util.isFunction(obj[prop])) { obj[prop] = sinon.stub(); if (returns) { if (util.isObject(returns)) { if (prop in returns) obj[prop].returns(returns[prop]); } else { obj[prop].returns(returns); } } } if (util.isObject(obj[prop]) &amp;&amp; !processed.includes(obj[prop])) { obj[prop] = stubObject(obj[prop], returns, processed); } } return obj; }; /** * Stubs object with its properties recursively. * * @global * @arg {object} obj - Object to stub. * @arg {object|number|string} returns - Returned values. * @return {object} Object with stubbed functions. */ global.stubObject = stubObject; require(&quot;rehire&quot;).global(); /** * `GlaceJS` config. * * @global * @see {@link module:config|config} to get more details about its options. */ global.CONF = CONF; /** * Allure helper. * * @global */ global.allure = require(&quot;../allure&quot;); /** * Steps collection. * * @global * @type {Steps} * @see {@link module:steps/index|steps} to get more details about its methods. */ global.$ = Steps.getInstance(); global.scope = require(&quot;./scope&quot;); /** * Creates tests suite. * * @global * @function * @arg {string} name - Suite name. * @arg {function[]} [fixtures] - List of fixtures. * @arg {object} [opts] - Suite options. * @arg {number} [opts.chunkRetry] - Number of chunk retries on failure. * @arg {number} [opts.chunkTimeout] - Time to execute chunk or hook, sec. * @arg {function} func - Callback function with test cases. * @example suite(&quot;Some test suite&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); */ global.suite = (name, fixtures, opts, func) =&gt; { scope(new ScopeType(name).setType(&quot;suite&quot;), fixtures, opts, func); }; global.session = require(&quot;./session&quot;); global.test = require(&quot;./test&quot;); global.jaki = global.jaki_chunk = global.chunk = require(&quot;./chunk&quot;); global.forEachLanguage = require(&quot;./forEachLanguage&quot;); /** * Global function, existing in `glace` tests, which create `before` hook. * * `before` hook executes before all chunks in test or all tests in &lt;a href=&quot;#scope&quot;&gt;scope&lt;/a&gt; / * &lt;a href=&quot;#suite&quot;&gt;suite&lt;/a&gt; / &lt;a href=&quot;#session&quot;&gt;session&lt;/a&gt;. * * @global * @function before * @arg {function} func - Hook function. Can be `async` too. * * @example &lt;caption&gt;&lt;b&gt;before chunks&lt;/b&gt;&lt;/caption&gt; * * test(&quot;my test&quot;, () =&gt; { * * before(() =&gt; { * doSomeThing(); * }); * * chunk(&quot;first chunk&quot;, () =&gt; { * doSomeThingAgain(); * }); * * chunk(&quot;second chunk&quot;, () =&gt; { * andDoSomeThingAgain(); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;before tests&lt;/b&gt;&lt;/caption&gt; * * suite(&quot;my suite&quot;, () =&gt; { * * before(async () =&gt; { * await db.connect(); * }); * * test(&quot;first&quot;, () =&gt; { * chunk(async () =&gt; { * await db.query(&quot;select * from users&quot;); * }); * }); * * test(&quot;second&quot;, () =&gt; { * chunk(async () =&gt; { * await db.query(&quot;select * from products&quot;); * }); * }); * }); */ /** * Global function, existing in `glace` tests, which create `after` hook. * * `after` hook executes after all chunks in test or all tests in &lt;a href=&quot;#scope&quot;&gt;scope&lt;/a&gt; / * &lt;a href=&quot;#suite&quot;&gt;suite&lt;/a&gt; / &lt;a href=&quot;#session&quot;&gt;session&lt;/a&gt;. * * @global * @function after * @arg {function} func - Hook function. Can be `async` too. * * @example &lt;caption&gt;&lt;b&gt;after chunks&lt;/b&gt;&lt;/caption&gt; * * test(&quot;my test&quot;, () =&gt; { * * after(() =&gt; { * doSomeThing(); * }); * * chunk(&quot;first chunk&quot;, () =&gt; { * doSomeThingAgain(); * }); * * chunk(&quot;second chunk&quot;, () =&gt; { * andDoSomeThingAgain(); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;after tests&lt;/b&gt;&lt;/caption&gt; * * suite(&quot;my suite&quot;, () =&gt; { * * after(async () =&gt; { * await db.connect(); * }); * * test(&quot;first&quot;, () =&gt; { * chunk(async () =&gt; { * await db.query(&quot;select * from users&quot;); * }); * }); * * test(&quot;second&quot;, () =&gt; { * chunk(async () =&gt; { * await db.query(&quot;select * from products&quot;); * }); * }); * }); */ /** * Global function, existing in `glace` tests, which creates `beforeChunk` hook. * * `beforeChunk` hook executes before each chunk in test. * * @global * @function * @arg {function} func - Hook function. * * @example * * test(&quot;Some test&quot;, () =&gt; { * * beforeChunk(() =&gt; { * someFunc(); * }); * * chunk(&quot;Chunk #1&quot;, () =&gt; { * someFunc(); * }); * * chunk(&quot;Chunk #2&quot;, () =&gt; { * someFunc(); * }); * }); */ global.beforeChunk = beforeEach; /** * Global function, existing in `glace` tests, which creates `afterChunk` hook. * * `afterChunk` hook executes after each chunk in test. * * @global * @function * @arg {function} func - Hook function. * * @example * * test(&quot;Some test&quot;, () =&gt; { * * afterChunk(() =&gt; { * someFunc(); * }); * * chunk(&quot;Chunk #1&quot;, () =&gt; { * someFunc(); * }); * * chunk(&quot;Chunk #2&quot;, () =&gt; { * someFunc(); * }); * }); */ global.afterChunk = afterEach; /* Load globals from plugins */ plugins.getModules(&quot;globals&quot;); Ã— Search results Close "},"globals_chunk.js.html":{"id":"globals_chunk.js.html","title":"Source: globals/chunk.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/chunk.js &quot;use strict&quot;; const _ = require(&quot;lodash&quot;); const isPromise = require(&quot;is-promise&quot;); const CONF = require(&quot;../config&quot;); /** * Global function, existing in `glace` tests, which creates test chunk. * * `chunk` is independently executed part of `test`. It means that even if * first chunk is failed, other will be executed in any case. `test` should * contain as minimum one `chunk`. * * @global * @function * @arg {string} [name=null] - Name of chunk. * @arg {object} [opts] - Chunk options. * @arg {?number} [opts.retry=null] - Number of chunk retries on failure. Overrides * [config](GlaceConfig.html#test-chunk-retry) and [test](#test-chunk-retry) settings. * @arg {?number} [opts.timeout=null] - Time limit to execute chunk, **sec**. Overrides * [config](GlaceConfig.html#test-chunk-timeout) and [test](#test-chunk-timeout) settings. * @arg {function} func - Callback function with test payload. Can be `async` too. * * @example &lt;caption&gt;&lt;b&gt;Anonymous chunk&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(() =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Named chunk&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(&quot;My chunk&quot;, () =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Chunk with options&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(&quot;My chunk&quot;, { retry: 2, timeout: 1 }, () =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Several chunks in test&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(&quot;first chunk&quot;, () =&gt; { * expect(2).to.be.equal(3); * }); * chunk(&quot;second chunk&quot;, () =&gt; { * expect(3).to.be.equal(3); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Async chunk&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(async () =&gt; { * await Promise.resolve(&quot;done!&quot;); * }); * }); */ const chunk = (name, opts, func) =&gt; { if (name instanceof Function) { func = name; name = &quot;&quot;; opts = {}; } if (opts instanceof Function) { func = opts; opts = {}; } if (name instanceof Object) { opts = name; name = &quot;&quot;; } name = name || &quot;&quot;; opts = opts || {}; CONF.chunk.id++; const chunkId = CONF.test.id + &quot;_&quot; + CONF.chunk.id; if (CONF.chunk.passedIds.includes(chunkId)) return; if (CONF.retry.id) { if (!_.flatMap(CONF.retry.chunkIds).includes(chunkId)) return; } else { CONF.retry.curChunkIds.push(chunkId); }; it(name, _chunkCb(name, chunkId, opts, func)); }; /** * Chunk callback. * @ignore */ const _chunkCb = (name, chunkId, opts, func) =&gt; function () { expect(CONF.test.curCase, &quot;Oops! Chunk is used outside of test&quot;).to.exist; CONF.test.curCase.addChunk(name); CONF.chunk.curId = chunkId; if (opts.retry) this.retries(opts.retry); if (opts.timeout) this.timeout(opts.timeout * 1000); let result = func(); if (isPromise(result)) { result = result.then(r =&gt; { if (r === false) CONF.test.curCase.skipChunk = name; return r; }); } else { if (result === false) CONF.test.curCase.skipChunk = name; } return result; }; module.exports = chunk; Ã— Search results Close "},"globals_forEachLanguage.js.html":{"id":"globals_forEachLanguage.js.html","title":"Source: globals/forEachLanguage.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/forEachLanguage.js &quot;use strict&quot;; const _ = require(&quot;lodash&quot;); const U = require(&quot;glace-utils&quot;); const CONF = require(&quot;../config&quot;); /** * Iterates test chunks through all languages specified in config or options. * * It's applicable for multilingual application. If list of languages is * specified, it will be used firstly. Otherwise from configuration. * * @global * @function * @arg {object} [name=&quot;for language&quot;] - Iterator namespace (will be report). * @arg {function[]} [fixtures] - Involved fixtures list. * @arg {object} [opts] - Options. * @arg {?string[]} [opts.languages] - List of tested languages. * @arg {number} [opts.chunkRetry=0] - Number of chunk retries on failure. * Overrides config value for concrete test chunks. * @arg {?number} [opts.chunkTimeout=null] - Time to execute chunk or hook, sec. * @arg {function} func - Function with test steps. * @example * * test(&quot;Some test&quot;, ctx =&gt; { * forEachLanguage(lang =&gt; { * chunk(() =&gt; { * // payload * }); * }); * }); */ const forEachLanguage = (name, fixtures, opts, func) =&gt; { if (_.isFunction(opts)) [func, opts] = [opts]; if (_.isPlainObject(fixtures)) [opts, fixtures] = [fixtures]; if (_.isFunction(fixtures)) [func, fixtures] = [fixtures]; if (_.isArray(name)) [fixtures, name] = [name]; if (_.isPlainObject(name)) [opts, name] = [name]; if (_.isFunction(name)) [func, name] = [name]; name = name || &quot;for language&quot;; opts = opts || {}; fixtures = fixtures || []; (opts.languages || CONF.test.languages).forEach(_langCb(name, fixtures, opts, func)); }; const _langCb = (name, fixtures, opts, func) =&gt; lang =&gt; { const _fixtures = [langFixture(lang)].concat(fixtures); scope(`${name} &quot;${lang}&quot;`, _fixtures, opts, () =&gt; { func(lang); }); }; const beforeCb = lang =&gt; ctx =&gt; () =&gt; { if (!CONF.test.curCase) return; ctx.oldLang = CONF.test.curCase.testParams.language; CONF.test.curCase.testParams.language = lang; }; const afterCb = ctx =&gt; () =&gt; { if (!CONF.test.curCase) return; CONF.test.curCase.testParams.language = ctx.oldLang; }; const langFixture = lang =&gt; { return U.makeFixture({ before: beforeCb(lang), after: afterCb }); }; module.exports = forEachLanguage; Ã— Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: config.js &quot;use strict&quot;; /** * Configures `GlaceJS` before tests run. * * @namespace GlaceConfig * @prop {object} cluster - Cluster namespace. * @prop {boolean} [cluster.isMaster=true] - Mark current process as master. * @prop {boolean} [cluster.isSlave=false] - Mark current process as slave. * @prop {number} [cluster.slavesNum=0] - Number of slaves to launch. * @prop {number} [cluster.slaveId=null] - ID of slave. * @prop {object} session - Session namespace. * @prop {string} session.name - Session name. By default contains timestamp. * Can be overridden with CLI option `--session-name`. * @prop {string} session.id - Session ID. Default is timestamp. * @prop {boolean} [session.errors=[]] - List of session errors. * @prop {boolean} [session.isPassed=false] - Flag to define if tests session * run is passed or no. * @prop {array&lt;string&gt;} [session.preloads=[]] - Array of paths to `js` modules * which will be loaded before tests session run. * @prop {boolean} [session.interactive=false] - Flag to launch interactive * session. Can be overridden with CLI option `-i / --interactive`. * @prop {boolean} [session.debugOnFail=false] - Flag to enter to interactive * mode on step failure. Can be overridden with CLI option `--debug-on-fail`. * @prop {boolean} [session.exitOnFail=false] - Flag to break tests session on * first test failure. Can be overridden with CLI option `--exit-on-fail`. * @prop {string} [session.uncaughtException=log] - Strategy to process uncaught * exceptions. Available values are `log`, `fail`, `mocha`. Can be overridden * with CLI option `--uncaught`. * @prop {string} session.rootConftest - Path to `js` module which will be * loaded right after preloads. Can be overridden with CLI * option `--root-conftest`. * @prop {array&lt;string&gt;} session.killProcs - Array of process names which will * be killed before tests session run. Can be overridden with CLI * option `--kill-procs`. * @prop {object} retry - Retry settings namespace. * @prop {integer} [retry.id=0] - Number of retried session. * @prop {object} [retry.chunkIds={}] - Chunk ids grouped by retry values. For * example: `{1: ['1_1', '1_2'], 3: ['2_1'], 2: ['3_1', '3_2']}`. Populated on * first session run. * @prop {?array&lt;string&gt;} [retry.curChunkIds=null] - Reference to currently * populated group in `retry.chunkIds`. * @prop {object} test - Test settings namespace. * @prop {integer} [test.id=0] - Number of currently created test. Each test has * unique incremental id. On first session run it's assigned, on retry is used * to find test by id, because test name can be non-unique. * @prop {?TestCase} [test.curCase=null] - Currently executed test case. * @prop {array&lt;TestCase&gt;} [test.cases=[]] - Array of session test cases. * @prop {array&lt;string&gt;} [test.languages=[]] - Array of language names. Can be * overridden with CLI option `--languages`. * @prop {array&lt;string&gt;} [test.dirs=[]] - Array of test files or folders. Can * be overridden with CLI arguments or option `--targets` separated with comma. * @prop {boolean} [test.checkNames=true] - Flag to check test names uniqueness. * Can be overridden with CLI option `--dont-check-names`. * @prop {integer} [test.retries=0] - &lt;a name=&quot;test-retry&quot; href=&quot;#test-retry&quot;&gt;#&lt;/a&gt; * Number of test retries on failure. Overridden with CLI option `--retry`. * @prop {object} chunk - Chunk settings namespace. * @prop {integer} [chunk.id=0] - Number of chunk inside a test, incremental, * starts from `0` in each test. Fully unique chunk id is consist of `test.id` &amp; * `chunk.id`, like `1_1`, `1_2`, `2_1`. * @prop {?string} [chunk.curId=null] - Currently executed fully unique chunk id. * @prop {array&lt;string&gt;} [chunk.passedIds=[]] - Fully unique ids of passed chunks. * Used to skip already passed chunks on retry. * @prop {integer} [chunk.retries=0] - &lt;a name=&quot;test-chunk-retry&quot; href=&quot;#test-chunk-retry&quot;&gt;#&lt;/a&gt; * Number of chunk retries on failure. Overridden with CLI option `--chunk-retry`. * @prop {integer} [chunk.timeout=180] - &lt;a name=&quot;test-chunk-timeout&quot; href=&quot;#test-chunk-timeout&quot;&gt;#&lt;/a&gt; * Timeout of chunk execution, **sec**. Overridden with CLI option `--chunk-timeout`. * @prop {object} report - Report namespace. * @prop {string} [report.dir=cwd/report] - Folder to save tests session report. * @prop {string} [report.testDir] - Folder to save test-specific artifacts. * @prop {boolean} [report.clear=true] - Flag to clear report before tests run. * Can be overridden with CLI option `--dont-clear-report`. * @prop {boolean} [report.errorsNow=false] - Flag to print test error right * after its capture. Can be overridden with CLI option `--errors-now`. * @prop {string} [report.failedTestsPath=cwd/failed-tests.json] - Path to file * where info about failed tests will be saved to. Can be overridden with CLI * option `--failed-tests-path`. * @prop {object} [xunit] - xUnit report namespace. * @prop {boolean} [xunit.use=false] - Flag to activate xUnit report. Can be * overridden with CLI option `--xunit`. * @prop {string} [xunit.path=report.dir/xunit.xml] - Path to xUnit report. Can * be overridden with CLI option `--xunit-path`. * @prop {string} [xunit.suiteName=session.name] - xUnit suite name. Can be * overridden with CLI option `--xunit-suite-name`. * @prop {object} [allure] - Allure report namespace. * @prop {boolean} [allure.use=false] - Flag to activate allure report. Can be * overridden with CLI option `--allure`. * @prop {string} [allure.dir=report.dir/allure] - Folder to save allure report. * Can be overridden with CLI option `--allure-dir`. * @prop {string} [allure.suiteName=session.name] - Allure suite name. Can be * overridden with CLI option `--allure-suite-name`. * @prop {object} testrail - Testrail report namespace. * @prop {boolean} [testrail.use=false] - Flag to activate testrail report. Can * be overridden with CLI option `--testrail`. * @prop {string} testrail.host - Testrail host. Can be overridden with CLI * option `--testrail-host`. * @prop {string} testrail.user - Testrail user name or email. Can be overridden * with CLI option `--testrail-user`. * @prop {string} testrail.token - Testrail auth token. Can be overridden with * CLI option `--testrail-token`. * @prop {string} testrail.projectId - Testrail project ID. Can be overridden * with CLI option `--testrail-project-id`. * @prop {string} testrail.suiteId - Testrail suite ID. Can be overridden with * CLI option `--testrail-suite-id`. * @prop {string} testrail.runName - Testrail run name. Can be overridden with * CLI option `--testrail-run-name`. * @prop {string} testrail.runDescription - Testrail run description. Can be * overridden with CLI option `--testrail-run-description`. * @prop {object} plugins - Plugins namespace. * @prop {string} plugins.dir - Folder with custom plugins. Can be overridden * with CLI option `--plugins-dir`. * @prop {object} filter - Tests filter namespace. * @prop {string} filter.grep - Mocha grep option to filter tests, scopes and * suites. Can be overridden with CLI option `-g / --grep`. * @prop {array&lt;string&gt;} filter.include - List of test names which should be * included to tests session. Can be overridden with CLI option `--include`. * @prop {array&lt;string&gt;} filter.exclude - List of test names which should be * excluded from tests session. Can be overridden with CLI option `--exclude`. * @prop {boolean} [filter.precise=false] - Flag for precise tests inclusion or * exclusion (not substring pattern). Can be overridden with CLI option * `--precise`. * @prop {object} tools - Tools namespace. * @prop {boolean} [tools.stepsList=false] - Flag to list available steps only. * Can be overridden with CLI option `--list-steps`. * @prop {string} tools.stepsFilter - String to filter steps. Can be overridden * with CLI option `--list-steps`. * @prop {boolean} [tools.testsList=false] - Flag to list implemented tests * only. Can be overridden with CLI option `--list-tests`. * @prop {string} tools.testsFilter - String to filter tests. Can be overridden * with CLI option `--list-tests`. * @prop {boolean} [tools.fixturesList=false] - Flag to list available fixtures * only. Can be overridden with CLI option `--list-fixtures`. * @prop {string} tools.fixturesFilter - String to filter fixtures. Can be * overridden with CLI option `--list-fixtures`. * @prop {boolean} [tools.checkTestrail=false] - Flag to check matching of * testrail cases with implemented tests only. Can be overridden with CLI * option `--testrail-check`. */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); require(&quot;colors&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const U = require(&quot;glace-utils&quot;); U.docString(); const plugins = require(&quot;./plugins&quot;); let config = U.config; const args = config.args; if (U.config.__testmode) config = {}; // not affect global config in test mode config.cluster = U.defVal(config.cluster, {}); config.cluster.slavesNum = U.defVal(args.slaves, 0); if (config.cluster.slavesNum === &quot;auto&quot;) { config.cluster.slavesNum = require(&quot;os&quot;).cpus().length; } else { config.cluster.slavesNum = +config.cluster.slavesNum; } config.cluster.slaveId = parseInt(process.env.GLACE_SLAVE_ID) || null; config.cluster.isSlave = !!process.env.GLACE_SLAVE_ID; config.cluster.isMaster = !!config.cluster.slavesNum &amp;&amp; !config.cluster.isSlave; config.cluster.artifactsDir = path.resolve(U.cwd, U.defVal(args.reportDir, &quot;report&quot;)); config.session = U.defVal(config.session, {}); const date = new Date(); config.session.name = U.defVal(args.sessionName, `Session ${date.toLocaleString()}`); config.session.id = date.getTime(); config.session.errors = []; config.session.isPassed = false; config.session.preloads = []; config.session.interactive = args.i || args.interactive || false; if (config.cluster.slavesNum) { expect(config.session.interactive, &quot;Interactive mode is incompatible with `--slaves`&quot;).to.be.false; } config.session.debugOnFail = args.debugOnFail || false; if (config.cluster.slavesNum) { expect(config.session.debugOnFail, &quot;`--debug-on-fail` is incompatible with `--slaves`&quot;).to.be.false; } config.session.exitOnFail = args.exitOnFail || false; config.session.uncaughtException = (args.uncaught || &quot;log&quot;).toLowerCase(); expect([ &quot;log&quot;, &quot;fail&quot;, &quot;mocha&quot; ], &quot;Invalid `--uncaught` option&quot;).include(config.session.uncaughtException); if (args.rootConftest) config.session.rootConftest = path.resolve(U.cwd, args.rootConftest); if (args.killProcs &amp;&amp; !config.cluster.isSlave) config.session.killProcs = U.splitBy(args.killProcs, &quot;,&quot;); config.retry = U.defVal(config.retry, {}); config.retry.id = 0; config.retry.chunkIds = {}; config.retry.curChunkIds = null; const get_targets = () =&gt; { let tt; if (args._ &amp;&amp; args._.length) { tt = args._; } else if (args.targets &amp;&amp; args.targets.length) { tt = U.splitBy(args.targets, &quot;,&quot;); } else { tt = [&quot;tests&quot;]; }; return tt.map(t =&gt; path.resolve(U.cwd, t)); }; config.test = U.defVal(config.test, {}); config.test.id = 0; config.test.curCase = null; config.test.cases = []; config.test.languages = []; if (args.languages) config.test.languages = U.splitBy(args.languages, &quot;,&quot;); config.test.dirs = get_targets(); config.test.checkNames = !args.dontCheckNames; config.test.retries = Math.max(0, U.defVal(args.retry, 0)); config.chunk = U.defVal(config.chunk, {}); config.chunk.id = 0; config.chunk.curId = null; config.chunk.passedIds = []; config.chunk.retries = Math.max(0, U.defVal(args.chunkRetry, 0)); config.chunk.timeout = (args.chunkTimeout || 180) * 1000 || Infinity; config.report = U.defVal(config.report, {}); config.report.dots = args.dots || false; config.report.dir = config.cluster.artifactsDir; if (config.cluster.isMaster) { config.report.dir = path.resolve(config.report.dir, &quot;master&quot;); } if (config.cluster.isSlave) { config.report.dir = path.resolve(config.report.dir, &quot;slave-&quot; + config.cluster.slaveId); } config.report.testDir = null; config.report.clear = !args.dontClearReport; config.report.errorsNow = args.errorsNow || false; config.report.deepErrors = args.deepErrors || false; config.report.failedTestsPath = path.resolve(config.report.dir, U.defVal(args.failedTestsPath, &quot;failed-tests.json&quot;)); if (!config.report.failedTestsPath.endsWith(&quot;.json&quot;)) config.report.failedTestsPath += &quot;.json&quot;; const tests_filter = filter =&gt; { const filePath = path.resolve(U.cwd, filter); if (fs.existsSync(filePath)) { config.filter.precise = true; return U.loadJson(filePath); } else { return U.splitBy(filter, &quot;|&quot;).map(e =&gt; ({ id: e })); } }; config.filter = U.defVal(config.filter, {}); config.filter.grep = args.g || args.grep; config.filter.precise = args.preciseMatch || false; if (args.include) config.filter.include = tests_filter(args.include); if (args.exclude) config.filter.exclude = tests_filter(args.exclude); if (config.filter.include) { for (const include of config.filter.include) { if (!include.passed_chunk_ids) continue; config.chunk.passedIds = config.chunk.passedIds.concat(include.passed_chunk_ids); } } if (process.env.GLACE_TEST_IDS) { config.filter.testIds = U.splitBy(process.env.GLACE_TEST_IDS, &quot;,&quot;).map(i =&gt; +i); } else { config.filter.testIds = null; } config.xunit = U.defVal(config.xunit, {}); config.xunit.use = U.defVal(args.xunit, false); config.xunit.path = path.resolve(config.report.dir, U.defVal(args.xunitPath, &quot;xunit.xml&quot;)); config.xunit.suiteName = U.defVal(args.xunitSuiteName, config.session.name); config.allure = U.defVal(config.allure, {}); config.allure.use = U.defVal(args.allure, false); config.allure.dir = path.resolve(config.report.dir, U.defVal(args.allureDir, &quot;allure&quot;)); config.allure.suiteName = U.defVal(args.allureSuiteName, config.session.name); config.testrail = U.defVal(config.testrail, {}); config.testrail.use = U.defVal(args.testrail, false); config.testrail.host = U.defVal(args.testrailHost); config.testrail.user = U.defVal(args.testrailUser); config.testrail.token = U.defVal(args.testrailToken); config.testrail.projectId = U.defVal(args.testrailProjectId); config.testrail.suiteId = U.defVal(args.testrailSuiteId); config.testrail.runName = U.defVal(args.testrailRunName); config.testrail.runDescription = U.defVal(args.testrailRunDesc); config.plugins = U.defVal(config.plugins, {}); if (args.pluginsDir) config.plugins.dir = path.join(U.cwd, args.pluginsDir); config.plugins.disableDefault = U.defVal(args.disableDefaultPlugins, false); plugins.getModules(&quot;config&quot;); config.tools = U.defVal(config.tools, {}); config.tools.stepsList = !!args.listSteps; config.tools.stepsFilter = typeof(args.listSteps) === &quot;string&quot; ? args.listSteps : null; config.tools.testsList = !!args.listTests; config.tools.testsFilter = typeof(args.listTests) === &quot;string&quot; ? args.listTests : null; config.tools.fixturesList = !!args.listFixtures; config.tools.fixturesFilter = typeof(args.listFixtures) === &quot;string&quot; ? args.listFixtures : null; config.tools.pluginsList = !!args.listPlugins; config.tools.checkTestrail = U.defVal(args.testrailCheck, false); if (config.session.debugOnFail) { config.chunk.timeout = Infinity; config.xunit.use = false; config.allure.use = false; config.testrail.use = false; } if (config.session.interactive) { const temp = require(&quot;temp&quot;).track(); const tempPath = temp.path({ prefix: &quot;test&quot;, suffix: &quot;.js&quot; }); const tempData = &quot;test('interactive', () =&gt; chunk(async () =&gt; await $.debug()));&quot;; fs.writeFileSync(tempPath, tempData); config.test.dirs = [tempPath]; config.chunk.timeout = Infinity; config.filter.grep = null; config.filter.include = null; config.filter.exclude = null; config.xunit.use = false; config.allure.use = false; config.testrail.use = false; } let userConfig = {}; const userConfigPath = path.resolve(U.cwd, (args.userConfig || &quot;config.js&quot;)); if (fs.existsSync(userConfigPath)) userConfig = require(userConfigPath); _.assign(config, userConfig); module.exports = config; Ã— Search results Close "},"reporter_base.js.html":{"id":"reporter_base.js.html","title":"Source: reporter/base.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/base.js &quot;use strict&quot;; /** * `GlaceJS` common reporter. * * @class * @name GlaceReporter * @arg {object} runner - `MochaJS` runner. */ const fs = require(&quot;fs&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const colors = require(&quot;colors&quot;); const MochaReporter = require(&quot;mocha&quot;).reporters.base; const U = require(&quot;glace-utils&quot;); const LOG = U.logger; const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const utils = require(&quot;../utils&quot;); /** * Registered reporters. * * @type {object[]} */ let reporters = []; const GlaceReporter = function (runner) { MochaReporter.call(this, runner); runner.on(&quot;start&quot;, () =&gt; { for (const reporter of reporters) { if (reporter.start) reporter.start(); } }); runner.on(&quot;end&quot;, () =&gt; { const failedTests = CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED); if (!failedTests.length) { if (!CONF.session.errors.length) CONF.session.isPassed = true; } saveFailedTests(failedTests); if (fs.existsSync(CONF.report.dir)) { U.clearEmptyFolders(CONF.report.dir); } for (const reporter of reporters) { if (reporter.end) reporter.end(); } }); runner.on(&quot;suite&quot;, mochaSuite =&gt; { if (mochaSuite.root) return; // skip mocha root suite; const methodName = { undefined: &quot;scope&quot;, suite: &quot;suite&quot;, test: &quot;test&quot;, }[mochaSuite.title.type]; for (const reporter of reporters) { if (reporter[methodName]) reporter[methodName](mochaSuite); } }); runner.on(&quot;suite end&quot;, mochaSuite =&gt; { if (mochaSuite.root) return; // skip mocha root suite; const methodName = { undefined: &quot;scopeEnd&quot;, suite: &quot;suiteEnd&quot;, test: &quot;testEnd&quot;, }[mochaSuite.title.type]; for (const reporter of reporters) { if (reporter[methodName]) reporter[methodName](mochaSuite); } if (methodName === &quot;testEnd&quot;) { CONF.test.curCase = null; CONF.report.testDir = null; utils.setLog(); // Current test case is finished, need to reinit log } }); runner.on(&quot;test&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.chunk) reporter.chunk(mochaTest); } }); runner.on(&quot;test end&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.chunkEnd) reporter.chunkEnd(mochaTest); } }); runner.on(&quot;hook&quot;, mochaHook =&gt; { for (const reporter of reporters) { if (reporter.hook) reporter.hook(mochaHook); } }); runner.on(&quot;hook end&quot;, mochaHook =&gt; { for (const reporter of reporters) { if (reporter.hookEnd) reporter.hookEnd(mochaHook); } }); runner.on(&quot;pass&quot;, mochaTest =&gt; { passChunkId(); handleSkipState(mochaTest); const method = mochaTest.state === &quot;skipped&quot; ? &quot;skip&quot; : &quot;pass&quot;; for (const reporter of reporters) { if (reporter[method]) reporter[method](mochaTest); } }); runner.on(&quot;fail&quot;, (mochaTest, err) =&gt; { if (err.actual &amp;&amp; err.expected) { try { err.diff = colors.strip( MochaReporter.generateDiff(err.actual, err.expected)); if (err.diff.trim() === &quot;+ expected - actual&quot;) { delete err.diff; } } catch (e) { /* do nothing */ } } utils.accountError(mochaTest.title, err); for (const reporter of reporters) { if (reporter.fail) reporter.fail(mochaTest, err); } if (CONF.session.exitOnFail) { CONF.test.curCase.end(TestCase.FAILED); runner.emit(&quot;end&quot;); } }); runner.on(&quot;pending&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.pending) reporter.pending(mochaTest); } }); }; util.inherits(GlaceReporter, MochaReporter); module.exports = GlaceReporter; /** * Finalizes reporting. * * @function * @async * @arg {Array.&lt;*&gt;} failures - Tests failures. * @arg {function} fn - Finalizator. */ GlaceReporter.prototype.done = function (failures, fn) { let prms = Promise.resolve(); reporters.forEach(reporter =&gt; { if (reporter.done) { prms = prms .then(() =&gt; reporter.done()) .catch(e =&gt; LOG.error(e)); } }); return prms.then(() =&gt; fn(failures)); }; /** * Registers reporters if they are not. * * @method * @static * @arg {...object} reporters - Sequence of reporters to register. */ GlaceReporter.register = function () { for (const reporter of arguments) { if (!reporters.includes(reporter)) { reporters.push(reporter); } } }; /** * Removes reporters if they are registered. * * @method * @static * @arg {...object} reporters - Sequence of reporters to remove. */ GlaceReporter.remove = function () { const args = Array.from(arguments); args.unshift(reporters); reporters = _.without.apply(_, args); }; /** * Mark chunk as passed via its ID. * @ignore */ const passChunkId = () =&gt; { if (!CONF.chunk.curId) return; if (CONF.chunk.passedIds.includes(CONF.chunk.curId)) return; CONF.chunk.passedIds.push(CONF.chunk.curId); if (CONF.test.curCase) CONF.test.curCase.addPassedChunkId(CONF.chunk.curId); CONF.chunk.curId = null; }; /** * Handle skip state of mocha test. * @ignore */ const handleSkipState = mochaTest =&gt; { if (!CONF.test.curCase) return; if (CONF.test.curCase.skipChunk !== mochaTest.title) return; mochaTest.state = &quot;skipped&quot;; CONF.test.curCase.skipChunk = null; }; const saveFailedTests = failedTests =&gt; { if (fs.existsSync(CONF.report.failedTestsPath)) { try { fs.unlinkSync(CONF.report.failedTestsPath); } catch (e) { LOG.error(util.format(`Can't remove file '${CONF.report.failedTestsPath}'`, e)); return; } } const data = []; for (const failedTest of failedTests) { data.push({ id: failedTest.id, passed_chunk_ids: failedTest.passedChunkIds }); } try { fs.writeFileSync( CONF.report.failedTestsPath, JSON.stringify(data, null, &quot; &quot;)); } catch (e) { LOG.error(util.format(`Can't write file '${CONF.report.failedTestsPath}'`, e)); } }; Ã— Search results Close "},"run.js.html":{"id":"run.js.html","title":"Source: run.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: run.js &quot;use strict&quot;; /** * Runs tests. * * - executes `runner.js` file, which is entry point to load and execute * files with tests * - connects custom reporter to `mochajs`. * * @function * @name run * @arg {function} cb - Callback. */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var fse = require(&quot;fs-extra&quot;); var Mocha = require(&quot;mocha&quot;); const cluster = require(&quot;./cluster&quot;); var CONF = require(&quot;./config&quot;); var hacking = require(&quot;./hacking&quot;); var tools = require(&quot;./tools&quot;); const utils = require(&quot;./utils&quot;); var run = cb =&gt; { resetReport(); if (CONF.session.uncaughtException !== &quot;mocha&quot;) hacking.suppressMochaUncaught(); var mocha = new Mocha({ grep: CONF.filter.grep, timeout: CONF.chunk.timeout, retries: CONF.chunk.retries, reporter: path.resolve(__dirname, &quot;reporter&quot;) }); mocha.addFile(path.resolve(__dirname, &quot;loader.js&quot;)); if (cb) { _run(mocha, cb); } else { return new Promise(resolve =&gt; _run(mocha, resolve)); } }; /** * Runs mocha. * * @ignore */ var _run = (mocha, fin) =&gt; { mocha.run(code =&gt; { var clampedCode = Math.min(code, 255); if (CONF.session.isPassed) clampedCode = 0; if (!CONF.session.isPassed &amp;&amp; clampedCode === 0) clampedCode = 1; fin(clampedCode); }); }; /** * Resets report folder. * * @ignore */ var resetReport = () =&gt; { if (CONF.report.clear &amp;&amp; fs.existsSync(CONF.report.dir)) { fse.removeSync(CONF.report.dir); } fse.mkdirsSync(CONF.report.dir); }; /** * Runs glace framework. * * @arg {function} cb - Callback. */ var glaceRun = cb =&gt; { utils.setLog(); if (CONF.tools.stepsList) { tools.printSteps(CONF.tools.stepsFilter); return cb(); } else if (CONF.tools.fixturesList) { tools.printFixtures(CONF.tools.fixturesFilter); return cb(); } else if (CONF.tools.testsList) { tools.printTests(CONF.tools.testsFilter); return cb(); } else if (CONF.tools.checkTestrail) { return tools.checkTestrail(cb); } else if (CONF.tools.pluginsList) { return tools.printPlugins(cb); } else if (CONF.cluster.isMaster) { return cluster.launch(cb); } else { return run(cb); } }; module.exports = glaceRun; Ã— Search results Close "},"help.js.html":{"id":"help.js.html","title":"Source: help.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: help.js &quot;use strict&quot;; /** * Help description. * * @function * @name help * @arg {function} d - Function to process option description. * @arg {function} cb - Callback to expand default help. */ require(&quot;colors&quot;); var U = require(&quot;glace-utils&quot;); var plugins = require(&quot;./plugins&quot;); module.exports = (d, cb) =&gt; { d = d || U.switchColor(); cb = cb || (o =&gt; o); var result = U.help(d) .usage(&quot;\\nglace [options] [sequence-of-test-files-or-folders]&quot;.white.bold) .options({ /* configuration */ &quot;user-config [path]&quot;: { describe: d(&quot;Path to JS file with configuration which will be&quot;, &quot;merged with override default configuration.&quot;, &quot;Default is 'cwd/config.js' (if it exists).&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;session-name [name]&quot;: { describe: d(&quot;Tests run session name.&quot;, &quot;Default value includes word 'session' and datetime.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;grep &lt;pattern&gt;&quot;: { alias: &quot;g&quot;, describe: d(&quot;Filter tests by part of name (powered by mocha).&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;include &lt;sequence&gt;&quot;: { describe: d(&quot;Sequence of test name parts separated by ' | '&quot;, &quot;in order to choose tests for run. Or path to json file&quot;, &quot;with test names and params.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;exclude &lt;sequence&gt;&quot;: { describe: d(&quot;Sequence of test name parts separated by ' | '&quot;, &quot;in order to exclude tests from run. Or path to json file&quot;, &quot;with test names.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;precise-match&quot;: { describe: d(&quot;Precise tests inclusion or exclusion (not substring pattern).&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;report-dir [path]&quot;: { describe: d(&quot;Path to report folder. Default is 'cwd/report'.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;dont-clear-report&quot;: { describe: d(&quot;Don't clear previous report on tests run.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;dont-check-names&quot;: { describe: d(&quot;Don't check test names uniqueness&quot;, &quot;(usually useful in unit testing).&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;failed-tests-path [path]&quot;: { describe: d(&quot;Path to save failed tests in JSON format.&quot;, &quot;Default is 'cwd/report/failed-tests.json'.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;root-conftest &lt;path&gt;&quot;: { describe: d(&quot;Path to root conftest.js which will be loaded&quot;, &quot;before all.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;languages &lt;sequence&gt;&quot;: { describe: d(&quot;List of tested languages separated with comma.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;retry [times]&quot;: { describe: d(&quot;Number of times to retry failed test.&quot;, &quot;Default is 0.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;chunk-retry [times]&quot;: { describe: d(&quot;Number of times to retry failed chunk.&quot;, &quot;Default is 0.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;chunk-timeout [sec]&quot;: { describe: d(&quot;Time to execute chunk or hook, sec.&quot;, &quot;Default is 180.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;uncaught [type]&quot;: { describe: d(&quot;Strategy to process uncaught exceptions.&quot;, &quot;Default value is 'log'. See details in&quot;, &quot;https://glacejs.github.io/glace-core&quot;), type: &quot;string&quot;, choices: [ &quot;log&quot;, &quot;fail&quot;, &quot;mocha&quot; ], group: &quot;Core:&quot;, }, &quot;kill-procs &lt;sequence&gt;&quot;: { describe: d(&quot;List of process names separated with comma,&quot;, &quot;which will be killed before tests run.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;debug-on-fail&quot;: { describe: d(&quot;Enter to interactive debug mode on step failure.&quot;, &quot;Incompatible with '--slaves' option.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;exit-on-fail&quot;: { describe: d(&quot;Finish test run on first failure.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;dots&quot;: { describe: d(&quot;Print dots instead of test &amp; chunk names.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;errors-now&quot;: { describe: d(&quot;Print error message immediately when it happened.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;deep-errors&quot;: { describe: d(&quot;Print deep objects structure in error message.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;interactive&quot;: { describe: d(&quot;Launch interactive mode to execute steps&quot;, &quot;manually in terminal. Incompatible with '--slaves' option.&quot;), alias: &quot;i&quot;, type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;slaves &lt;number|auto&gt;&quot;: { describe: d(&quot;Split tests by slaves and execute them in&quot;, &quot;separated processes in parallel.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, /* plugins */ &quot;list-plugins&quot;: { describe: d(&quot;List plugins end exit.&quot;), type: &quot;boolean&quot;, group: &quot;Plugins:&quot;, }, &quot;plugins-dir [path]&quot;: { describe: d(&quot;Path to custom plugins folder. By default it searches&quot;, &quot;plugins inside folder, where 'glace-core' is installed.&quot;), type: &quot;string&quot;, group: &quot;Plugins:&quot;, }, &quot;disable-default-plugins&quot;: { describe: d(&quot;Disable default plugins.&quot;), type: &quot;boolean&quot;, group: &quot;Plugins:&quot;, }, /* xunit */ &quot;xunit&quot;: { describe: d(&quot;Activate xUnit reporter.&quot;), type: &quot;boolean&quot;, group: &quot;xUnit:&quot;, }, &quot;xunit-path [path]&quot;: { describe: d(&quot;Path to xUnit report. Default is 'cwd/report/xunit.xml'.&quot;), type: &quot;string&quot;, group: &quot;xUnit:&quot;, }, &quot;xunit-suite-name [name]&quot;: { describe: d(&quot;Tests suite name in xUnit report.&quot;, &quot;By default it's the same as session name.&quot;), type: &quot;string&quot;, group: &quot;xUnit:&quot;, }, /* allure */ &quot;allure&quot;: { describe: d(&quot;Activate Allure reporter.&quot;), type: &quot;boolean&quot;, group: &quot;Allure:&quot;, }, &quot;allure-dir [path]&quot;: { describe: d(&quot;Path to allure report folder. Default is 'cwd/report/allure'.&quot;), type: &quot;string&quot;, group: &quot;Allure:&quot;, }, /* testrail */ &quot;testrail&quot;: { describe: d(&quot;Activate TestRail reporter.&quot;), type: &quot;boolean&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-host &lt;host&gt;&quot;: { describe: d(&quot;TestRail host.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-user &lt;user&gt;&quot;: { describe: d(&quot;TestRail username or email.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-token &lt;token&gt;&quot;: { describe: d(&quot;TestRail token.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-project-id &lt;id&gt;&quot;: { describe: d(&quot;TestRail project id.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-suite-id &lt;id&gt;&quot;: { describe: d(&quot;TestRail suite id.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-run-name &lt;name&gt;&quot;: { describe: d(&quot;TestRail run name.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-run-desc &lt;description&gt;&quot;: { describe: d(&quot;TestRail run description.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, /* tools */ &quot;testrail-check&quot;: { describe: d(&quot;Check TestRail cases consistency with&quot;, &quot;implemented tests.&quot;), type: &quot;boolean&quot;, group: &quot;Tools:&quot;, }, &quot;list-steps [filter]&quot;: { describe: d(&quot;List available steps and exit.&quot;), group: &quot;Tools:&quot;, }, &quot;list-tests [filter]&quot;: { describe: d(&quot;List collected tests and exit.&quot;), group: &quot;Tools:&quot;, }, &quot;list-fixtures [filter]&quot;: { describe: d(&quot;List available fixtures and exit.&quot;), group: &quot;Tools:&quot;, }, }); for (var help of plugins.getModules(&quot;pluginHelp&quot;)) { result = help(result, d); } result = cb(result); result.epilog(&quot;Have a green test ;)&quot;.green.bold).argv; }; Ã— Search results Close "},"allure.js.html":{"id":"allure.js.html","title":"Source: allure.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: allure.js &quot;use strict&quot;; /** * [Allure](http://allure.qatools.ru/) wrapper. * * @module */ const fs = require(&quot;fs&quot;); const Allure = require(&quot;allure-js-commons&quot;); const Step = require(&quot;allure-js-commons/beans/step&quot;); const CONF = require(&quot;./config&quot;); let allure; if (CONF.allure.use) { allure = new Allure(); allure.setOptions({ targetDir: CONF.allure.dir }); allure.PASSED = &quot;passed&quot;; allure.FAILED = &quot;failed&quot;; allure.SKIPPED = &quot;skipped&quot;; /** * Defines if allure helper has steps or no. * * @memberOf module:allure * @method * @return {boolean} `true` if it has steps, `false` otherwise. */ allure.hasSteps = function () { return this.getCurrentSuite().currentStep instanceof Step; }; /** * Defines if test is started or no. * * @memberOf module:allure * @method * @return {boolean} `true` if test is started, `false` otherwise. */ allure.isTestStarted = function () { return !!(this.getCurrentSuite() &amp;&amp; this.getCurrentTest() &amp;&amp; !this.getCurrentTest().status); }; /** * Starts step if test is started. * * @memberOf module:allure * @method * @arg {string} name - Step name. */ allure.step = function () { if (this.isTestStarted()) this.startStep.apply(this, arguments); }; /** * Ends step as passed if test is started. * * @memberOf module:allure * @method */ allure.pass = function () { if (this.isTestStarted()) this.endStep(this.PASSED); }; /** * Adds test story if test is started. * * @memberOf module:allure * @method * @arg {string} name - Story name. */ allure.story = function (name) { if (!this.isTestStarted()) return; this.getCurrentTest().addLabel(&quot;story&quot;, name); }; /** * Adds test feature if test is started. * * @memberOf module:allure * @method * @arg {string} name - Feature name. */ allure.feature = function (name) { if (!this.isTestStarted()) return; this.getCurrentTest().addLabel(&quot;feature&quot;, name); }; /** * Adds test environment value if test is started. * * @memberOf module:allure * @method * @arg {string} name - Environment name. * @arg {string} value - Environment value. */ allure.addEnvironment = function (name, value) { if (!this.isTestStarted()) return; this.getCurrentTest().addParameter(&quot;environment-variable&quot;, name, value); }; /** * Adds test description if test is started. * * @memberOf module:allure * @method * @arg {string} desc - Description. * @arg {string} type - Mime type. */ allure.addDescription = function (desc, type) { if (!this.isTestStarted()) return; this.getCurrentTest().setDescription(desc, type); }; /** * Attach content to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Content name. * @arg {string} content - Content body. * @arg {string} type - Mime type. */ allure.attach = function (name, content, type) { if (!this.isTestStarted()) return; this.addAttachment(name, Buffer.from(content), type); }; /** * Attach JSON to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - JSON name. * @arg {string} obj - Object to convert to JSON. */ allure.attachJson = function (name, obj) { if (!this.isTestStarted()) return; this.attach(name, JSON.stringify(obj, null, &quot; &quot;), &quot;application/json&quot;); }; /** * Attach image to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Image name. * @arg {string} imgPath - Image path. */ allure.attachImage = function (name, imgPath) { if (!this.isTestStarted()) return; this.attach(name, fs.readFileSync(imgPath), &quot;image/png&quot;); }; /** * Attach video to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Video name. * @arg {string} videoPath - Video path. */ allure.attachVideo = function (name, videoPath) { if (!this.isTestStarted()) return; this.attach(name, fs.readFileSync(videoPath), &quot;video/mp4&quot;); }; /** * Attach text to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Text name. * @arg {string} txt - Text content. */ allure.attachText = function (name, txt) { this.attach(name, txt, &quot;text/plain&quot;); }; /** * Attach HTML to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - HTML name. * @arg {string} html - HTML content. */ allure.attachHtml = function (name, html) { this.attach(name, html, &quot;application/html&quot;); }; } else { allure = new Proxy({}, { get: () =&gt; () =&gt; {} }); }; module.exports = allure; Ã— Search results Close "},"classifier.js.html":{"id":"classifier.js.html","title":"Source: classifier.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: classifier.js &quot;use strict&quot;; /** * Wrapper on bayes classifier. * * @module */ var bayes = require(&quot;bayes&quot;); module.exports = () =&gt; { var classifier = bayes(); classifier.classify = function (text) { var tokens = this.tokenizer(text); var frequencyTable = this.frequencyTable(tokens); var result = []; for (var category in this.categories) { var item = { label: category, value: 0 }; result.push(item); for (var [token, frequency] of Object.entries(frequencyTable)) { var tokenProbability = this.tokenProbability(token, category); item.value += frequency * tokenProbability; }; }; result.sort((a, b) =&gt; b.value - a.value); return result; }; return classifier; }; Ã— Search results Close "},"cli.js.html":{"id":"cli.js.html","title":"Source: cli.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: cli.js &quot;use strict&quot;; /** * **Execute tests via command line interface.** * * @module */ require(&quot;./config&quot;); // configuration is before all! require(&quot;./help&quot;)(); const run = require(&quot;./run&quot;); /** * Run glace-core in CLI and exit process at the end. * * @function */ exports.run = () =&gt; run(process.exit); Ã— Search results Close "},"cluster.js.html":{"id":"cluster.js.html","title":"Source: cluster.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: cluster.js &quot;use strict&quot;; /** * **Is used to execute tests concurrently in subprocesses.** * * Scheduler process is named `master`, subprocesses with tests are `slaves`. * `Master` uses simple scheduling, splitting tests on parts by `slaves` number. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); require(&quot;colors&quot;); const _ = require(&quot;lodash&quot;); const fse = require(&quot;fs-extra&quot;); const spawn = require(&quot;cross-spawn&quot;); const U = require(&quot;glace-utils&quot;); const CONF = require(&quot;./config&quot;); const tools = require(&quot;./tools&quot;); module.exports = { /** * Launches tests in subprocesses. * * @async * @instance * @function * @arg {function} [cb] - Callback function executing at the end. * @arg {number} cb.exitCode - Subprocesses summary exit code. * @return {Promise&lt;number|*&gt;} Exit code if callback isn't passed, * or result providing by callback. */ launch: async cb =&gt; { cb = cb || (o =&gt; o); resetArtifactsDir(); await killProcs(); const argv = _.clone(process.argv); const cmd = argv.shift(); const testIds = getTestIds(); const procs = []; _.range(1, CONF.cluster.slavesNum + 1).forEach(i =&gt; { procs.push(new Promise(launchSlave(i, cmd, argv, testIds))); }); const codes = await Promise.all(procs); if (fs.existsSync(CONF.report.dir)) U.clearEmptyFolders(CONF.report.dir); printArtifactsDir(); const resultCode = calcExitCode(codes); return cb(resultCode); }, }; /** * Kills requested processes one time in `master`. In `slaves` killing is disabled. * * @ignore */ const killProcs = async () =&gt; { for (const procName of (CONF.session.killProcs || [])) { await U.killProcs(procName); } }; /** * Artifacts folder includes `master` report and `slaves` reports. * * @ignore */ const resetArtifactsDir = () =&gt; { if (CONF.report.clear &amp;&amp; fs.existsSync(CONF.cluster.artifactsDir)) { fse.removeSync(CONF.cluster.artifactsDir); } fse.mkdirsSync(CONF.cluster.artifactsDir); }; const printArtifactsDir = () =&gt; { console.log(); const reportMsg = &quot;Artifacts are in &quot; + CONF.cluster.artifactsDir; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }; const calcExitCode = codes =&gt; { let exitCode = 0; for (const code of codes) { if (code === 0) continue; exitCode = Math.min(exitCode + code, 255); } return exitCode; }; const getTestIds = () =&gt; { tools.fakeLoad(); let testIds = _.shuffle(CONF.test.cases.map(c =&gt; c.id)); return _.chunk(testIds, Math.ceil(testIds.length / CONF.cluster.slavesNum)); }; const launchSlave = (i, cmd, argv, testIds) =&gt; resolve =&gt; { const env = _.clone(process.env); env.GLACE_SLAVE_ID = i; env.GLACE_TEST_IDS = testIds[i - 1]; const opts = { env }; const stream = fs.createWriteStream( path.resolve(CONF.cluster.artifactsDir, `slave-${i}.stdout`)); console.log(`Slave #${i} is working...`.yellow); const proc = spawn(cmd, argv, opts); proc.stdout.pipe(stream); proc.stderr.pipe(stream); proc.on(&quot;close&quot;, endSlave(resolve, i)); }; const endSlave = (resolve, i) =&gt; code =&gt; { if (code === 0) { console.log(`Slave #${i} is succeeded`.green); } else { console.log(`Slave #${i} is failed with code ${code}`.red); } resolve(code); }; Ã— Search results Close "},"error.js.html":{"id":"error.js.html","title":"Source: error.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: error.js &quot;use strict&quot;; /** * Contains `GlaceJS` errors. * * @module */ const util = require(&quot;util&quot;); const GlaceError = require(&quot;glace-utils&quot;).GlaceError; /** * Error which is thrown when configuration is wrong. * * @class * @arg {string} message - Error message. */ const ConfigError = module.exports.ConfigError = function (message) { GlaceError.call(this, message); }; util.inherits(ConfigError, GlaceError); /** * Error which is thrown when step execution is wrong. * * @class * @arg {string} message - Error message. */ const StepError = module.exports.StepError = function (message) { GlaceError.call(this, message); }; util.inherits(StepError, GlaceError); Ã— Search results Close "},"hacking.js.html":{"id":"hacking.js.html","title":"Source: hacking.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: hacking.js &quot;use strict&quot;; /** * Contains hacks for test run. * * @module */ const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const LOG = require(&quot;glace-utils&quot;).logger; const Mocha = require(&quot;mocha&quot;); const Pending = require(&quot;mocha/lib/pending&quot;); const mochaUtils = require(&quot;mocha/lib/utils&quot;); mochaUtils.isString = _.isString; // monkey patch mocha to define instance of `String` as string not as object const CONF = require(&quot;./config&quot;); const utils = require(&quot;./utils&quot;); /** * Patches original `Mocha.Runner.prototype.uncaught` in order to process * uncaught exceptions flexible. * @ignore */ module.exports.suppressMochaUncaught = () =&gt; { Mocha.Runner.prototype.uncaught = function (err) { LOG.error(util.format(&quot;UNCAUGHT EXCEPTION&quot;, err)); if (CONF.session.uncaughtException === &quot;fail&quot;) { utils.accountError(&quot;Uncaught exception&quot;, err); } }; }; /** * Patches mocha runner to allow multiple independent `after`-calls. */ Mocha.Runner.prototype.hook = function(name, fn) { var suite = this.suite; var hooks = suite.getHooks(name); var self = this; function next(i) { var hook = hooks[i]; if (!hook) { return fn(); } self.currentRunnable = hook; if (name === &quot;beforeAll&quot;) { hook.ctx.currentTest = hook.parent.tests[0]; } else if (name === &quot;afterAll&quot;) { hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1]; } else { hook.ctx.currentTest = self.test; } self.emit(Mocha.Runner.constants.EVENT_HOOK_BEGIN, hook); if (!hook.listeners(&quot;error&quot;).length) { hook.on(&quot;error&quot;, function(err) { self.failHook(hook, err); }); } hook.run(function(err) { var testError = hook.error(); if (testError) { self.fail(self.test, testError); } if (err) { if (err instanceof Pending) { if (name === Mocha.Suite.constants.HOOK_TYPE_BEFORE_EACH || name === Mocha.Suite.constants.HOOK_TYPE_AFTER_EACH) { self.test.pending = true; } else { suite.tests.forEach(function(test) { test.pending = true; }); suite.suites.forEach(function(suite) { suite.pending = true; }); // a pending hook won't be executed twice. hook.pending = true; } } else { self.failHook(hook, err); // stop executing hooks, notify callee of hook err if (!name.startsWith(&quot;after&quot;)) return fn(err); } } self.emit(Mocha.Runner.constants.EVENT_HOOK_END, hook); delete hook.ctx.currentTest; next(++i); }); } Mocha.Runner.immediately(function() { next(0); }); }; Ã— Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: index.js &quot;use strict&quot;; /** * `GlaceJS` main module. * * @module * * @prop {object} config - {@link module:config|Config} module. * @prop {object} error - {@link module:error|Error} module. * @prop {function} help - {@link module:help|Help} module. * @prop {object} reporter - {@link module:reporter/index|Reporter} module. * @prop {object} run - {@link module:run|run} module. * @prop {object} Steps - {@link module:steps|Steps} module. */ var allure, config, error, help, plugins, reporter, run, Steps; Object.defineProperties(exports, { allure: { get: function () { allure = allure || require(&quot;./allure&quot;); return allure; }, }, /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, error: { get: function() { error = error || require(&quot;./error&quot;); return error; }, }, /** * Help. */ help: { get: function () { help = help || require(&quot;./help&quot;); return help; }, }, plugins: { get: function () { plugins = plugins || require(&quot;./plugins&quot;); return plugins; }, }, /** * @type {GlaceReporter} */ reporter: { get: function() { reporter = reporter || require(&quot;./reporter&quot;); return reporter; }, }, /** * @type {run} */ run: { get: function() { run = run || require(&quot;./run&quot;); return run; }, }, /** * @type {Steps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); Ã— Search results Close "},"loader.js.html":{"id":"loader.js.html","title":"Source: loader.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: loader.js /* global before session */ &quot;use strict&quot;; /** * Makes tests root session. * * - runner loads root `conftest.js` if it is located on one level with * each of `CONF.test.dirs`; * - if each of `CONF.test.dirs` is file with tests, runner loads and executes it; * - if each of `CONF.test.dirs` is folder runner loads files inside recursive if * file name starts with `test` and ends with `.js`; * - inside each subfolder of each of `CONF.test.dirs` runner loads `conftest.js` * file if it is present; * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const U = require(&quot;glace-utils&quot;); require(&quot;./globals&quot;); const CONF = require(&quot;./config&quot;); const ConfigError = require(&quot;./error&quot;).ConfigError; /** * Loads special `preloads` files before main conftests and test files. * * Preloads are specified in `CONF.preloads` array. It may be managed only * programmatically and needs as extension point to load some custom files * before tests. * * After preloads it loads root (the mainest) conftest file, which may be set * via CLI. */ const preloads = () =&gt; { const pre = _.clone(CONF.session.preloads); if (CONF.session.rootConftest &amp;&amp; !pre.includes(CONF.session.rootConftest)) { pre.push(CONF.session.rootConftest); } for (const preload of pre) { expect( fs.existsSync(preload) &amp;&amp; fs.statSync(preload).isFile(), `Preloader '${preload}' isn't a file or doesn't exist` ).to.be.true; require(preload); } }; /** * Main conftests are loaded before tests session creation and may used for * objects management, for example to created custom instance of global `SS`. * * Main conftest is `conftest.js` file which is located on one hierarchy level * with each specified tests folder or file. */ const mainConftests = () =&gt; { for (const testDir of CONF.test.dirs) { if (!fs.existsSync(testDir)) { throw new ConfigError( `Tests file or folder '${testDir}' doesn't exist`); } const siblingConftest = path.resolve(path.dirname(testDir), &quot;conftest.js&quot;); if (fs.existsSync(siblingConftest)) { require(siblingConftest); } } }; /** * Callback to create tests session. * * It kills some processes before all if they are specified. */ const sessFunc = () =&gt; { if (CONF.session.killProcs) { before(async () =&gt; { for (const procName of CONF.session.killProcs) { await U.killProcs(procName); } }); } for (const testDir of CONF.test.dirs) { if (!fs.statSync(testDir).isDirectory()) { reload(testDir); continue; } loadTests(testDir); } }; /** * Loads test files recursively. Test file name should start with `test` and * end with `.js`. * * @function * @arg {string} dir - Folder with test files. */ const loadTests = dir =&gt; { for (const fileName of fs.readdirSync(dir)) { const filePath = path.resolve(dir, fileName); const fileStat = fs.statSync(filePath); if (fileStat.isDirectory()) { loadTests(filePath); } if (fileStat.isFile()) { if (fileName === &quot;conftest.js&quot;) require(filePath); if (fileName.startsWith(&quot;test&quot;) &amp;&amp; fileName.endsWith(&quot;.js&quot;)) { reload(filePath); } } } }; const reload = filePath =&gt; { const fullPath = path.resolve(filePath); delete require.cache[fullPath]; return require(fullPath); }; if (!CONF.__testmode) { /* Starts session */ preloads(); mainConftests(); session(sessFunc); } Ã— Search results Close "},"matcher.js.html":{"id":"matcher.js.html","title":"Source: matcher.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: matcher.js &quot;use strict&quot;; /** * Matchers. * * @module */ var _ = require(&quot;lodash&quot;); var Assertion = require(&quot;chai&quot;).Assertion; var U = require(&quot;glace-utils&quot;); /** * Checks expectation corresponds to condition. * * @method * @arg {string} cond - conditions for assertion. * @arg {string} [msg] - message to throw in case of wrong conditions. * @example await $.checkBalance({ &quot;to be not equal&quot;: 100 }) Steps.prototype.checkBalance = async function (condition) { var currBalance = await this.getBalance(); expect(currBalance).correspond(condition, &quot;Invalid user balance&quot;); }; */ Assertion.prototype.correspond = function (cond, msg) { var matchers, expVal; if (msg) this.__flags.message = msg; if (typeof(cond) === &quot;object&quot;) { if (Object.keys(cond).length !== 1) { throw new Error(&quot;Condition should contain only one key-value pair&quot;); } matchers = Object.keys(cond)[0]; expVal = Object.values(cond)[0]; } else if (typeof(cond) === &quot;string&quot;) { matchers = cond; } else { throw new Error(&quot;Condition should be string or object only&quot;); } matchers = _.filter(_.split(matchers, &quot; &quot;)); var predicate = this; for (var matcher of matchers) { predicate = predicate[matcher]; if (!predicate) throw new TypeError(`Undefined matcher '${matcher}'`); } if (expVal) predicate.call(this, expVal); return this; }; /** * Checks expectation corresponds to condition during timeout. * * @arg {string|object} cond - Condition for assertion. * @arg {number} [timeout=1] - Timeout to wait for matching. * @arg {string} [msg] - Error message. * @throws {Error} If condition wasn't matched during timeout. */ Assertion.prototype.waitFor = async function (cond, timeout, msg) { var err = null; var predicate = async () =&gt; { try { return await new Assertion( await this.__flags.object(), this.__flags.message).correspond(cond, msg); } catch (e) { err = e; return false; } }; var result = await U.waitFor(predicate, { timeout: timeout }); if (result) return this; if (err) { throw err; } else { throw new Error(&quot;Unexpected matcher error&quot;); } }; Ã— Search results Close "},"plugins.js.html":{"id":"plugins.js.html","title":"Source: plugins.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: plugins.js &quot;use strict&quot;; /** * Plugins. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const U = require(&quot;glace-utils&quot;); const CONF = U.config; // HACK to avoid cross-import between config.js and plugins.js const LOG = U.logger; let systemPlugins = null; let customPlugins = []; /** * Get list of found and registered plugins. Each plugin is an object with keys: * `name` - plugin name, `path` - plugin path, `module` - loaded plugin module. * Order of resolving, if there plugins with the same names: * 1. Registered custom plugins. * 2. Plugins which are far from `glace-core` package. * * @function * @return {array&lt;object&gt;} */ const get = () =&gt; { if (!systemPlugins) { systemPlugins = []; systemPlugins = findPlugins(systemPlugins); systemPlugins = getPluginsFromDir(systemPlugins); systemPlugins = loadPlugins(systemPlugins); } const customPluginNames = getNames({ type: &quot;custom&quot; }); return systemPlugins .filter(p =&gt; !customPluginNames.includes(p.name)) .concat(customPlugins); }; /** * Traverse folders and find `glace` plugins. * @ignore */ const findPlugins = plugins =&gt; { if (CONF.plugins.disableDefault) return plugins; const SKIPPED_PACKAGES = [&quot;glace-js&quot;, &quot;glace-core&quot;, &quot;glace-utils&quot;]; const foundPlugins = []; const foundPluginNames = []; for (const pluginDir of dirsToSearchPlugins()) { if (!fs.existsSync(pluginDir)) continue; for (const fileName of fs.readdirSync(pluginDir)) { if (!fileName.startsWith(&quot;glace-&quot;) || SKIPPED_PACKAGES.includes(fileName) || foundPluginNames.includes(fileName)) continue; foundPlugins.push({ name: fileName, path: path.resolve(pluginDir, fileName), }); foundPluginNames.push(fileName); } } return plugins .filter(p =&gt; !foundPluginNames.includes(p.name)) .concat(foundPlugins); }; /** * Get list of plugins for folder specified in config. * @ignore */ const getPluginsFromDir = plugins =&gt; { if (!CONF.plugins.dir) return plugins; expect(fs.existsSync(CONF.plugins.dir) &amp;&amp; fs.statSync(CONF.plugins.dir).isDirectory(), `Plugins folder '${CONF.plugins.dir}' doesn't exist or isn't a folder`).to.be.true; const dirPlugins = []; const dirPluginNames = []; for (const fileName of fs.readdirSync(CONF.plugins.dir)) { dirPlugins.push({ name: fileName, path: path.resolve(CONF.plugins.dir, fileName), }); dirPluginNames.push(fileName); } return plugins .filter(p =&gt; !dirPluginNames.includes(p.name)) .concat(dirPlugins); }; /** * Load required plugins and return back list of loaded plugins. * @ignore */ const loadPlugins = plugins =&gt; { const loadedPlugins = []; for (const plugin of plugins) { try { plugin.module = require(plugin.path); loadedPlugins.push(Object.freeze(plugin)); } catch (e) { LOG.error(util.format(`Can't load plugin '${plugin.path}':`, e)); } } return loadedPlugins; }; /** * Gets modules from plugins. * * @arg {string} moduleName - Name of module to request from plugins. * @return {object[]} - List of modules requested from plugins. */ const getModules = moduleName =&gt; { const modules = []; for (const plugin of get()) { const mod = plugin.module[moduleName]; if (mod) modules.push(mod); } return modules; }; /** * Clear plugins cache. * * @function */ const clearCache = () =&gt; systemPlugins = null; /** * Registers custom plugin. * * @function * @arg {string} name - Name of plugin module. */ const register = name =&gt; { const customPluginNames = getNames({ type: &quot;custom&quot; }); if (customPluginNames.includes(name)) { LOG.warn(`Plugin '${name}' is registered already`); return; } customPlugins.push({ name: name, path: require.resolve(name), module: require(name), }); }; /** * Removes custom plugin from list of registered. * * @function * @arg {string} name - Name of registered plugin. */ const remove = name =&gt; { const customPluginNames = getNames({ type: &quot;custom&quot; }); if (!customPluginNames.includes(name)) { LOG.warn(`Plugin '${name}' isn't registered yet`); return; } customPlugins = customPlugins.filter(p =&gt; p.name !== name); }; /** * Gets names of plugins. * * @function * @arg {object} opts - Options. * @arg {string} [opts.type] - Type of plugins. Supported values are `custom` * and `system`, if omitted then names of all plugins will be returned. * @return {array&lt;string&gt;} Plugin names. */ const getNames = opts =&gt; { opts = opts || {}; let names; if (opts.type === &quot;custom&quot;) { names = customPlugins.map(p =&gt; p.name).sort(); } else if (opts.type === &quot;system&quot;) { names = (systemPlugins || []).map(p =&gt; p.name).sort(); } else { names = _.uniq((systemPlugins || []).map(p =&gt; p.name).concat(customPlugins.map(p =&gt; p.name))).sort(); }; return names; }; /** * Get folders to search plugins. * @ignore */ const dirsToSearchPlugins = () =&gt; { const pluginDirs = _.clone(module.paths); if (require.main) { const mainDir = path.dirname(require.main.filename); if (!pluginDirs.includes(mainDir)) { pluginDirs.unshift(mainDir); } } if (!pluginDirs.includes(U.cwd)) { pluginDirs.unshift(U.cwd); } return pluginDirs; }; module.exports = { get, getModules, getNames, register, remove, clearCache, }; Ã— Search results Close "},"reporter_allure.js.html":{"id":"reporter_allure.js.html","title":"Source: reporter/allure.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/allure.js &quot;use strict&quot;; /** * Allure reporter. * * @module */ require(&quot;colors&quot;); const allure = require(&quot;../allure&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; module.exports = { start: () =&gt; { allure.startSuite(CONF.allure.suiteName); }, end: () =&gt; { reportSkippedTests(); allure.endSuite(); console.log(); const reportMsg = &quot;Allure report is &quot; + CONF.allure.dir; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, suite: suite =&gt; { allure.startSuite(suite.title); }, suiteEnd: () =&gt; { allure.endSuite(); }, scope: scope =&gt; { if (!allure.isTestStarted()) return; allure.startStep(scope.title); allure.getCurrentSuite().currentStep.isScope = true; // small hack }, scopeEnd: () =&gt; { if (allure.isTestStarted()) allure.endStep(); }, test: test =&gt; { allure.startCase(test.title); }, testEnd: () =&gt; { if (CONF.test.curCase.status === TestCase.PASSED) { allure.endCase(allure.PASSED); } if (CONF.test.curCase.status === TestCase.FAILED) { allure.endCase(allure.FAILED, getErrors(CONF.test.curCase)); } }, chunk: chunk =&gt; { allure.startStep(chunk.title); }, skip: () =&gt; { while (allureNotScope()) allure.endStep(allure.SKIPPED); }, pass: () =&gt; { while (allureNotScope()) allure.endStep(allure.PASSED); }, fail: () =&gt; { while (allureNotScope()) allure.endStep(allure.FAILED); }, }; const allureNotScope = () =&gt; allure.hasSteps() &amp;&amp; !allure.getCurrentSuite().currentStep.isScope; const getErrors = testCase =&gt; { const result = {}; const errMsgs = getErrMsgs(testCase.errors); if (errMsgs.length === 0) { result.message = &quot;Show details âž¤&quot;; } else if (errMsgs.length === 1) { result.message = errMsgs[0]; } else { let n = 0; result.message = errMsgs.map(i =&gt; `${++n}. ${i}`).join(&quot;\\r&quot;); } result.stack = testCase.errors.map(e =&gt; e.split(&quot;\\n&quot;).join(&quot;\\r&quot;)).join(&quot;\\n\\r&quot;); return result; }; const getErrMsgs = errs =&gt; { const result = []; for (const err of errs) { for (const line of err.split(&quot;\\n&quot;)) { if (line.startsWith(&quot;message: &quot;)) { result.push(line.substr(9)); break; }; } } return result; }; const reportSkippedTests = () =&gt; { const skipped = CONF.test.cases.filter(t =&gt; t.status === TestCase.SKIPPED); for (const skip of skipped) { allure.startCase(skip.name); if (skip.rawInfo[0]) { allure.endCase(allure.SKIPPED, { message: skip.rawInfo[0] }); } else { allure.endCase(allure.SKIPPED); } } }; Ã— Search results Close "},"reporter_dots.js.html":{"id":"reporter_dots.js.html","title":"Source: reporter/dots.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/dots.js &quot;use strict&quot;; /** * Glace dots reporter. * * @module */ require(&quot;colors&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const utils = require(&quot;../utils&quot;); let i = 0; module.exports = { suite: suite =&gt; { if (suite.title.toString() == CONF.session.name) { const msg = Array(i).join(&quot;\\n&quot;) + &quot;&gt;&quot;.cyan.bold + &quot; &quot;; process.stdout.write(msg); i = 2; } }, pass: () =&gt; { process.stdout.write(&quot;.&quot;.green); }, fail: () =&gt; { process.stdout.write(&quot;x&quot;.red); }, end: () =&gt; { const failedTests = CONF.test.cases.filter( t =&gt; t.status === TestCase.FAILED); utils.printTestErrors(failedTests); utils.printSessionErrors(); }, done: console.log, }; Ã— Search results Close "},"reporter_index.js.html":{"id":"reporter_index.js.html","title":"Source: reporter/index.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/index.js &quot;use strict&quot;; /** * GlaceJS reporter package. * * @module */ const CONF = require(&quot;../config&quot;); const plugins = require(&quot;../plugins&quot;); const base = require(&quot;./base&quot;); const main = () =&gt; { if (CONF.report.dots) { base.register(require(&quot;./dots&quot;)); } else { base.register(require(&quot;./stdout&quot;)); }; if (CONF.testrail.use) base.register(require(&quot;./testrail&quot;)); if (CONF.xunit.use) base.register(require(&quot;./xunit&quot;)); if (CONF.allure.use) base.register(require(&quot;./allure&quot;)); for (const reporter of plugins.getModules(&quot;reporter&quot;)) { base.register(reporter); } return base; }; module.exports = CONF.__testmode ? main : main(); Ã— Search results Close "},"reporter_stdout.js.html":{"id":"reporter_stdout.js.html","title":"Source: reporter/stdout.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/stdout.js &quot;use strict&quot;; /** * `GlaceJS` stdout reporter. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const colors = require(&quot;colors&quot;); const fse = require(&quot;fs-extra&quot;); const MochaReporter = require(&quot;mocha&quot;).reporters.base; const prettyms = require(&quot;pretty-ms&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const utils = require(&quot;../utils&quot;); let report; let indents = 0; /** * Calculate message indentation. * @ignore */ const indent = () =&gt; Array(indents).join(&quot; &quot;); /** * Write report to stdout. * @ignore */ const stdout = function() { report.write(colors.strip(util.format.apply(util, arguments)) + &quot;\\n&quot;); console.log.apply(console, arguments); }; /** * Print epilogue results. * @ignore */ const epilogue = () =&gt; { const passedTests = [], failedTests = [], skippedTests = []; for (const testCase of CONF.test.cases) { if (testCase.status === TestCase.FAILED) { failedTests.push(testCase); } if (testCase.status === TestCase.PASSED) { passedTests.push(testCase); } if (testCase.status === TestCase.SKIPPED) { skippedTests.push(testCase); } } printStatistics(passedTests.length, failedTests.length); if (skippedTests.length) printSkippedTests(skippedTests); utils.printTestErrors(failedTests, stdout); utils.printSessionErrors(stdout); }; /** * Prints tests statistics. * @ignore */ const printStatistics = (passedNum, failedNum) =&gt; { let msg; const indent = &quot; &quot;; if (passedNum) { msg = &quot;passed test&quot; + (passedNum === 1 ? &quot;&quot; : &quot;s&quot;); stdout((indent + MochaReporter.symbols.ok + &quot; &quot; + String(passedNum).bold + &quot; &quot; + msg).green); } if (failedNum) { msg = &quot;failed test&quot; + (failedNum === 1 ? &quot;&quot; : &quot;s&quot;); stdout((indent + MochaReporter.symbols.err + &quot; &quot; + String(failedNum).bold + &quot; &quot; + msg).red); } const chunksNum = CONF.test.cases.reduce((a, b) =&gt; a + b.chunks.length, 0); if (chunksNum) { msg = &quot;executed chunk&quot; + (chunksNum === 1 ? &quot;&quot; : &quot;s&quot;); stdout(indent + chunksNum + &quot; &quot; + msg); } let execTime = CONF.test.cases .map(t =&gt; t.duration) .reduce((a, b) =&gt; a + b, 0); if (execTime &gt; 0) { execTime = (execTime &lt; 60000 ? `${execTime / 1000} sec` : prettyms(execTime)).bold; stdout(); stdout(indent + &quot;Summary tests time is&quot;, execTime); } }; /** * Prints skipped tests. * @ignore */ const printSkippedTests = skippedTests =&gt; { let msg; const indent = &quot; &quot;; msg = &quot;skipped test&quot; + (skippedTests.length === 1 ? &quot;&quot; : &quot;s&quot;); stdout(); // HACK https://github.com/glacejs/glace-core/issues/136 stdout(indent + &quot;# &quot;.gray + String(skippedTests.length).gray.bold + &quot; &quot; + msg.gray); for (const skip of skippedTests) { msg = `* '${skip.name}'`; if (skip.rawInfo[0]) { msg += &quot; - &quot; + skip.rawInfo[0].bold; } stdout(indent + indent + msg.gray); } }; module.exports = { /** * Called before tests start. * * @method * @instance */ start: () =&gt; { fse.mkdirsSync(CONF.report.dir); report = fs.createWriteStream( path.resolve(CONF.report.dir, &quot;stdout.log&quot;), { flags : &quot;w&quot; }); }, /** * Called before tests end. * * @method * @instance */ end: () =&gt; { epilogue(); stdout(); const reportMsg = &quot;Local report is &quot; + CONF.report.dir; stdout(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); stdout(reportMsg.yellow); }, /** * Called on scope start. * * @method * @instance * @arg {object} scope - `MochaJS` suite. */ scope: scope =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;scope: &quot; + scope.title).cyan); } }, /** * Called before scope end. * * @method * @instance */ scopeEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on suite start. * * @method * @instance * @arg {object} suite - `MochaJS` suite. */ suite: suite =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;suite: &quot; + suite.title).cyan); } }, /** * Called before suite end. * * @method * @instance */ suiteEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on test start. * * @method * @instance * @arg {object} test - `MochaJS` suite. */ test: test =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;test: &quot; + test.title).cyan.bold); } }, /** * Called on test end. * * @method * @instance */ testEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on chunk passed. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ pass: chunk =&gt; { let msg = indent() + &quot; &quot; + MochaReporter.symbols.ok + &quot; chunk&quot;; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.green); }, /** * Called on chunk skipped. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ skip: chunk =&gt; { let msg = indent() + &quot; # chunk&quot;; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.gray); }, /** * Called on chunk or hook failed. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ fail: chunk =&gt; { let suffix = chunk.type === &quot;hook&quot; ? &quot; hook&quot; : &quot; chunk&quot;; let msg = indent() + &quot; &quot; + MochaReporter.symbols.err + suffix; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.red); if (CONF.report.errorsNow) { let errMsg; if (CONF.test.curCase) { errMsg = _.last(CONF.test.curCase.errors); } else { errMsg = _.last(CONF.session.errors); } stdout(errMsg.red.bold); } }, /** * Called on report finalizing. * * @method * @instance */ done: () =&gt; new Promise(resolve =&gt; report.end(resolve)), }; Ã— Search results Close "},"reporter_testrail.js.html":{"id":"reporter_testrail.js.html","title":"Source: reporter/testrail.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/testrail.js &quot;use strict&quot;; /** * [TestRail](https://www.gurock.com/testrail) reporter publishs test results * to remote testrail server via its API. * * @module */ const util = require(&quot;util&quot;); const expect = require(&quot;chai&quot;).expect; const Testrail = require(&quot;testrail-api&quot;); const LOG = require(&quot;glace-utils&quot;).logger; const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; for (const opt in CONF.testrail) { expect(CONF.testrail[opt], `TestRail option '${opt}' is not specified in config`) .to.exist; } const testrail = new Testrail({ host: CONF.testrail.host, user: CONF.testrail.user, password: CONF.testrail.token }); testrail.isFailed = false; const Results = { PASSED: 1, BLOCKED: 2, UNTESTED: 3, RETEST: 4, FAILED: 5 }; const cases = {}; let report = Promise.resolve(); const Reporter = { /** * Called on tests start. * * @method * @instance */ start: () =&gt; { report = report.then(() =&gt; { return testrail.getCases( CONF.testrail.projectId, { suite_id: CONF.testrail.suiteId }); }).then(result =&gt; { for (const remoteCase of result.body) { if (cases[remoteCase.title]) { throw new Error(&quot;Detect duplicated cases in TestRail for &quot; + `name '${remoteCase.title}'. Only unique names should be.`); } cases[remoteCase.title] = { id: remoteCase.id }; } }).then(() =&gt; { return testrail.addRun(CONF.testrail.projectId, { suite_id: CONF.testrail.suiteId, name: CONF.testrail.runName, description: CONF.testrail.runDescription }); }).then(result =&gt; { CONF.testrail.runId = result.body.id; }).catch(e =&gt; { testrail.isFailed = true; LOG.error(util.format(&quot;Error to init TestRail report:&quot;, e)); }); }, /** * Called before tests end. * * @method * @instance */ end: () =&gt; { if (testrail.isFailed) return; console.log(); const reportMsg = &quot;TestRail report is &quot; + CONF.testrail.host + &quot;/index.php?/runs/view/&quot; + CONF.testrail.runId; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, /** * Called on test end. * * @method * @instance */ testEnd: () =&gt; { if (testrail.isFailed) return; const testrailCase = cases[CONF.test.curCase.name]; if (!testrailCase) { LOG.error(`Testrail case '${CONF.test.curCase.name}' is absent`); return; } const testResult = { status_id: Results.PASSED, comment: &quot;&quot; }; testResult.comment = Reporter.setComment(); if (CONF.test.curCase.status === TestCase.SKIPPED) { testResult.status_id = Results.BLOCKED; } if (CONF.test.curCase.screenshots.length) { testResult.comment += Reporter.processScreens(CONF.test.curCase.screenshots); } if (CONF.test.curCase.videos.length) { testResult.comment += Reporter.processVideos(CONF.test.curCase.videos); } if (CONF.test.curCase.status === TestCase.FAILED) { testResult.status_id = Results.FAILED; testResult.comment += Reporter.processErrors(CONF.test.curCase.errors); } if (CONF.test.curCase.rawInfo.length) { testResult.comment += Reporter.processExtras(CONF.test.curCase.rawInfo); } testResult.comment = testResult.comment.trim(); report = report.then(() =&gt; { return testrail.addResultForCase( CONF.testrail.runId, testrailCase.id, testResult); }).catch(e =&gt; { LOG.error(util.format( `Error to publish test '${CONF.test.curCase.name}' report to TestRail:`, e)); }); }, /** * Called on report finalizing. * * @method * @instance */ done: () =&gt; report, }; /** * Entry point to set comment of test before testrail publication. * Can be overridden with custom function. * * @memberOf module:reporter/testrail * @instance * @function setComment * @return {string} - Test comment. * * @example &lt;caption&gt;&lt;b&gt;Overriding with custom function&lt;/b&gt;&lt;/caption&gt; * // should be after configuration but before tests run * const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); * testrail.setComment = myFuncToSetComment; */ Reporter.setComment = () =&gt; &quot;&quot;; /** * Entry point to process test screenshot paths before testrail publication. * Can be overridden with custom function. * * @memberOf module:reporter/testrail * @instance * @function processScreens * @arg {string[]} screens - List of screenshot paths. * @return {string} - Test screenshots info, attaching to test comment. * * @example &lt;caption&gt;&lt;b&gt;Overriding with custom function&lt;/b&gt;&lt;/caption&gt; * // should be after configuration but before tests run * const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); * testrail.processScreens = myFuncToProcessScreens; */ Reporter.processScreens = screens =&gt; { let result = &quot;\\n\\nScreenshots:&quot;; screens.forEach((screen, i) =&gt; { result += `\\n${i + 1}. ${screen}`; }); return result; }; /** * Entry point to process test video paths before testrail publication. * Can be overridden with custom function. * * @memberOf module:reporter/testrail * @instance * @function processVideos * @arg {string[]} videos - List of video paths. * @return {string} - Test videos info, attaching to test comment. * * @example &lt;caption&gt;&lt;b&gt;Overriding with custom function&lt;/b&gt;&lt;/caption&gt; * // should be after configuration but before tests run * const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); * testrail.processVideos = myFuncToProcessVideos; */ Reporter.processVideos = videos =&gt; { let result = &quot;\\n\\nVideos:&quot;; videos.forEach((video, i) =&gt; { result += `\\n${i + 1}. ${video}`; }); return result; }; /** * Entry point to process test errors before testrail publication. * Can be overridden with custom function. * * @memberOf module:reporter/testrail * @instance * @function processErrors * @arg {string[]} errors - List of test errors. * @return {string} - Test errors info, attaching to test comment. * * @example &lt;caption&gt;&lt;b&gt;Overriding with custom function&lt;/b&gt;&lt;/caption&gt; * // should be after configuration but before tests run * const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); * testrail.processErrors = myFuncToProcessErrors; */ Reporter.processErrors = errors =&gt; { let result = &quot;\\n\\nErrors:&quot;; errors.forEach((error, i) =&gt; { result += `${i ? &quot;\\n&quot; : &quot;&quot;}\\n${i + 1}. ${error}`; }); return result; }; /** * Entry point to process test extra details before testrail publication. * Can be overridden with custom function. * * @memberOf module:reporter/testrail * @instance * @function processExtras * @arg {string[]} extras - List of extra details. * @return {string} - Test extra details, attaching to test comment. * * @example &lt;caption&gt;&lt;b&gt;Overriding with custom function&lt;/b&gt;&lt;/caption&gt; * // should be after configuration but before tests run * const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); * testrail.processExtras = myFuncToProcessExtras; */ Reporter.processExtras = extras =&gt; { let result = &quot;\\n\\nExtra details:&quot;; extras.forEach((extra, i) =&gt; { result += `${i ? &quot;\\n&quot; : &quot;&quot;}\\n${i + 1}. ${extra}`; }); return result; }; module.exports = Reporter; Ã— Search results Close "},"reporter_xunit.js.html":{"id":"reporter_xunit.js.html","title":"Source: reporter/xunit.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: reporter/xunit.js &quot;use strict&quot;; /** * `GlaceJS` xunit reporter. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); require(&quot;colors&quot;); const escape = require(&quot;mocha&quot;).utils.escape; const fse = require(&quot;fs-extra&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; let stream; module.exports = { start: () =&gt; { if (fs.existsSync(CONF.xunit.path)) { fs.unlinkSync(CONF.xunit.path); } }, end: () =&gt; { fse.mkdirsSync(path.dirname(CONF.xunit.path)); stream = fs.createWriteStream(CONF.xunit.path); write(tag(&quot;testsuite&quot;, { name: CONF.xunit.suiteName, tests: CONF.test.cases.length, failures: CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED).length, errors: CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED).length, skipped: CONF.test.cases.filter(t =&gt; t.status === TestCase.SKIPPED).length, timestamp: new Date().toUTCString(), time: (CONF.test.cases.map(t =&gt; t.duration).reduce((a, b) =&gt; a + b, 0) / 1000) || 0 }, false)); CONF.test.cases.forEach(t =&gt; writeTest(t)); write(&quot;&lt;/testsuite&gt;&quot;); console.log(); const reportMsg = &quot;xUnit report is &quot; + CONF.xunit.path; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, done: () =&gt; new Promise(resolve =&gt; stream.end(resolve)), }; /** * Writes a line. * * @arg {string} line - Report text line. */ const write = line =&gt; { stream.write(line + &quot;\\n&quot;); }; /** * Writes a test. * * @arg {TestCase} test - Test case. */ const writeTest = test =&gt; { const attrs = { classname: test.name, name: test.name, time: (test.duration / 1000) || 0 }; if (test.status === TestCase.FAILED) { const err = test.errors.join(&quot;\\n&quot;); write(tag(&quot;testcase&quot;, attrs, false, tag(&quot;failure&quot;, {}, false, escape(err)))); } else if (test.status === TestCase.SKIPPED) { write(tag(&quot;testcase&quot;, attrs, false, tag(&quot;skipped&quot;, {}, true))); } else { write(tag(&quot;testcase&quot;, attrs, true)); } }; /** * HTML tag helper. (copied from mochajs) * * @ignore * @param name * @param attrs * @param close * @param content * @return {string} */ function tag (name, attrs, close, content) { const end = close ? &quot;/&gt;&quot; : &quot;&gt;&quot;; const pairs = []; let tag; for (const key in attrs) { if (Object.prototype.hasOwnProperty.call(attrs, key)) { pairs.push(key + &quot;=\\&quot;&quot; + escape(attrs[key]) + &quot;\\&quot;&quot;); } } tag = &quot;&lt;&quot; + name + (pairs.length ? &quot; &quot; + pairs.join(&quot; &quot;) : &quot;&quot;) + end; if (content) { tag += content + &quot;&lt;/&quot; + name + end; } return tag; } Ã— Search results Close "},"testing.js.html":{"id":"testing.js.html","title":"Source: testing.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: testing.js &quot;use strict&quot;; /** * Contains classes and functions to save executed tests data. * * @module */ var expect = require(&quot;chai&quot;).expect; /** * Test case data structure. * * Contains full information and history about test case. * * @class * @arg {string} name - Test name. * @prop {string} name - Test name. * @prop {string} [status=NOT_STARTED] - Test status. * @prop {?string} [skipChunk=null] - Name of currently skipped chunk. * @prop {string[]} [screenshots=[]] - List of test screenshot paths. * @prop {string[]} [videos=[]] - List of test video paths. * @prop {string[]} [errors=[]] - List of test errors. * @prop {string[]} [rawInfo=[]] - List of additional test details. * @prop {object} [testParams={}] - Dict of test parameters. */ var TestCase = module.exports.TestCase = function (name, id) { this.duration = 0; this.name = name; this.id = id; this.status = TestCase.NOT_STARTED; this.skipChunk = null; this.chunks = []; this.passedChunkIds = []; this.reset(); }; /** * Starts test case. * * @method */ TestCase.prototype.start = function () { expect(this.status, `test case '${this.name}' is started already`) .to.not.be.equal(TestCase.IN_PROGRESS); this._startTime = new Date(); this.status = TestCase.IN_PROGRESS; }; /** * Ends test case. * * @method * @arg {string} status - Test case status. */ TestCase.prototype.end = function (status) { expect(this.status, `test case '${this.name}' isn't started yet`) .to.be.equal(TestCase.IN_PROGRESS); this.duration += new Date() - this._startTime; this.status = status; }; /** * Resets test case info. * * @method */ TestCase.prototype.reset = function () { this.screenshots = []; this.videos = []; this.errors = []; this.rawInfo = []; this.testParams = {}; }; /** * Adds passed chunk id. * * @method * @arg {string} chunkId - Chunk id. */ TestCase.prototype.addPassedChunkId = function (chunkId) { if (!chunkId || this.passedChunkIds.includes(chunkId)) return; this.passedChunkIds.push(chunkId); }; /** * Adds passed chunk ids. * * @method * @arg {array&lt;string&gt;} chunkIds - Chunk ids. */ TestCase.prototype.addPassedChunkIds = function (chunkIds) { for (const chunkId of chunkIds) this.addPassedChunkId(chunkId); }; /** * Adds error to test case. * * @method * @arg {Error} err - Test error. */ TestCase.prototype.addError = function (err) { this.errors.push(err); }; /** * Adds screenshot. * * @method * @arg {string} imagePath - Path to saved screenshot. */ TestCase.prototype.addScreenshot = function (imagePath) { this.screenshots.push(imagePath); }; /** * Adds video. * * @method * @arg {string} videoPath - Path to saved video. */ TestCase.prototype.addVideo = function (videoPath) { this.videos.push(videoPath); }; /** * Adds additional information. * * @method * @arg {string} info - Additional information. */ TestCase.prototype.addDetails = function (info) { this.rawInfo.push(info); }; /** * Adds chunk. * * @method * @arg {string} chunkName - Name of chunk. */ TestCase.prototype.addChunk = function (chunkName) { this.chunks.push(chunkName); }; TestCase.NOT_STARTED = &quot;not started&quot;; TestCase.IN_PROGRESS = &quot;in progress&quot;; TestCase.FAILED = &quot;failed&quot;; TestCase.PASSED = &quot;passed&quot;; TestCase.SKIPPED = &quot;skipped&quot;; /** * Class defining mochajs scope name and type. */ class ScopeType extends String { /** * Set mochajs scope type. * @arg {string} type - Supported values are `scope`, `suite`, `test`. */ setType (type) { this.type = type; return this; } }; module.exports.ScopeType = ScopeType; Ã— Search results Close "},"tools.js.html":{"id":"tools.js.html","title":"Source: tools.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: tools.js &quot;use strict&quot;; /** * Glace tools. * * @module */ const util = require(&quot;util&quot;); require(&quot;colors&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const highlight = require(&quot;cli-highlight&quot;).highlight; const Testrail = require(&quot;testrail-api&quot;); const U = require(&quot;glace-utils&quot;); const classifier = require(&quot;./classifier&quot;)(); const CONF = require(&quot;./config&quot;); const plugins = require(&quot;./plugins&quot;); const utils = require(&quot;./utils&quot;); const d = U.switchColor(); let stepsCache = null; /** * Get list of steps data, where step data is an object with keys: * `name` - name of step, `decription` - short details of steps, * `doc` - documentation of step. * * @memberOf module:tools * @function * @arg {string} [filter] - String chunk to filter steps. * @arg {boolean} [namesOnly=false] - Flag to filter by step names only. * @return {array&lt;object&gt;} */ const listSteps = (filter, namesOnly=false) =&gt; { if (!stepsCache) { stepsCache = getStepsData(getStepNames()); learnClassifier(stepsCache); } if (!filter) return stepsCache; return filterSteps(stepsCache, filter, namesOnly); }; /** * Print list of steps in stdout. * * @memberOf module:tools * @function * @arg {string} [filter] - String chunk to filter steps. * @arg {boolean} [namesOnly=false] - Flag to filter by step names only. */ const printSteps = (filter, namesOnly=false) =&gt; { const steps = listSteps(filter, namesOnly); if (!steps.length) { console.log(&quot;No steps are found&quot;.yellow); return; } steps.reverse().forEach((step, i) =&gt; { console.log(d(`${i+1}. ${step.name}:`)); console.log(d(step.description)); if (step.doc) console.log(highlight(step.doc, { language: &quot;js&quot; })); }); }; /** * Print list of implemented test cases. * * &lt;img src=&quot;./list_tests.gif&quot; title=&quot;listTests example&quot; /&gt; * * @memberOf module:tools * @name listTests * @function * @arg {string} [filter] - String chunk to filter test cases. */ const printTests = filter =&gt; { fakeLoad(); let cases = CONF.test.cases; if (filter) cases = cases.filter(c =&gt; U.textContains(c.name, filter)); if (!cases.length) { console.log(&quot;No tests are found&quot;.yellow); return; } cases.forEach((c, i) =&gt; { console.log(d(`${i+1}. ${c.name}`)); }); }; /** * Print list of available plugins. * * &lt;img src=&quot;./list_plugins.gif&quot; title=&quot;listPlugins example&quot; /&gt; * * @memberOf module:tools * @name listPlugins * @function */ const printPlugins = () =&gt; { const pluginsList = plugins.get(); if (!pluginsList.length) { console.log(&quot;No plugins are detected&quot;.yellow); return; } pluginsList.forEach((p, i) =&gt; { console.log(`${i+1}. ${p.name}`.yellow, p.path); }); }; /** * Get list of available fixtures. * * @memberOf module:tools * @function * @arg {string} [filter] - String chunk to filter fixtures. * @arg {boolean} [namesOnly=false] - Flag to filter by fixture names only. * @return {array&lt;object&gt;} */ const listFixtures = (filter, namesOnly=false) =&gt; { fakeLoad(); const fixtures = getFixtures(); if (!filter) return fixtures; return filterFixtures(fixtures, filter, namesOnly); }; /** * Print list of fixtures in stdout. * * @memberOf module:tools * @function * @arg {string} [filter] - String chunk to filter fixtures. * @arg {boolean} [namesOnly=false] - Flag to filter by fixture names only. */ const printFixtures = (filter, namesOnly=false) =&gt; { const fixtures = listFixtures(filter, namesOnly); if (!fixtures.length) { console.log(&quot;No fixtures are found&quot;.yellow); return; } fixtures.forEach((fx, i) =&gt; { console.log(d(`${i+1}. ${fx.name}`)); if (fx.doc) console.log(highlight(fx.doc, { language: &quot;js&quot; })); }); }; /** * Make fake load of tests in order to collect tests, fixtures, steps, etc. * * @memberOf module:tools * @function */ const fakeLoad = () =&gt; { const dummy = () =&gt; {}; global.before = dummy; global.after = dummy; global.beforeEach = dummy; global.afterEach = dummy; global.it = dummy; global.describe = (name, cb) =&gt; { cb.call({ retries: dummy, timeout: dummy, }); }; require(&quot;./globals&quot;); require(&quot;./loader&quot;); }; /** * Check testrail cases consistency with implemented tests. * * @memberOf module:tools * @function * @arg {function} cb - Callback function. */ const checkTestrail = cb =&gt; { checkTestrailOpts(); fakeLoad(); console.log(&quot;TestRail connecting...&quot;.yellow); const testrail = new Testrail({ host: CONF.testrail.host, user: CONF.testrail.user, password: CONF.testrail.token }); checkTestrailCases(testrail, cb); }; module.exports = { checkTestrail, fakeLoad, listSteps, printSteps, printTests, printPlugins, listFixtures, printFixtures, }; /** * Check testrail options. * @ignore */ const checkTestrailOpts = () =&gt; { for (const opt in CONF.testrail) { expect(CONF.testrail[opt], `TestRail option '${opt}' isn't specified in config`) .to.exist; } }; /** * Check testrail missed cases which are implemented. * @ignore */ const checkTestrailMissed = cases =&gt; { const testrailNames = cases.map(case_ =&gt; case_.title); const testNames = CONF.test.cases.map(case_ =&gt; case_.name); const missed = _.difference(testNames, testrailNames); if (!missed.length) return 0; console.log(&quot;\\nMissed TestRail cases:&quot;.magenta.bold); missed.forEach((title, i) =&gt; { console.log(`${i+1}. ${title}`.cyan.bold); }); return 1; }; /** * Check testrail cases which are not implemented yet. * @ignore */ const checkTestrailNotImplemented = cases =&gt; { const testrailNames = cases.map(case_ =&gt; case_.title); const testNames = CONF.test.cases.map(case_ =&gt; case_.name); const notImplemented = _.difference(testrailNames, testNames); if (!notImplemented.length) return 0; console.log(&quot;\\nNot implemented TestRail cases:&quot;.magenta.bold); notImplemented.forEach((title, i) =&gt; { console.log(`${i+1}. ${title}`.cyan.bold); }); return 1; }; /** * Check testrail duplicated cases. * @ignore */ const checkTestrailDuplicates = cases =&gt; { const testrailNames = []; let testrailDups = []; cases.forEach(case_ =&gt; { if (testrailNames.includes(case_.title)) { testrailDups.push(case_.title); } else { testrailNames.push(case_.title); } }); testrailDups = _.uniq(testrailDups); if (!testrailDups.length) return 0; console.log(&quot;\\nTestRail duplicated cases:&quot;.magenta.bold); testrailDups.forEach((title, i) =&gt; { console.log(`${i+1}. ${title}`.cyan.bold); }); return 1; }; /** * Check testrail cases. * @ignore */ const checkTestrailCases = (client, cb) =&gt; { client.getCases( CONF.testrail.projectId, { suite_id: CONF.testrail.suiteId }, (err, response, cases) =&gt; { if (err) { console.log(err); cb(1); return; } let errorCode = 0; errorCode += checkTestrailDuplicates(cases); errorCode += checkTestrailNotImplemented(cases); errorCode += checkTestrailMissed(cases); if (!errorCode) { console.log(&quot;TestRail cases correspond current tests&quot;.green.bold); } console.log( &quot;\\nTestRail suite is&quot;, `${CONF.testrail.host}/index.php?/suites/view/${CONF.testrail.suiteId}`.yellow); cb(errorCode); }); }; /** * Get fixtures. * @ignore */ const getFixtures = () =&gt; { const fixtures = []; for (const name in global) { if (!name.startsWith(&quot;fx&quot;)) continue; const func = global[name]; if (!util.isFunction(func)) continue; fixtures.push({ name: name, doc: utils.getDoc(func), }); } return fixtures; }; /** * Filter fixtures. * @ignore */ const filterFixtures = (fixtures, filter, namesOnly) =&gt; { const filtered = []; for (const fx of fixtures) { if (namesOnly) { if (!U.textContains(fx.name, filter)) continue; } else { if (!U.textContains(fx.name, filter) &amp;&amp; !U.textContains(fx.doc, filter)) continue; } filtered.push(fx); } return filtered; }; /** * Get list of step names. * * @ignore * @function * @return {array&lt;string&gt;} */ const getStepNames = () =&gt; { global.$ || fakeLoad(); const NOT_STEPS = [ &quot;constructor&quot;, &quot;hasOwnProperty&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;toLocaleString&quot;, &quot;toString&quot;, &quot;valueOf&quot;, ]; let names = []; for (const key in $) { names.push(key); }; names = _.union( names, Object.getOwnPropertyNames($), Object.getOwnPropertyNames(Object.getPrototypeOf($)) ).sort() .filter(i =&gt; !i.startsWith(&quot;_&quot;)) .filter(i =&gt; /^\\w+$/.test(i)) .filter(i =&gt; !NOT_STEPS.includes(i)) .filter(i =&gt; /^\\D/.test(i)); return names; }; /** * Get list of step data, where step data is an object with keys: * `name` - name of step, `decription` - short details of steps, * `doc` - documentation of step. * * @ignore * @function * @arg {array&lt;string&gt;} names - List of step names. * @return {array&lt;object&gt;} */ const getStepsData = names =&gt; { const result = []; for (const name of names) { const func = $[name]; if (!util.isFunction(func)) continue; result.push({ name: name, description: funcDescription(func), doc: utils.getDoc(func), }); }; return result; }; /** * Learn classifier on step names and description. * @ignore */ const learnClassifier = steps =&gt; { steps.forEach(step =&gt; classifier.learn(step.doc, step.name)); }; /** * Filter steps and return relevant result merged with ML predictions. * @ignore */ const filterSteps = (steps, filter, namesOnly) =&gt; { let filtered = []; for (const step of steps) { if (namesOnly) { if (!U.textContains(step.name, filter)) continue; } else { if (!U.textContains(step.name, filter) &amp;&amp; !U.textContains(step.doc, filter)) continue; } filtered.push(step); } if (!namesOnly) { const classified = classifySteps(steps, filter); filtered = mergeSteps(classified, filtered); } return filtered; }; /** * Get classified steps based on ML. * @ignore */ const classifySteps = (steps, filter) =&gt; { const result = []; const sampling = classifier.classify(filter); for (const sample of sampling) { for (const step of steps) { if (sample.label === step.name) result.push(step); } } return result; }; /** * Merge steps. * @ignore */ const mergeSteps = (base, merging) =&gt; { const usedNames = base.map(s =&gt; s.name); const result = _.clone(base); for (const step of merging) { if (!usedNames.includes(step.name)) result.push(step); } return result; }; /** * Get function description. * @ignore */ const funcDescription = func =&gt; { return &quot; &quot; + func.toString().replace(&quot;\\n&quot;, &quot; &quot;).split(/\\) *\\{/)[0] + &quot;) {...}&quot;; }; Ã— Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: utils.js &quot;use strict&quot;; /** * Utils. * * @module */ const path = require(&quot;path&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const U = require(&quot;glace-utils&quot;); const LOG = U.logger; const CONF = require(&quot;./config&quot;); /** * Helper to set actual log file. * * @function */ module.exports.setLog = () =&gt; { const logsDir = CONF.report.testDir || CONF.report.dir; const logFile = path.resolve(logsDir, &quot;logs&quot;, &quot;test.log&quot;); LOG.setFile(logFile); }; /** * Account test error and add it to test or session errors. * * @function */ module.exports.accountError = (errMsg, err) =&gt; { errMsg = errMsg || &quot;&quot;; if (CONF.test.curCase &amp;&amp; !_.isEmpty(CONF.test.curCase.testParams)) { errMsg += &quot;\\n&quot; + util.format(CONF.test.curCase.testParams); } if (err.message) { errMsg += &quot;\\nmessage: &quot; + err.message; } if (err.diff) { errMsg += err.diff; } if (err.stack) { errMsg += &quot;\\nstack: &quot; + err.stack; } if (err.seleniumStack) { errMsg += &quot;\\nselenium: &quot; + JSON.stringify(err.seleniumStack, null, &quot;\\t&quot;); } errMsg = errMsg.trim(); if (CONF.test.curCase) { CONF.test.curCase.addError(errMsg); } else { CONF.session.errors.push(errMsg); } }; /** * Get function description. * * @function * @arg {function} func - Function to read documentation. * @return {string} Documentation. */ module.exports.getDoc = func =&gt; { let doc = func.__doc__; if (!doc) return &quot;&quot;; doc = doc .split(&quot;\\n&quot;) .map(i =&gt; i.trim()) .filter(i =&gt; i) .map(i =&gt; ` ${i}`) .join(&quot;\\n&quot;); if (!doc) return &quot;&quot;; return ` /**\\n${doc}\\n */`; }; module.exports.printTestErrors = (failedTests, log = console.log) =&gt; { if (!failedTests.length) return; log(); log(&quot;TEST FAILURES:&quot;.bold); for (const testCase of failedTests) { log(); log((&quot;test: &quot; + testCase.name).cyan.bold); printErrors(testCase.errors, log); } }; module.exports.printSessionErrors = (log = console.log) =&gt; { if (!CONF.session.errors.length) return; log(); log(&quot;OUTTEST FAILURES:&quot;.bold); printErrors(CONF.session.errors, log); }; const printErrors = (errors, log) =&gt; { for (let error of errors) { error = error.split(&quot;\\n&quot;).map(line =&gt; { if (line.trim() === &quot;+ expected - actual&quot;) { return line .replace(&quot;+ expected&quot;, &quot;+ expected&quot;.green.bold) .replace(&quot;- actual&quot;, &quot;- actual&quot;.red.bold); } if (line.trim().startsWith(&quot;+ &quot;)) { return line.green.bold; } return line.red.bold; }).join(&quot;\\n&quot;); log(); log(error); } }; Ã— Search results Close "},"globals_scope.js.html":{"id":"globals_scope.js.html","title":"Source: globals/scope.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/scope.js &quot;use strict&quot;; const _ = require(&quot;lodash&quot;); const U = require(&quot;glace-utils&quot;); /** * Execute tests scope. * * @global * @function * @arg {string} name - Scope name. * @arg {function[]} [fixtures] - List of fixtures. * @arg {object} [opts] - Scope options. * @arg {number} [opts.chunkRetry] - Number of chunk retries on failure. * @arg {number} [opts.chunkTimeout] - Time to execute chunk or hook, sec. * @arg {function} func - Callback function with test cases. * @example scope(&quot;Some test scope&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); */ const scope = (name, fixtures, opts, func) =&gt; { if (_.isFunction(opts)) [func, opts] = [opts]; if (_.isPlainObject(fixtures)) [opts, fixtures] = [fixtures]; if (_.isFunction(fixtures)) [func, fixtures] = [fixtures]; fixtures = fixtures || []; opts = opts || {}; describe(name, scopeCb(fixtures, opts, func)); }; /** * Scope callback. * @ignore */ const scopeCb = (fixtures, opts, func) =&gt; function () { if (opts.chunkRetry) this.retries(opts.chunkRetry); if (opts.chunkTimeout) this.timeout(opts.chunkTimeout * 1000); U.wrap(fixtures, func)(); }; module.exports = scope; Ã— Search results Close "},"globals_session.js.html":{"id":"globals_session.js.html","title":"Source: globals/session.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/session.js &quot;use strict&quot;; const _ = require(&quot;lodash&quot;); const CONF = require(&quot;../config&quot;); /** * Executes tests session. * * @global * @function * @arg {string} [name] - Session name. By default it includes start date time. * @arg {object} [fixtures=[]] - Session fixtures. * @arg {function} func - Function with test cases. * @example session(() =&gt; { test(&quot;Test #1&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); test(&quot;Test #2&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); }); */ const session = (name, fixtures, func) =&gt; { if (_.isFunction(fixtures)) [func, fixtures] = [fixtures]; if (_.isArray(name)) [fixtures, name] = [name]; if (_.isFunction(name)) [func, name] = [name]; name = name || CONF.session.name; fixtures = fixtures || []; CONF.session.errors = []; suite(name, fixtures, sessCb(name, fixtures, func)); }; /** * Session callback. * @ignore */ const sessCb = (name, fixtures, func) =&gt; () =&gt; { func(); after(afterCb(name, fixtures, func)); }; /** * After-hook callback. * @ignore */ const afterCb = (name, fixtures, func) =&gt; () =&gt; { delete CONF.retry.chunkIds[CONF.retry.id]; if (_.isEmpty(CONF.retry.chunkIds)) return; CONF.retry.id++; CONF.test.id = 0; suite(name, fixtures, sessCb(name, fixtures, func)); }; module.exports = session; Ã— Search results Close "},"steps_index.js.html":{"id":"steps_index.js.html","title":"Source: steps/index.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: steps/index.js &quot;use strict&quot;; /** * Creates new instance of `Steps` class. * * @class * @classdesc Contains collection of steps which may be called inside tests via * its instance [$](global.html#$). It mixes steps from plugins too. * @name Steps * @mixes TimerSteps * @prop {object} ctx - Storage to share some data between steps. */ var util = require(&quot;util&quot;); require(&quot;colors&quot;); var _ = require(&quot;lodash&quot;); var U = require(&quot;glace-utils&quot;); var CONF = require(&quot;../config&quot;); var plugins = require(&quot;../plugins&quot;); var tools = require(&quot;../tools&quot;); const utils = require(&quot;../utils&quot;); var Steps = function () { this.ctx = {}; }; module.exports = Steps; Steps.prototype.resetCtx = function () { /** * Helper to reset steps context. * * @memberOf Steps * @method resetCtx * @instance */ this.ctx = {}; }; Steps.prototype.isTestFailed = function () { /** * Helper to check whether test was failed before current step. * * @memberOf Steps * @method isTestFailed * @instance * @return {undefined|boolean} `undefined` if test is absent, * `true` if test was failed, `false` otherwise. */ if (!CONF.test.curCase) return; return !!CONF.test.curCase.errors.length; }; Steps.prototype.debug = async function () { /** * Step to enter to interactive debugging mode. May be used inside test if you * need to debug test in runtime. * * @async * @memberOf Steps * @method debug * @instance * @return {Promise&lt;void&gt;} * @example * * test(&quot;my test&quot;, () =&gt; { * chunk(async () =&gt; { * await $.debug(); * }); * }); */ var onFail = CONF.session.debugOnFail; CONF.session.debugOnFail = false; await U.debug(setupDebug()); CONF.session.debugOnFail = onFail; }; Steps.prototype.listSteps = function (filter, namesOnly) { /** * Step to list available steps [debug mode]. * * @memberOf Steps * @method listSteps * @instance * @arg {string} filter - Steps filter. * @arg {boolean} [namesOnly=false] - Search among step names only. By default * full-text search is used. */ tools.printSteps(filter, namesOnly); }; /** * Registers steps (mixes them). * * @method * @static * @arg {...object} steps - Sequence of steps to register. * @example * * var MyStepsMixin = require(&quot;./my-steps-mixin&quot;); * var AnotherStepsMixin = require(&quot;./another-steps-mixin&quot;); * * Steps.register(MyStepsMixin, AnotherStepsMixin); */ Steps.register = function () { for (var obj of arguments) { _.assign(this.prototype, obj); } }; /** * Helper to get steps instance. * * It wraps steps class with proxy object. Proxy observes steps call and in * debug mode if steps is failed it entered test to interactive debug mode. * * @method * @static * @arg {function} [cls] - Class with steps. By default original glace `Steps` * will be used. * @return {Proxy} Wrapped steps instance. */ Steps.getInstance = function (cls) { return new Proxy( new (cls || Steps), { get: (target, property) =&gt; { var func = target[property]; if (!util.isFunction(func)) return func; if (property === &quot;debug&quot; || !CONF.session.debugOnFail) { return func; } return async function () { try { var result = await func.apply(target, arguments); } catch (e) { console.log(util.format(e).red); await target.debug(); throw e; } return result; }; }, }); }; Steps.register(require(&quot;./timer&quot;)); /* Load plugins steps */ Steps.register.apply(Steps, plugins.getModules(&quot;Steps&quot;)); /** * Set up debug mode for glace. * @ignore */ const setupDebug = () =&gt; { global.search = $.listSteps.bind($); global.doc = f =&gt; { const doc = utils.getDoc(f); if (doc) { console.log(doc.green); } else { console.log(&quot;No docs found&quot;.yellow); } }; const helpMsg = &quot;In interactive mode you can execute any nodejs code or glace step.\\n&quot; + &quot;Available commands:\\n&quot; + &quot;- search([query string]) - Searchs a glace step according to query. &quot; + &quot;For ex: &gt; search('step to start timer');\\n&quot; + &quot;- doc(function) - Prints function documentation;\\n&quot;; return helpMsg; }; Ã— Search results Close "},"globals_test.js.html":{"id":"globals_test.js.html","title":"Source: globals/test.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: globals/test.js &quot;use strict&quot;; const path = require(&quot;path&quot;); const _ = require(&quot;lodash&quot;); const U = require(&quot;glace-utils&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const ScopeType = require(&quot;../testing&quot;).ScopeType; const setLog = require(&quot;../utils&quot;).setLog; const _test = (names =&gt; { return (name, fixtures, opts, func) =&gt; { CONF.test.id++; CONF.chunk.id = 0; let preloaded_passed_chunk_ids; if (CONF.filter.testIds &amp;&amp; !CONF.filter.testIds.includes(CONF.test.id)) return; if (CONF.filter.include) { let isIncluded = false; for (const include of CONF.filter.include) { if (isFilterMatched(name, include.id)) { preloaded_passed_chunk_ids = include.passed_chunk_ids; isIncluded = true; break; } } if (!isIncluded) return; } if (CONF.filter.exclude) { for (const exclude of CONF.filter.exclude) { if (isFilterMatched(name, exclude.id)) return; } } if (CONF.test.checkNames &amp;&amp; !CONF.retry.id) { if (names.includes(name)) { throw new Error(`Test case '${name}' is added already`); } names.push(name); } const skip = !!opts.skip; const skipReason = _.isString(opts.skip) ? opts.skip : null; const retries = U.defVal(opts.retry, CONF.test.retries, 0); opts.chunkRetry = U.defVal(opts.chunkRetry, CONF.chunk.retries, 0); opts.chunkTimeout = U.defVal(opts.chunkTimeout); let testCase; if (!CONF.retry.id) { testCase = new TestCase(name, CONF.test.id); testCase.addPassedChunkIds(preloaded_passed_chunk_ids || []); CONF.test.cases.push(testCase); if (skip) { testCase.status = TestCase.SKIPPED; if (skipReason) testCase.addDetails(skipReason); } } else { testCase = CONF.test.cases.filter(t =&gt; t.id === CONF.test.id)[0]; expect(testCase, &quot;Oops! Testcase isn't found by id&quot;).to.exist; } if (testCase.status === TestCase.SKIPPED) return; if (!CONF.retry.chunkIds[retries]) CONF.retry.chunkIds[retries] = []; CONF.retry.curChunkIds = CONF.retry.chunkIds[retries]; testFunc({ testCase, fixtures, opts, func }); }; })([]); const testFunc = ({ testCase, fixtures, opts, func }) =&gt; { fixtures = [initTestFixture(testCase)].concat(fixtures); const scopeType = new ScopeType(testCase.name).setType(&quot;test&quot;); scope(scopeType, fixtures, opts, () =&gt; { func(); }); }; const initTestFixture = testCase =&gt; { return U.makeFixture({ before: beforeCb(testCase), after: afterCb }); }; const beforeCb = testCase =&gt; ctx =&gt; () =&gt; { ctx.testCase = testCase; ctx.testCase.reset(); ctx.testCase.start(); CONF.test.curCase = ctx.testCase; CONF.report.testDir = path.resolve( CONF.report.dir, &quot;tests&quot;, U.toKebab(ctx.testCase.name)); setLog(); // Current test case is started, need to reinit log }; const afterCb = ctx =&gt; () =&gt; { if (ctx.testCase.errors.length) { ctx.testCase.end(TestCase.FAILED); } else { ctx.testCase.end(TestCase.PASSED); } }; const isFilterMatched = (testName, filterId) =&gt; { if (filterId == CONF.test.id) return true; filterId = filterId.toString(); if (CONF.filter.precise) { return testName.toLowerCase() === filterId.toLowerCase(); } else { return testName.toLowerCase().includes(filterId.toLowerCase()); } }; /** * Global function, existing in `glace` tests, which creates test case. * * @global * @function * @arg {string} name - Name of test case. By default, should be unique in session. * But uniqueness check can be skipped with CLI option `--dont-check-names`. * @arg {object} [opts] - Options. * @arg {boolean|string} [opts.skip=false] - Flag to skip test or skip reason message. * @arg {?number} [opts.retry=null] - Number of test retries on failure. Overrides * [config](GlaceConfig.html#test-retry) settings. * @arg {?number} [opts.chunkRetry=null] - &lt;a name=&quot;test-chunk-retry&quot; href=&quot;#test-chunk-retry&quot;&gt;#&lt;/a&gt; * Number of chunk retries on failure. Overrides [config](GlaceConfig.html#test-chunk-retry) settings. * @arg {?number} [opts.chunkTimeout=null] - &lt;a name=&quot;test-chunk-timeout&quot; href=&quot;#test-chunk-timeout&quot;&gt;#&lt;/a&gt; * Time to execute chunk or hook, **sec**. Overrides [config](GlaceConfig.html#test-chunk-timeout) settings. * @arg {function[]} [fixtures] - Involved [fixtures](tutorial-common-used-funcs.html#fixtures) list. * @arg {function} func - Ð¡allback function with [chunks](#chunk__anchor) and hooks. * * @example &lt;caption&gt;&lt;b&gt;Simple test&lt;/b&gt;&lt;/caption&gt; * * test(&quot;Some test&quot;, () =&gt; { * chunk(&quot;Some chunk&quot;, () =&gt; { * someFunc(); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Test with retry&lt;/b&gt;&lt;/caption&gt; * * test(&quot;Test with retry&quot;, { retry: 2 }, () =&gt; { * chunk(() =&gt; { * someFunc(); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Test with fixtures&lt;/b&gt;&lt;/caption&gt; * * test(&quot;Test with fixtures&quot;, null, [fix_func_1, fix_func_2], () =&gt; { * chunk(() =&gt; { * someFunc(); * }); * }); */ const test = (name, fixtures, opts, func) =&gt; { if (_.isFunction(opts)) [func, opts] = [opts]; if (_.isPlainObject(fixtures)) [opts, fixtures] = [fixtures]; if (_.isFunction(fixtures)) [func, fixtures] = [fixtures]; fixtures = fixtures || []; opts = opts || {}; _test(name, fixtures, opts, func); }; module.exports = test; Ã— Search results Close "},"steps_timer.js.html":{"id":"steps_timer.js.html","title":"Source: steps/timer.js","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Source: steps/timer.js /* global expect */ &quot;use strict&quot;; /** * Steps to measure time. * * These methods will be mixed with glacejs [Steps](https://glacejs.github.io/glace-core/Steps.html) * class and available via its instance [$](https://glacejs.github.io/glace-core/global.html#$) * in tests. * * @mixin TimerSteps */ var util = require(&quot;util&quot;); var U = require(&quot;glace-utils&quot;); var LOG = U.logger; var A = require(&quot;../allure&quot;); var TimerSteps = { pause: async function (timeout, message) { /** * Step to make pause in another step or test case. **Good style** is * to not use directly in test case, only inside another step. * * @async * @memberOf TimerSteps * @method pause * @instance * @arg {number} timeout - Pause time, sec. * @arg {string} message - Pause reason. * @return {Promise&lt;void&gt;} * @throws {AssertionError} If pause message is not defined. * @example * * await $.pause(1, &quot;wait for server start&quot;); */ A.step(`Sleep ${timeout} sec because ${message}`); expect(message, &quot;Pause message is not defined&quot;).to.not.be.undefined; LOG.warn(util.format(&quot;Sleep&quot;, timeout, &quot;sec, reason:&quot;, message)); await U.sleep(timeout * 1000); A.pass(); }, startTimer: function () { /** * Step to start timer. * Each time when it will be called, timer will be reset. * * @memberOf TimerSteps * @method startTimer * @instance * @example * * $.startTimer(); * await $.pause(1, &quot;sleep a bit&quot;); * var elapsedSeconds = $.getTimer(); */ A.step(&quot;Start timer&quot;); this._timer = new Date(); A.pass(); }, stopTimer: function () { /** * Step to stop timer. * * @memberOf TimerSteps * @method stopTimer * @instance * @example * * $.stopTimer(); */ A.step(&quot;Stop timer&quot;); this._timer = null; A.pass(); }, getTimer: function () { /** * Step to get timer. * * @memberOf TimerSteps * @method getTimer * @instance * @return {number} Number of seconds since timer starts. * @throws {AssertionError} If timer is not started. * @example * * $.startTimer(); * await $.pause(1, &quot;sleep a bit&quot;); * var elapsedSeconds = $.getTimer(); */ A.step(&quot;Get timer value&quot;); expect(this._timer, &quot;Timer is not started&quot;).to.exist; var result = (new Date() - this._timer) / 1000; A.pass(); return result; }, checkTimer: function (condition) { /** * Step to check timer. * * @memberOf TimerSteps * @method checkTimer * @instance * @arg {string|object} condition - [chaijs](http://chaijs.com/) condition. * @throws {AssertionError} If timer verification was failed. * @example * * $.startTimer(); * $.checkTimer(&quot;to exist&quot;); * * $.startTimer(); * await $.pause(1, &quot;sleep a bit&quot;); * $.checkTimer({ &quot;to be gte&quot;: 1 }); */ if (typeof(condition) === &quot;string&quot;) { var stepMsg = `Check timer ${condition}`; } else { stepMsg = util.format(&quot;Check timer with condition&quot;, condition); } A.step(stepMsg); expect(this.getTimer(), &quot;Timing is failed&quot;).to.correspond(condition); A.pass(); }, }; module.exports = TimerSteps; Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Global Members $ :Steps Steps collection. Type: Steps Source: globals/index.js, line 113 See: steps to get more details about its methods. allure Allure helper. Source: globals/index.js, line 105 CONF GlaceJS config. Source: globals/index.js, line 98 See: config to get more details about its options. reporters :Array.&lt;object&gt; Registered reporters. Type: Array.&lt;object&gt; Source: reporter/base.js, line 28 sinon SinonJS is pretty nice lib for mocking. Source: globals/index.js, line 50 stubObject Stubs object with its properties recursively. Source: globals/index.js, line 88 Methods after(func) Global function, existing in glace tests, which create after hook. after hook executes after all chunks in test or all tests in scope / suite / session. Parameters: Name Type Description func function Hook function. Can be async too. Source: globals/index.js, line 203 Examples after chunks test(&quot;my test&quot;, () =&gt; { after(() =&gt; { doSomeThing(); }); chunk(&quot;first chunk&quot;, () =&gt; { doSomeThingAgain(); }); chunk(&quot;second chunk&quot;, () =&gt; { andDoSomeThingAgain(); }); }); after tests suite(&quot;my suite&quot;, () =&gt; { after(async () =&gt; { await db.connect(); }); test(&quot;first&quot;, () =&gt; { chunk(async () =&gt; { await db.query(&quot;select * from users&quot;); }); }); test(&quot;second&quot;, () =&gt; { chunk(async () =&gt; { await db.query(&quot;select * from products&quot;); }); }); }); afterChunk(func) Global function, existing in glace tests, which creates afterChunk hook. afterChunk hook executes after each chunk in test. Parameters: Name Type Description func function Hook function. Source: globals/index.js, line 306 Example test(&quot;Some test&quot;, () =&gt; { afterChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); before(func) Global function, existing in glace tests, which create before hook. before hook executes before all chunks in test or all tests in scope / suite / session. Parameters: Name Type Description func function Hook function. Can be async too. Source: globals/index.js, line 154 Examples before chunks test(&quot;my test&quot;, () =&gt; { before(() =&gt; { doSomeThing(); }); chunk(&quot;first chunk&quot;, () =&gt; { doSomeThingAgain(); }); chunk(&quot;second chunk&quot;, () =&gt; { andDoSomeThingAgain(); }); }); before tests suite(&quot;my suite&quot;, () =&gt; { before(async () =&gt; { await db.connect(); }); test(&quot;first&quot;, () =&gt; { chunk(async () =&gt; { await db.query(&quot;select * from users&quot;); }); }); test(&quot;second&quot;, () =&gt; { chunk(async () =&gt; { await db.query(&quot;select * from products&quot;); }); }); }); beforeChunk(func) Global function, existing in glace tests, which creates beforeChunk hook. beforeChunk hook executes before each chunk in test. Parameters: Name Type Description func function Hook function. Source: globals/index.js, line 278 Example test(&quot;Some test&quot;, () =&gt; { beforeChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); chunk( [name] [, opts], func) Global function, existing in glace tests, which creates test chunk. chunk is independently executed part of test. It means that even if first chunk is failed, other will be executed in any case. test should contain as minimum one chunk. Parameters: Name Type Argument Default Description name string &lt;optional&gt; null Name of chunk. opts object &lt;optional&gt; Chunk options. Properties Name Type Argument Default Description retry number &lt;optional&gt; &lt;nullable&gt; null Number of chunk retries on failure. Overrides config and test settings. timeout number &lt;optional&gt; &lt;nullable&gt; null Time limit to execute chunk, sec. Overrides config and test settings. func function Callback function with test payload. Can be async too. Source: globals/chunk.js, line 71 Examples Anonymous chunk test(&quot;My test&quot;, () =&gt; { chunk(() =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); Named chunk test(&quot;My test&quot;, () =&gt; { chunk(&quot;My chunk&quot;, () =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); Chunk with options test(&quot;My test&quot;, () =&gt; { chunk(&quot;My chunk&quot;, { retry: 2, timeout: 1 }, () =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); Several chunks in test test(&quot;My test&quot;, () =&gt; { chunk(&quot;first chunk&quot;, () =&gt; { expect(2).to.be.equal(3); }); chunk(&quot;second chunk&quot;, () =&gt; { expect(3).to.be.equal(3); }); }); Async chunk test(&quot;My test&quot;, () =&gt; { chunk(async () =&gt; { await Promise.resolve(&quot;done!&quot;); }); }); expect(actualValue) chaijs expect function. Parameters: Name Type Description actualValue * Some actual value which should be checked. Source: globals/index.js, line 44 See: chaijs to get more details about `expect` usage. Example expect(1).to.be.equal(1); expect(2).to.be.gte(0); forEachLanguage( [name] [, fixtures] [, opts], func) Iterates test chunks through all languages specified in config or options. It's applicable for multilingual application. If list of languages is specified, it will be used firstly. Otherwise from configuration. Parameters: Name Type Argument Default Description name object &lt;optional&gt; &quot;for language&quot; Iterator namespace (will be report). fixtures Array.&lt;function()&gt; &lt;optional&gt; Involved fixtures list. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description languages Array.&lt;string&gt; &lt;optional&gt; &lt;nullable&gt; List of tested languages. chunkRetry number &lt;optional&gt; 0 Number of chunk retries on failure. Overrides config value for concrete test chunks. chunkTimeout number &lt;optional&gt; &lt;nullable&gt; null Time to execute chunk or hook, sec. func function Function with test steps. Source: globals/forEachLanguage.js, line 34 Example test(&quot;Some test&quot;, ctx =&gt; { forEachLanguage(lang =&gt; { chunk(() =&gt; { // payload }); }); }); glaceRun(cb) Runs glace framework. Parameters: Name Type Description cb function Callback. Source: run.js, line 75 help(d, cb) Help description. Parameters: Name Type Description d function Function to process option description. cb function Callback to expand default help. Source: help.js, line 2 run(cb) Runs tests. executes runner.js file, which is entry point to load and execute files with tests connects custom reporter to mochajs. Parameters: Name Type Description cb function Callback. Source: run.js, line 2 scope(name [, fixtures] [, opts], func) Execute tests scope. Parameters: Name Type Argument Description name string Scope name. fixtures Array.&lt;function()&gt; &lt;optional&gt; List of fixtures. opts object &lt;optional&gt; Scope options. Properties Name Type Argument Description chunkRetry number &lt;optional&gt; Number of chunk retries on failure. chunkTimeout number &lt;optional&gt; Time to execute chunk or hook, sec. func function Callback function with test cases. Source: globals/scope.js, line 34 Example scope(&quot;Some test scope&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); session( [name] [, fixtures], func) Executes tests session. Parameters: Name Type Argument Default Description name string &lt;optional&gt; Session name. By default it includes start date time. fixtures object &lt;optional&gt; [] Session fixtures. func function Function with test cases. Source: globals/session.js, line 37 Example session(() =&gt; { test(&quot;Test #1&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); test(&quot;Test #2&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); }); suite(name [, fixtures] [, opts], func) Creates tests suite. Parameters: Name Type Argument Description name string Suite name. fixtures Array.&lt;function()&gt; &lt;optional&gt; List of fixtures. opts object &lt;optional&gt; Suite options. Properties Name Type Argument Description chunkRetry number &lt;optional&gt; Number of chunk retries on failure. chunkTimeout number &lt;optional&gt; Time to execute chunk or hook, sec. func function Callback function with test cases. Source: globals/index.js, line 145 Example suite(&quot;Some test suite&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); test(name [, opts] [, fixtures], func) Global function, existing in glace tests, which creates test case. Parameters: Name Type Argument Description name string Name of test case. By default, should be unique in session. But uniqueness check can be skipped with CLI option --dont-check-names. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description skip boolean | string &lt;optional&gt; false Flag to skip test or skip reason message. retry number &lt;optional&gt; &lt;nullable&gt; null Number of test retries on failure. Overrides config settings. chunkRetry number &lt;optional&gt; &lt;nullable&gt; null # Number of chunk retries on failure. Overrides config settings. chunkTimeout number &lt;optional&gt; &lt;nullable&gt; null # Time to execute chunk or hook, sec. Overrides config settings. fixtures Array.&lt;function()&gt; &lt;optional&gt; Involved fixtures list. func function Ð¡allback function with chunks and hooks. Source: globals/test.js, line 160 Examples Simple test test(&quot;Some test&quot;, () =&gt; { chunk(&quot;Some chunk&quot;, () =&gt; { someFunc(); }); }); Test with retry test(&quot;Test with retry&quot;, { retry: 2 }, () =&gt; { chunk(() =&gt; { someFunc(); }); }); Test with fixtures test(&quot;Test with fixtures&quot;, null, [fix_func_1, fix_func_2], () =&gt; { chunk(() =&gt; { someFunc(); }); }); Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Modules Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Classes Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig Ã— Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Namespaces Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig Ã— Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Mixins Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Tutorials Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest | Source Code | Release Notes Glace (fr. glacÃ© â€” ice, frozen) is a cold drink based on coffee with addition of ice cream. glace-core is a quick-start functional &amp; unit testing framework based on mochajs and can be extented with its plugins. Why it is Firstly it's R&amp;D project for me to dive deeply to programming and software architecture. Current testing frameworks like mochajs or jasminejs look cool for unit testing but are not flexible for complex functional scenarios. Quick start Make sure you have installed node &gt;= v8.9 &amp; npm &gt;= v5.5. Install glace-core globally npm i -g glace-core or locally npm i glace-core. Create file tests.js with next content: &quot;use strict&quot;; test(&quot;My first test&quot;, () =&gt; { chunk(() =&gt; { console.log(&quot;hello world&quot;); }); }); test(&quot;My second test&quot;, () =&gt; { chunk(() =&gt; { throw new Error(&quot;BOOM!&quot;); }); }); Launch tests with command glace tests.js if you installed glace-core globally or with ./node_modules/glace-core/bin/glace tests.js if locally and get the result. Features Cross-platform: can be launched easily in linux, macos, windows. Concept is based on STEPS-architecture. Plugins system based on STEPS-protocol. Parameterization inside and outside of test Mechanism to launch tests in parallel workers. Mechanism to retry failed tests Mechanism to retry failed chunks Mechanism to process uncaught exceptions (mocha mechanism is unreliable but supported) Fixtures support similar to pytest fixtures Conftest and preloads support Test &amp; chunk options Multiple reporting system Stdout reporter in-box. Allure reporter in-box. TestRail reporter in-box, Easy to provide custom reporter May read CLI arguments from JSON file May be extended with custom JavaScript config May be used as platform for own testing frameworks development Reserved functions test - testcase definition; chunk - part of test executed independently; before - hook executed before chunks; after - hook executed after chunks; beforeChunk - hook executed before each chunk; afterChunk - hook executed after each chunk; $ - namespace of steps; CONF - configuration; fixtures - modular &amp; reusable blocks of test; iterators - cycles for tests, chunks and other blocks; suite - groups tests to suites for visual output mostly; scope - groups tests or chunks for visual or logical output, is used inside iterators also; session - first root suite, created by framework, not need to reuse by default. CLI optionsCommon --version - Show version. -h, --help - Show help. Arguments --config [path], -c - Path to JSON file with CLI arguments. Default is &lt;cwd&gt;/config.json if it exists. Note! All options below may be set via json file (see option --config above). Log --stdout-log - Print log messages to stdout. --log [path] - Path to log file. Default is &lt;cwd&gt;/glace.log. --log-level [level] - Log level. Supported values are error, warn, info, verbose, debug, silly. Default is debug. Core --user-config [path] - Path to JS file with configuration which will be merged with override default configuration. Default is &lt;cwd&gt;/config.js if it exists. --session-name [name] - Tests run session name. Default value includes word session and datetime. --grep &lt;pattern&gt;, -g - Filter tests by part of name (powered by mocha). --include &lt;sequence&gt; - 1) Sequence of test name parts separated by | in order to choose tests for run, case-insensitive. For example, --include &quot;my first test | my second test&quot; includes these ones in run only. 2) Path to json file with test names or test ids in order to choose them for run. For example, it can be path to file with failed tests, which is generated glace-core if some tests were failed. --exclude &lt;sequence&gt; - 1) Sequence of test name parts separated by | in order to exclude tests from run, case-insensitive. For example, --exclude &quot;my first test | my second test&quot; excludes these ones from run. 2) Path to json file with test names or test ids in order to exclude them from run. --precise-match - Precise tests inclusion or exclusion matching (check full test name equivalence, not substring matching). --report [path] - Path to report folder. Default is &lt;cwd&gt;/report. --dont-clear-report - Don't clear folder of previous report before tests run. --dont-check-names - Don't check test names uniqueness (usually useful in unit testing). By default test names should be human-readable and unique among other tests in run. --failed-tests-path [path] - Path to save failed tests in json format. Default is &lt;cwd&gt;/report/failed-tests.json. If there are failed tests in run, glace-core puts its info to json file, which can be used then with --include option to rerun failed tests only. --root-conftest &lt;path&gt; - Path to root conftest.js which will be loaded before tests but after preloads. --languages &lt;sequence&gt; - List of tested languages separated with comma. For example, --languages &quot;ru, en, ee&quot;. --retry [times] - Number of times to retry failed test. Default is 0. --chunk-retry [times] - Number of times to retry failed chunk (powered by mocha). Default is 0. --chunk-timeout [sec] - Time to execute chunk or hook, sec. Default is 180. --uncaught [type] - Strategy to process uncaught exceptions. Default value is log. Supported values are log just to log uncaught exceptions, fail to fail test if uncaught exception happened, mocha to use default mocha mechanism (unreliable). --kill-procs &lt;sequence&gt; - List of process names separated with comma, which will be killed before tests run, case-sensitive. For example, --kill-procs &quot;java, chrome, selenium&quot;. --debug-on-fail - Enter to interactive debug mode on step failure. Incompatible with --slaves option. --exit-on-fail - Finish tests run on first failure. --dots - Print dots instead of test &amp; chunk names. --errors-now - Print error message immediately when it happened. --deep-errors - Print deep objects structure in error message. --interactive, -i - Launch interactive mode to execute steps manually in terminal. Incompatible with --slaves option. --slaves &lt;number|auto&gt; - Split tests by slaves and execute them concurrently in separated processes. If it is auto, slaves amount will be equal to processor cores amount. Plugins --list-plugins - List found plugins and exit. --plugins-dir [path] - Path to custom plugins folder. --disable-default-plugins - Disable default (autodiscovered) plugins. xUnit --xunit - Activate xUnit reporter. --xunit-path [path] - Path to xUnit report. Default is &lt;cwd&gt;/report/xunit.xml. --xunit-suite-name [name] - Tests suite name in xUnit report. By default it's the same as session name. Allure --allure - Activate Allure reporter. --allure-dir [path] - Path to allure reports folder. Default is &lt;cwd&gt;/report/allure. TestRail --testrail - Activate TestRail reporter. --testrail-host &lt;host&gt; - TestRail host. --testrail-user &lt;user&gt; - TestRail username or email. --testrail-token &lt;token&gt; - TestRail token. --testrail-project-id &lt;id&gt; - TestRail project id. --testrail-suite-id &lt;id&gt; - TestRail suite id. --testrail-run-name &lt;name&gt; - TestRail run name. --testrail-run-desc &lt;description&gt; - TestRail run description. Tools --testrail-check - Check TestRail cases consistency with implemented tests. --list-steps [filter] - List available steps and exit. If filter is omitted, list all steps. --list-tests [filter] - List collected tests and exit. If filter is omitted, list all tests. --list-fixtures [filter] - List available fixtures and exit. If filter is omitted, list all fixtures. ExamplesThere are e2e tests in order to explore glace-core examples. Qualityglace-core is highly reliable framework. And it's ready to provide confirmation: release tests report release code coverage Ã— Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Namespace: GlaceConfig GlaceConfig Configures GlaceJS before tests run. Properties: Name Type Argument Description cluster object Cluster namespace. Properties Name Type Argument Default Description isMaster boolean &lt;optional&gt; true Mark current process as master. isSlave boolean &lt;optional&gt; false Mark current process as slave. slavesNum number &lt;optional&gt; 0 Number of slaves to launch. slaveId number &lt;optional&gt; null ID of slave. session object Session namespace. Properties Name Type Argument Default Description name string Session name. By default contains timestamp. Can be overridden with CLI option --session-name. id string Session ID. Default is timestamp. errors boolean &lt;optional&gt; [] List of session errors. isPassed boolean &lt;optional&gt; false Flag to define if tests session run is passed or no. preloads array.&lt;string&gt; &lt;optional&gt; [] Array of paths to js modules which will be loaded before tests session run. interactive boolean &lt;optional&gt; false Flag to launch interactive session. Can be overridden with CLI option -i / --interactive. debugOnFail boolean &lt;optional&gt; false Flag to enter to interactive mode on step failure. Can be overridden with CLI option --debug-on-fail. exitOnFail boolean &lt;optional&gt; false Flag to break tests session on first test failure. Can be overridden with CLI option --exit-on-fail. uncaughtException string &lt;optional&gt; log Strategy to process uncaught exceptions. Available values are log, fail, mocha. Can be overridden with CLI option --uncaught. rootConftest string Path to js module which will be loaded right after preloads. Can be overridden with CLI option --root-conftest. killProcs array.&lt;string&gt; Array of process names which will be killed before tests session run. Can be overridden with CLI option --kill-procs. retry object Retry settings namespace. Properties Name Type Argument Default Description id integer &lt;optional&gt; 0 Number of retried session. chunkIds object &lt;optional&gt; {} Chunk ids grouped by retry values. For example: {1: ['1_1', '1_2'], 3: ['2_1'], 2: ['3_1', '3_2']}. Populated on first session run. curChunkIds array.&lt;string&gt; &lt;optional&gt; &lt;nullable&gt; null Reference to currently populated group in retry.chunkIds. test object Test settings namespace. Properties Name Type Argument Default Description id integer &lt;optional&gt; 0 Number of currently created test. Each test has unique incremental id. On first session run it's assigned, on retry is used to find test by id, because test name can be non-unique. curCase TestCase &lt;optional&gt; &lt;nullable&gt; null Currently executed test case. cases array.&lt;TestCase&gt; &lt;optional&gt; [] Array of session test cases. languages array.&lt;string&gt; &lt;optional&gt; [] Array of language names. Can be overridden with CLI option --languages. dirs array.&lt;string&gt; &lt;optional&gt; [] Array of test files or folders. Can be overridden with CLI arguments or option --targets separated with comma. checkNames boolean &lt;optional&gt; true Flag to check test names uniqueness. Can be overridden with CLI option --dont-check-names. retries integer &lt;optional&gt; 0 # Number of test retries on failure. Overridden with CLI option --retry. chunk object Chunk settings namespace. Properties Name Type Argument Default Description id integer &lt;optional&gt; 0 Number of chunk inside a test, incremental, starts from 0 in each test. Fully unique chunk id is consist of test.id &amp; chunk.id, like 1_1, 1_2, 2_1. curId string &lt;optional&gt; &lt;nullable&gt; null Currently executed fully unique chunk id. passedIds array.&lt;string&gt; &lt;optional&gt; [] Fully unique ids of passed chunks. Used to skip already passed chunks on retry. retries integer &lt;optional&gt; 0 # Number of chunk retries on failure. Overridden with CLI option --chunk-retry. timeout integer &lt;optional&gt; 180 # Timeout of chunk execution, sec. Overridden with CLI option --chunk-timeout. report object Report namespace. Properties Name Type Argument Default Description dir string &lt;optional&gt; cwd/report Folder to save tests session report. testDir string &lt;optional&gt; Folder to save test-specific artifacts. clear boolean &lt;optional&gt; true Flag to clear report before tests run. Can be overridden with CLI option --dont-clear-report. errorsNow boolean &lt;optional&gt; false Flag to print test error right after its capture. Can be overridden with CLI option --errors-now. failedTestsPath string &lt;optional&gt; cwd/failed-tests.json Path to file where info about failed tests will be saved to. Can be overridden with CLI option --failed-tests-path. xunit object &lt;optional&gt; xUnit report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate xUnit report. Can be overridden with CLI option --xunit. path string &lt;optional&gt; report.dir/xunit.xml Path to xUnit report. Can be overridden with CLI option --xunit-path. suiteName string &lt;optional&gt; session.name xUnit suite name. Can be overridden with CLI option --xunit-suite-name. allure object &lt;optional&gt; Allure report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate allure report. Can be overridden with CLI option --allure. dir string &lt;optional&gt; report.dir/allure Folder to save allure report. Can be overridden with CLI option --allure-dir. suiteName string &lt;optional&gt; session.name Allure suite name. Can be overridden with CLI option --allure-suite-name. testrail object Testrail report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate testrail report. Can be overridden with CLI option --testrail. host string Testrail host. Can be overridden with CLI option --testrail-host. user string Testrail user name or email. Can be overridden with CLI option --testrail-user. token string Testrail auth token. Can be overridden with CLI option --testrail-token. projectId string Testrail project ID. Can be overridden with CLI option --testrail-project-id. suiteId string Testrail suite ID. Can be overridden with CLI option --testrail-suite-id. runName string Testrail run name. Can be overridden with CLI option --testrail-run-name. runDescription string Testrail run description. Can be overridden with CLI option --testrail-run-description. plugins object Plugins namespace. Properties Name Type Description dir string Folder with custom plugins. Can be overridden with CLI option --plugins-dir. filter object Tests filter namespace. Properties Name Type Argument Default Description grep string Mocha grep option to filter tests, scopes and suites. Can be overridden with CLI option -g / --grep. include array.&lt;string&gt; List of test names which should be included to tests session. Can be overridden with CLI option --include. exclude array.&lt;string&gt; List of test names which should be excluded from tests session. Can be overridden with CLI option --exclude. precise boolean &lt;optional&gt; false Flag for precise tests inclusion or exclusion (not substring pattern). Can be overridden with CLI option --precise. tools object Tools namespace. Properties Name Type Argument Default Description stepsList boolean &lt;optional&gt; false Flag to list available steps only. Can be overridden with CLI option --list-steps. stepsFilter string String to filter steps. Can be overridden with CLI option --list-steps. testsList boolean &lt;optional&gt; false Flag to list implemented tests only. Can be overridden with CLI option --list-tests. testsFilter string String to filter tests. Can be overridden with CLI option --list-tests. fixturesList boolean &lt;optional&gt; false Flag to list available fixtures only. Can be overridden with CLI option --list-fixtures. fixturesFilter string String to filter fixtures. Can be overridden with CLI option --list-fixtures. checkTestrail boolean &lt;optional&gt; false Flag to check matching of testrail cases with implemented tests only. Can be overridden with CLI option --testrail-check. Source: config.js, line 2 Ã— Search results Close "},"GlaceReporter.html":{"id":"GlaceReporter.html","title":"Class: GlaceReporter","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: GlaceReporter GlaceReporter new GlaceReporter(runner) GlaceJS common reporter. Parameters: Name Type Description runner object MochaJS runner. Source: reporter/base.js, line 2 Methods &lt;static&gt; register(reporters) Registers reporters if they are not. Parameters: Name Type Argument Description reporters object &lt;repeatable&gt; Sequence of reporters to register. Source: reporter/base.js, line 186 &lt;static&gt; remove(reporters) Removes reporters if they are registered. Parameters: Name Type Argument Description reporters object &lt;repeatable&gt; Sequence of reporters to remove. Source: reporter/base.js, line 200 &lt;async&gt; done(failures, fn) Finalizes reporting. Parameters: Name Type Description failures Array.&lt;*&gt; Tests failures. fn function Finalizator. Source: reporter/base.js, line 168 Ã— Search results Close "},"module-allure.html":{"id":"module-allure.html","title":"Module: allure","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: allure Allure wrapper. Source: allure.js, line 3 Methods &lt;static&gt; allure.addDescription(desc, type) Adds test description if test is started. Parameters: Name Type Description desc string Description. type string Mime type. Source: allure.js, line 105 &lt;static&gt; allure.addEnvironment(name, value) Adds test environment value if test is started. Parameters: Name Type Description name string Environment name. value string Environment value. Source: allure.js, line 93 &lt;static&gt; allure.attach(name, content, type) Attach content to test if test is started. Parameters: Name Type Description name string Content name. content string Content body. type string Mime type. Source: allure.js, line 118 &lt;static&gt; allure.attachHtml(name, html) Attach HTML to test if test is started. Parameters: Name Type Description name string HTML name. html string HTML content. Source: allure.js, line 177 &lt;static&gt; allure.attachImage(name, imgPath) Attach image to test if test is started. Parameters: Name Type Description name string Image name. imgPath string Image path. Source: allure.js, line 142 &lt;static&gt; allure.attachJson(name, obj) Attach JSON to test if test is started. Parameters: Name Type Description name string JSON name. obj string Object to convert to JSON. Source: allure.js, line 130 &lt;static&gt; allure.attachText(name, txt) Attach text to test if test is started. Parameters: Name Type Description name string Text name. txt string Text content. Source: allure.js, line 166 &lt;static&gt; allure.attachVideo(name, videoPath) Attach video to test if test is started. Parameters: Name Type Description name string Video name. videoPath string Video path. Source: allure.js, line 154 &lt;static&gt; allure.feature(name) Adds test feature if test is started. Parameters: Name Type Description name string Feature name. Source: allure.js, line 81 &lt;static&gt; allure.hasSteps() Defines if allure helper has steps or no. Source: allure.js, line 31 Returns: true if it has steps, false otherwise. Type boolean &lt;static&gt; allure.isTestStarted() Defines if test is started or no. Source: allure.js, line 41 Returns: true if test is started, false otherwise. Type boolean &lt;static&gt; allure.pass() Ends step as passed if test is started. Source: allure.js, line 60 &lt;static&gt; allure.step(name) Starts step if test is started. Parameters: Name Type Description name string Step name. Source: allure.js, line 51 &lt;static&gt; allure.story(name) Adds test story if test is started. Parameters: Name Type Description name string Story name. Source: allure.js, line 70 Ã— Search results Close "},"module-classifier.html":{"id":"module-classifier.html","title":"Module: classifier","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: classifier Wrapper on bayes classifier. Source: classifier.js, line 3 Ã— Search results Close "},"module-cli.html":{"id":"module-cli.html","title":"Module: cli","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: cli Execute tests via command line interface. Source: cli.js, line 3 Methods &lt;static&gt; run() Run glace-core in CLI and exit process at the end. Source: cli.js, line 18 Ã— Search results Close "},"module-cluster.html":{"id":"module-cluster.html","title":"Module: cluster","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: cluster Is used to execute tests concurrently in subprocesses. Scheduler process is named master, subprocesses with tests are slaves. Master uses simple scheduling, splitting tests on parts by slaves number. Source: cluster.js, line 3 Methods &lt;async&gt; launch( [cb]) Launches tests in subprocesses. Parameters: Name Type Argument Description cb function &lt;optional&gt; Callback function executing at the end. Properties Name Type Description exitCode number Subprocesses summary exit code. Source: cluster.js, line 36 Returns: Exit code if callback isn't passed, or result providing by callback. Type Promise.&lt;(number|*)&gt; Ã— Search results Close "},"module-error.html":{"id":"module-error.html","title":"Module: error","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: error Contains GlaceJS errors. Source: error.js, line 3 Classes ConfigError StepError Ã— Search results Close "},"module-error-ConfigError.html":{"id":"module-error-ConfigError.html","title":"Class: ConfigError","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: ConfigError error~ ConfigError new ConfigError(message) Error which is thrown when configuration is wrong. Parameters: Name Type Description message string Error message. Source: error.js, line 18 Ã— Search results Close "},"module-error-StepError.html":{"id":"module-error-StepError.html","title":"Class: StepError","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: StepError error~ StepError new StepError(message) Error which is thrown when step execution is wrong. Parameters: Name Type Description message string Error message. Source: error.js, line 28 Ã— Search results Close "},"module-globals_index.html":{"id":"module-globals_index.html","title":"Module: globals/index","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: globals/index Contains global framework functions and helpers. Source: globals/index.js, line 3 Ã— Search results Close "},"module-hacking.html":{"id":"module-hacking.html","title":"Module: hacking","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: hacking Contains hacks for test run. Source: hacking.js, line 2 Ã— Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: index GlaceJS main module. Properties: Name Type Description config object Config module. error object Error module. help function Help module. reporter object Reporter module. run object run module. Steps object Steps module. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 27 &lt;inner&gt; help Help. Source: index.js, line 42 &lt;inner&gt; reporter :GlaceReporter Type: GlaceReporter Source: index.js, line 57 &lt;inner&gt; run :run Type: run Source: index.js, line 66 &lt;inner&gt; Steps :Steps Type: Steps Source: index.js, line 75 Ã— Search results Close "},"module-loader.html":{"id":"module-loader.html","title":"Module: loader","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: loader Makes tests root session. runner loads root conftest.js if it is located on one level with each of CONF.test.dirs; if each of CONF.test.dirs is file with tests, runner loads and executes it; if each of CONF.test.dirs is folder runner loads files inside recursive if file name starts with test and ends with .js; inside each subfolder of each of CONF.test.dirs runner loads conftest.js file if it is present; Source: loader.js, line 5 Methods &lt;inner&gt; loadTests(dir) Loads test files recursively. Test file name should start with test and end with .js. Parameters: Name Type Description dir string Folder with test files. Source: loader.js, line 109 &lt;inner&gt; mainConftests() Main conftests are loaded before tests session creation and may used for objects management, for example to created custom instance of global SS. Main conftest is conftest.js file which is located on one hierarchy level with each specified tests folder or file. Source: loader.js, line 63 &lt;inner&gt; preloads() Loads special preloads files before main conftests and test files. Preloads are specified in CONF.preloads array. It may be managed only programmatically and needs as extension point to load some custom files before tests. After preloads it loads root (the mainest) conftest file, which may be set via CLI. Source: loader.js, line 40 &lt;inner&gt; sessFunc() Callback to create tests session. It kills some processes before all if they are specified. Source: loader.js, line 83 Ã— Search results Close "},"module-matcher.html":{"id":"module-matcher.html","title":"Module: matcher","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: matcher Matchers. Source: matcher.js, line 2 Ã— Search results Close "},"module-plugins.html":{"id":"module-plugins.html","title":"Module: plugins","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: plugins Plugins. Source: plugins.js, line 2 Methods &lt;inner&gt; clearCache() Clear plugins cache. Source: plugins.js, line 144 &lt;inner&gt; get() Get list of found and registered plugins. Each plugin is an object with keys: name - plugin name, path - plugin path, module - loaded plugin module. Order of resolving, if there plugins with the same names: Registered custom plugins. Plugins which are far from glace-core package. Source: plugins.js, line 32 Returns: Type array.&lt;object&gt; &lt;inner&gt; getModules(moduleName) Gets modules from plugins. Parameters: Name Type Description moduleName string Name of module to request from plugins. Source: plugins.js, line 131 Returns: List of modules requested from plugins. Type Array.&lt;object&gt; &lt;inner&gt; getNames(opts) Gets names of plugins. Parameters: Name Type Description opts object Options. Properties Name Type Argument Description type string &lt;optional&gt; Type of plugins. Supported values are custom and system, if omitted then names of all plugins will be returned. Source: plugins.js, line 192 Returns: Plugin names. Type array.&lt;string&gt; &lt;inner&gt; register(name) Registers custom plugin. Parameters: Name Type Description name string Name of plugin module. Source: plugins.js, line 151 &lt;inner&gt; remove(name) Removes custom plugin from list of registered. Parameters: Name Type Description name string Name of registered plugin. Source: plugins.js, line 172 Ã— Search results Close "},"module-reporter_allure.html":{"id":"module-reporter_allure.html","title":"Module: reporter/allure","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/allure Allure reporter. Source: reporter/allure.js, line 3 Ã— Search results Close "},"module-reporter_dots.html":{"id":"module-reporter_dots.html","title":"Module: reporter/dots","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/dots Glace dots reporter. Source: reporter/dots.js, line 3 Ã— Search results Close "},"module-reporter_index.html":{"id":"module-reporter_index.html","title":"Module: reporter/index","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/index GlaceJS reporter package. Source: reporter/index.js, line 2 Ã— Search results Close "},"module-reporter_stdout.html":{"id":"module-reporter_stdout.html","title":"Module: reporter/stdout","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/stdout GlaceJS stdout reporter. Source: reporter/stdout.js, line 2 Methods done() Called on report finalizing. Source: reporter/stdout.js, line 274 end() Called before tests end. Source: reporter/stdout.js, line 142 fail(chunk) Called on chunk or hook failed. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 252 pass(chunk) Called on chunk passed. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 228 scope(scope) Called on scope start. Parameters: Name Type Description scope object MochaJS suite. Source: reporter/stdout.js, line 156 scopeEnd() Called before scope end. Source: reporter/stdout.js, line 169 skip(chunk) Called on chunk skipped. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 240 start() Called before tests start. Source: reporter/stdout.js, line 131 suite(suite) Called on suite start. Parameters: Name Type Description suite object MochaJS suite. Source: reporter/stdout.js, line 180 suiteEnd() Called before suite end. Source: reporter/stdout.js, line 193 test(test) Called on test start. Parameters: Name Type Description test object MochaJS suite. Source: reporter/stdout.js, line 204 testEnd() Called on test end. Source: reporter/stdout.js, line 217 Ã— Search results Close "},"module-reporter_testrail.html":{"id":"module-reporter_testrail.html","title":"Module: reporter/testrail","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/testrail TestRail reporter publishs test results to remote testrail server via its API. Source: reporter/testrail.js, line 2 Methods processErrors(errors) Entry point to process test errors before testrail publication. Can be overridden with custom function. Parameters: Name Type Description errors Array.&lt;string&gt; List of test errors. Source: reporter/testrail.js, line 207 Returns: Test errors info, attaching to test comment. Type string Example Overriding with custom function // should be after configuration but before tests run const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); testrail.processErrors = myFuncToProcessErrors; processExtras(extras) Entry point to process test extra details before testrail publication. Can be overridden with custom function. Parameters: Name Type Description extras Array.&lt;string&gt; List of extra details. Source: reporter/testrail.js, line 230 Returns: Test extra details, attaching to test comment. Type string Example Overriding with custom function // should be after configuration but before tests run const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); testrail.processExtras = myFuncToProcessExtras; processScreens(screens) Entry point to process test screenshot paths before testrail publication. Can be overridden with custom function. Parameters: Name Type Description screens Array.&lt;string&gt; List of screenshot paths. Source: reporter/testrail.js, line 161 Returns: Test screenshots info, attaching to test comment. Type string Example Overriding with custom function // should be after configuration but before tests run const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); testrail.processScreens = myFuncToProcessScreens; processVideos(videos) Entry point to process test video paths before testrail publication. Can be overridden with custom function. Parameters: Name Type Description videos Array.&lt;string&gt; List of video paths. Source: reporter/testrail.js, line 184 Returns: Test videos info, attaching to test comment. Type string Example Overriding with custom function // should be after configuration but before tests run const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); testrail.processVideos = myFuncToProcessVideos; setComment() Entry point to set comment of test before testrail publication. Can be overridden with custom function. Source: reporter/testrail.js, line 145 Returns: Test comment. Type string Example Overriding with custom function // should be after configuration but before tests run const testrail = require(&quot;glace-core/lib/reporter/testrail&quot;); testrail.setComment = myFuncToSetComment; Ã— Search results Close "},"module-reporter_xunit.html":{"id":"module-reporter_xunit.html","title":"Module: reporter/xunit","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: reporter/xunit GlaceJS xunit reporter. Source: reporter/xunit.js, line 2 Methods &lt;inner&gt; write(line) Writes a line. Parameters: Name Type Description line string Report text line. Source: reporter/xunit.js, line 58 &lt;inner&gt; writeTest(test) Writes a test. Parameters: Name Type Description test TestCase Test case. Source: reporter/xunit.js, line 66 Ã— Search results Close "},"module-testing.html":{"id":"module-testing.html","title":"Module: testing","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: testing Contains classes and functions to save executed tests data. Source: testing.js, line 2 Classes ScopeType TestCase Ã— Search results Close "},"module-testing-ScopeType.html":{"id":"module-testing-ScopeType.html","title":"Class: ScopeType","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: ScopeType testing~ ScopeType Class defining mochajs scope name and type. new ScopeType() Source: testing.js, line 147 Methods setType(type) Set mochajs scope type. Parameters: Name Type Description type string Supported values are scope, suite, test. Source: testing.js, line 152 Ã— Search results Close "},"module-testing-TestCase.html":{"id":"module-testing-TestCase.html","title":"Class: TestCase","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: TestCase testing~ TestCase new TestCase(name) Test case data structure. Contains full information and history about test case. Parameters: Name Type Description name string Test name. Properties: Name Type Argument Default Description name string Test name. status string &lt;optional&gt; NOT_STARTED Test status. skipChunk string &lt;optional&gt; &lt;nullable&gt; null Name of currently skipped chunk. screenshots Array.&lt;string&gt; &lt;optional&gt; [] List of test screenshot paths. videos Array.&lt;string&gt; &lt;optional&gt; [] List of test video paths. errors Array.&lt;string&gt; &lt;optional&gt; [] List of test errors. rawInfo Array.&lt;string&gt; &lt;optional&gt; [] List of additional test details. testParams object &lt;optional&gt; {} Dict of test parameters. Source: testing.js, line 25 Methods addChunk(chunkName) Adds chunk. Parameters: Name Type Description chunkName string Name of chunk. Source: testing.js, line 134 addDetails(info) Adds additional information. Parameters: Name Type Description info string Additional information. Source: testing.js, line 125 addError(err) Adds error to test case. Parameters: Name Type Description err Error Test error. Source: testing.js, line 98 addPassedChunkId(chunkId) Adds passed chunk id. Parameters: Name Type Description chunkId string Chunk id. Source: testing.js, line 79 addPassedChunkIds(chunkIds) Adds passed chunk ids. Parameters: Name Type Description chunkIds array.&lt;string&gt; Chunk ids. Source: testing.js, line 89 addScreenshot(imagePath) Adds screenshot. Parameters: Name Type Description imagePath string Path to saved screenshot. Source: testing.js, line 107 addVideo(videoPath) Adds video. Parameters: Name Type Description videoPath string Path to saved video. Source: testing.js, line 116 end(status) Ends test case. Parameters: Name Type Description status string Test case status. Source: testing.js, line 53 reset() Resets test case info. Source: testing.js, line 66 start() Starts test case. Source: testing.js, line 40 Ã— Search results Close "},"module-tools.html":{"id":"module-tools.html","title":"Module: tools","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: tools Glace tools. Source: tools.js, line 3 Methods &lt;static&gt; checkTestrail(cb) Check testrail cases consistency with implemented tests. Parameters: Name Type Description cb function Callback function. Source: tools.js, line 188 &lt;static&gt; fakeLoad() Make fake load of tests in order to collect tests, fixtures, steps, etc. Source: tools.js, line 162 &lt;static&gt; listFixtures( [filter] [, namesOnly]) Get list of available fixtures. Parameters: Name Type Argument Default Description filter string &lt;optional&gt; String chunk to filter fixtures. namesOnly boolean &lt;optional&gt; false Flag to filter by fixture names only. Source: tools.js, line 127 Returns: Type array.&lt;object&gt; &lt;static&gt; listPlugins() Print list of available plugins. Source: tools.js, line 96 &lt;static&gt; listSteps( [filter] [, namesOnly]) Get list of steps data, where step data is an object with keys: name - name of step, decription - short details of steps, doc - documentation of step. Parameters: Name Type Argument Default Description filter string &lt;optional&gt; String chunk to filter steps. namesOnly boolean &lt;optional&gt; false Flag to filter by step names only. Source: tools.js, line 38 Returns: Type array.&lt;object&gt; &lt;static&gt; listTests( [filter]) Print list of implemented test cases. Parameters: Name Type Argument Description filter string &lt;optional&gt; String chunk to filter test cases. Source: tools.js, line 70 &lt;static&gt; printFixtures( [filter] [, namesOnly]) Print list of fixtures in stdout. Parameters: Name Type Argument Default Description filter string &lt;optional&gt; String chunk to filter fixtures. namesOnly boolean &lt;optional&gt; false Flag to filter by fixture names only. Source: tools.js, line 142 &lt;static&gt; printSteps( [filter] [, namesOnly]) Print list of steps in stdout. Parameters: Name Type Argument Default Description filter string &lt;optional&gt; String chunk to filter steps. namesOnly boolean &lt;optional&gt; false Flag to filter by step names only. Source: tools.js, line 55 Ã— Search results Close "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Module: utils Utils. Source: utils.js, line 3 Methods &lt;static&gt; accountError() Account test error and add it to test or session errors. Source: utils.js, line 34 &lt;static&gt; getDoc(func) Get function description. Parameters: Name Type Description func function Function to read documentation. Source: utils.js, line 68 Returns: Documentation. Type string &lt;static&gt; setLog() Helper to set actual log file. Source: utils.js, line 23 Ã— Search results Close "},"Steps.html":{"id":"Steps.html","title":"Class: Steps","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Class: Steps Steps Contains collection of steps which may be called inside tests via its instance $. It mixes steps from plugins too. new Steps() Creates new instance of Steps class. Properties: Name Type Description ctx object Storage to share some data between steps. Mixes In: TimerSteps Source: steps/index.js, line 2 Methods &lt;static&gt; getInstance( [cls]) Helper to get steps instance. It wraps steps class with proxy object. Proxy observes steps call and in debug mode if steps is failed it entered test to interactive debug mode. Parameters: Name Type Argument Description cls function &lt;optional&gt; Class with steps. By default original glace Steps will be used. Source: steps/index.js, line 126 Returns: Wrapped steps instance. Type Proxy &lt;static&gt; register(steps) Registers steps (mixes them). Parameters: Name Type Argument Description steps object &lt;repeatable&gt; Sequence of steps to register. Source: steps/index.js, line 108 Example var MyStepsMixin = require(&quot;./my-steps-mixin&quot;); var AnotherStepsMixin = require(&quot;./another-steps-mixin&quot;); Steps.register(MyStepsMixin, AnotherStepsMixin); &lt;async&gt; debug() Step to enter to interactive debugging mode. May be used inside test if you need to debug test in runtime. Source: steps/index.js, line 57 Returns: Type Promise.&lt;void&gt; Example test(&quot;my test&quot;, () =&gt; { chunk(async () =&gt; { await $.debug(); }); }); isTestFailed() Helper to check whether test was failed before current step. Source: steps/index.js, line 42 Returns: undefined if test is absent, true if test was failed, false otherwise. Type undefined | boolean listSteps(filter [, namesOnly]) Step to list available steps [debug mode]. Parameters: Name Type Argument Default Description filter string Steps filter. namesOnly boolean &lt;optional&gt; false Search among step names only. By default full-text search is used. Source: steps/index.js, line 82 resetCtx() Helper to reset steps context. Source: steps/index.js, line 30 Ã— Search results Close "},"TimerSteps.html":{"id":"TimerSteps.html","title":"Mixin: TimerSteps","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Mixin: TimerSteps TimerSteps Steps to measure time. These methods will be mixed with glacejs Steps class and available via its instance $ in tests. Source: steps/timer.js, line 5 Methods checkTimer(condition) Step to check timer. Parameters: Name Type Description condition string | object chaijs condition. Source: steps/timer.js, line 110 Throws: If timer verification was failed. Type AssertionError Example $.startTimer(); $.checkTimer(&quot;to exist&quot;); $.startTimer(); await $.pause(1, &quot;sleep a bit&quot;); $.checkTimer({ &quot;to be gte&quot;: 1 }); getTimer() Step to get timer. Source: steps/timer.js, line 87 Throws: If timer is not started. Type AssertionError Returns: Number of seconds since timer starts. Type number Example $.startTimer(); await $.pause(1, &quot;sleep a bit&quot;); var elapsedSeconds = $.getTimer(); &lt;async&gt; pause(timeout, message) Step to make pause in another step or test case. Good style is to not use directly in test case, only inside another step. Parameters: Name Type Description timeout number Pause time, sec. message string Pause reason. Source: steps/timer.js, line 25 Throws: If pause message is not defined. Type AssertionError Returns: Type Promise.&lt;void&gt; Example await $.pause(1, &quot;wait for server start&quot;); startTimer() Step to start timer. Each time when it will be called, timer will be reset. Source: steps/timer.js, line 50 Example $.startTimer(); await $.pause(1, &quot;sleep a bit&quot;); var elapsedSeconds = $.getTimer(); stopTimer() Step to stop timer. Source: steps/timer.js, line 70 Example $.stopTimer(); Ã— Search results Close "},"tutorial-common-used-funcs.html":{"id":"tutorial-common-used-funcs.html","title":"Tutorial: Commonly Used Functions","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Commonly Used Functions # testtest is a central function which is used to create a testcase unit. Full info âž¤ test(&quot;It should print 'hello world'&quot;, () =&gt; { chunk(() =&gt; { console.log(&quot;hello world&quot;); }); });âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-15 09:27:15 test: It should print 'hello world' hello world âœ“ chunk âœ“ 1 passed test 1 executed chunk Summary tests time is 0.003 sec ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/reporttest should contain as minimum one chunk, named or unnamed. # chunkchunk is independently executed part of test. Independently means even if first chunk is failed, other chunks will be executed in any case. Full info âž¤ test(&quot;It should include one unnamed chunk&quot;, () =&gt; { chunk(() =&gt; { console.log(&quot;do some stuff&quot;); }); }); test(&quot;It should include one named chunk&quot;, () =&gt; { chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); }); test(&quot;It should include several chunks&quot;, () =&gt; { chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); chunk(&quot;second chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); }); test(&quot;It should include failed &amp; passed chunks&quot;, () =&gt; { chunk(&quot;which is failed&quot;, () =&gt; { throw Error(&quot;BOOM!&quot;); }); chunk(&quot;which is passed&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); });âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-15 09:38:45 test: It should include one unnamed chunk do some stuff âœ“ chunk test: It should include one named chunk do some stuff âœ“ chunk: first chunk test: It should include several chunks do some stuff âœ“ chunk: first chunk do some stuff âœ“ chunk: second chunk test: It should include failed &amp; passed chunks âœ– chunk: which is failed do some stuff âœ“ chunk: which is passed âœ“ 3 passed tests âœ– 1 failed test 6 executed chunks Summary tests time is 0.005 sec TEST FAILURES: test: It should include failed &amp; passed chunks which is failed message: BOOM! stack: Error: BOOM! at chunk (example.js:24:15) at Context.&lt;anonymous&gt; (lib/globals/chunk.js:88:18) at next (lib/hacking.js:45:20) at Immediate.&lt;anonymous&gt; (lib/hacking.js:88:9) ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/report# beforebefore is a hook executed before all chunks inside a test or before all tests inside a suite / scope / session. Full info âž¤ test(&quot;It should execute hook before all chunks&quot;, () =&gt; { before(() =&gt; { console.log(&quot;some stuff before chunks&quot;); }); chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); chunk(&quot;second chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); });# afterafter is a hook executed after all chunks inside a test or after all tests inside a suite / scope / session. Full info âž¤ test(&quot;It should execute hook after all chunks&quot;, () =&gt; { chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); chunk(&quot;second chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); after(() =&gt; { console.log(&quot;some stuff after chunks&quot;); }); });# beforeChunkbeforeChunk is a hook executed before each chunk inside a test. Full info âž¤ test(&quot;It should execute hook before each chunk&quot;, () =&gt; { beforeChunk(() =&gt; { console.log(&quot;some stuff before each chunk&quot;); }); chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); chunk(&quot;second chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); });# afterChunkafterChunk is a hook executed after each chunk inside a test. Full info âž¤ test(&quot;It should execute hook after each chunk&quot;, () =&gt; { chunk(&quot;first chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); chunk(&quot;second chunk&quot;, () =&gt; { console.log(&quot;do some stuff&quot;); }); afterChunk(() =&gt; { console.log(&quot;some stuff after each chunk&quot;); }); });# $$ is the steps namespace, central concept of glace philosophy. Ideally and normally in glace tests to have only step calls inside test chunks. glace-core provides only basic steps, other steps for specific actions are provided by plugins or should be implemented together with tests development. There are more examples of steps usage in glace-js. And here some basic: suite(&quot;Timer steps&quot;, () =&gt; { test(&quot;It should sleep 1 sec&quot;, () =&gt; { chunk(async () =&gt; { await $.pause(1, &quot;sleep 1 sec&quot;); }); }); test(&quot;It should pass timer check&quot;, () =&gt; { chunk(async () =&gt; { await $.startTimer(); await $.pause(1, &quot;sleep&quot;); await $.checkTimer({ &quot;to be above&quot;: 1 }); }); }); test(&quot;It should fail timer check&quot;, () =&gt; { chunk(async () =&gt; { await $.startTimer(); await $.pause(1, &quot;sleep&quot;); await $.checkTimer({ &quot;to be below&quot;: 1 }); }); }); test(&quot;It should fail because timer is not started&quot;, () =&gt; { chunk(async () =&gt; { await $.startTimer(); await $.pause(1, &quot;sleep&quot;); await $.stopTimer(); await $.checkTimer({ &quot;to be equal&quot;: 1 }); }); }); });âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-16 08:29:39 suite: Timer steps test: It should sleep 1 sec âœ“ chunk test: It should pass timer check âœ“ chunk test: It should fail timer check âœ– chunk test: It should fail because timer is not started âœ– chunk âœ“ 2 passed tests âœ– 2 failed tests 4 executed chunks Summary tests time is 4.032 sec TEST FAILURES: test: It should fail timer check message: Timing is failed: expected 1.005 to be below 1 stack: AssertionError: Timing is failed: expected 1.005 to be below 1 at Proxy.Assertion.correspond (lib/matcher.js:50:27) at Proxy.checkTimer (lib/steps/timer.js:135:56) at chunk (example.js:23:21) at &lt;anonymous&gt; test: It should fail because timer isn't started message: Timer isn't started: expected null to exist stack: AssertionError: Timer isn't started: expected null to exist at Proxy.getTimer (lib/steps/timer.js:103:54) at Proxy.checkTimer (lib/steps/timer.js:135:21) at chunk (example.js:32:21) at &lt;anonymous&gt; ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/report# CONFCONF refers to glace configuration and is mostly used inside steps, features or iterators, rather than inside tests directly. For example, glace-core/lib/globals/forEachLanguage.js#L66: scope(`${name} &quot;${lang}&quot;`, () =&gt; { let oldLang; before(() =&gt; { if (CONF.test.curCase) { oldLang = CONF.test.curCase.testParams.language; CONF.test.curCase.testParams.language = lang; } }); U.wrap(fixtures, () =&gt; func(lang))(); after(() =&gt; { if (CONF.test.curCase) { CONF.test.curCase.testParams.language = oldLang; } }); });CONF is global object for all glace components, which means that even if some glace plugin imports own config module internally, finally it works in the same global config namespace. Full info âž¤ # fixturesFixtures are reusable functions, which can add hooks before and after test or group of tests. They were introduced to glace-core under impression of pytest fixtures. Simple fixture can be presented as: const myFixture = testFunc =&gt; { before(() =&gt; console.log(&quot;fixture before&quot;)); testFunc(); after(() =&gt; console.log(&quot;fixture after&quot;)); };Now it can be reusable as many times as it needs. For example: suite(&quot;My suite&quot;, [myFixture], () =&gt; { test(&quot;first test&quot;, () =&gt; { chunk(() =&gt; {}); }); test(&quot;second test&quot;, [myFixture], () =&gt; { chunk(() =&gt; {}); }); });Run result: âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-22 07:39:21 suite: My suite fixture before test: first test âœ“ chunk test: second test fixture before âœ“ chunk fixture after fixture after âœ“ 2 passed tests 2 executed chunks Summary tests time is 0.005 sec ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/reportFixtures can be used with test, scope, suite, session and forEachLanguage. Many glace plugins offer fixtures as wrappers on their steps. For example, glace-web/lib/fixtures.js#L18. And glace-js session is fully based on fixtures reusage. # iteratorsiterators are used to make parametrization over tests or chunks. Underhood iterators are cycles. glace-core provides iterator forEachLanguage to make easy localisation tests. suite(&quot;Localisation tests&quot;, () =&gt; { test(&quot;my test&quot;, () =&gt; { forEachLanguage(lang =&gt; { chunk(() =&gt; { // someLangSpecificStuff(lang); }); }); }); });âžœ glace-core: ./bin/glace example.js --languages en,ru,fr suite: Session 2018-11-22 07:39:21 suite: Localisation tests test: my test scope: for language &quot;en&quot; âœ“ chunk scope: for language &quot;ru&quot; âœ“ chunk scope: for language &quot;fr&quot; âœ“ chunk âœ“ 1 passed test 3 executed chunks Summary tests time is 0.004 sec ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/report# suitesuite is used to group tests. Full info âž¤ suite(&quot;my tests&quot;, () =&gt; { test(&quot;first test&quot;, () =&gt; { chunk(() =&gt; {}); }); test(&quot;second test&quot;, () =&gt; { chunk(() =&gt; {}); }); });âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-22 07:39:21 suite: my tests test: first test âœ“ chunk test: second test âœ“ chunk âœ“ 2 passed tests 2 executed chunks Summary tests time is 0.004 sec ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/report# scopescope is used to group tests or chunks. Full info âž¤ test(&quot;my test&quot;, () =&gt; { scope(&quot;user chunks&quot;, () =&gt; { chunk(&quot;login as user&quot;, () =&gt; {}); chunk(&quot;post a message&quot;, () =&gt; {}); }); scope(&quot;admin chunks&quot;, () =&gt; { chunk(&quot;login as admin&quot;, () =&gt; {}); chunk(&quot;moderate messages&quot;, () =&gt; {}); }); });âžœ glace-core: ./bin/glace example.js suite: Session 2018-11-22 07:39:21 test: my test scope: user chunks âœ“ chunk: login as user âœ“ chunk: post a message scope: admin chunks âœ“ chunk: login as admin âœ“ chunk: moderate messages âœ“ 1 passed test 4 executed chunks Summary tests time is 0.004 sec ----------------------------------------------------------- Local report is /home/user/projects/glace/glace-core/report# sessionsession is root suite, which is created automatically (not need to use it explicitly). Full info âž¤ But it can be overridden to extend its functionality, for example glace-js/lib/globals.js#L13: const gSession = session; global.session = (name, fixtures, func) =&gt; { if (_.isFunction(fixtures)) [func, fixtures] = [fixtures]; if (_.isArray(name)) [fixtures, name] = [name]; if (_.isFunction(name)) [func, name] = [name]; fixtures = fixtures || []; if (CONF.web.use &amp;&amp; !CONF.cluster.slavesNum) fixtures.push(fxKillWebdriver); if (CONF.xvfb.use) fixtures.push(fxXvfb); if (CONF.proxy.global) fixtures.push(fxGlobalProxy); if (CONF.proxy.http) fixtures.push(fxHttpProxy); if (CONF.web.use &amp;&amp; !CONF.webdriver.host) fixtures.push(fxSelenium); if (CONF.web.use) fixtures.push(fxBrowser); if (CONF.image.screenOnFail) fixtures.push(fxScreenOnFail); gSession(name, fixtures, func); }; Ã— Search results Close "},"tutorial-concepts.html":{"id":"tutorial-concepts.html","title":"Tutorial: GlaceJS concepts","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest GlaceJS concepts test - test case. Wrapper on mochajs describe. Should have readable and unique name per suite. test(&quot;my test&quot;, () =&gt; { chunk(() =&gt; { // payload }); });chunk - a set of actions in test. Wrapper on mochajs it. Test should contain as minimum one chunk. Chunks are executed independently inside a test. Chunk may have name or be anonymous. /* anonymous chunk */ test(&quot;my test&quot;, () =&gt; { chunk(() =&gt; { // payload }); }); /* named chunks */ test(&quot;my test&quot;, () =&gt; { chunk(&quot;#1&quot;, () =&gt; { // payload }); chunk(&quot;#2&quot;, () =&gt; { // payload }); });scope - the scope of tests or chunks, which is used for grouping. Wrapper on mochajs describe. If you have more than one file with tests, it will be a good style to wrap all tests inside file under one scope for visual grouping in stdout report. /* scope of tests */ scope(&quot;Auth&quot;, () =&gt; { test(&quot;is passed&quot;, () =&gt; { // test case }); test(&quot;is failed&quot;, () =&gt; { // test case }); }); /* scope of chunks */ test(&quot;Auth&quot;, () =&gt; { scope(&quot;is passed&quot;, () =&gt; { chunk(&quot;for user&quot;, () =&gt; { // payload }); chunk(&quot;for admin&quot;, () =&gt; { // payload }); }); });before - mochajs before. after - mochajs after. beforeChunk - wrapper on mochajs beforeEach. afterChunk - wrapper on mochajs afterEach. Ã— Search results Close "},"tutorial-mocha-uncaught.html":{"id":"tutorial-mocha-uncaught.html","title":"Tutorial: Mocha broken queue with uncaught exceptions","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Mocha broken queue with uncaught exceptions In mocha it's very easy to break async tests queue due to uncaught exceptions processing mechanism in mocha. Create tests file with next content: &quot;use strict&quot;; var sleep = timeout =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(`I was sleeping ${timeout} ms`); resolve(); }, timeout); }); }; var error = timeout =&gt; { setTimeout(() =&gt; { throw new Error(&quot;BOOM!!!&quot;); }, timeout); }; describe(&quot;scope&quot;, () =&gt; { it (&quot;test #1&quot;, async () =&gt; { error(1000); await sleep(1000); }); it (&quot;test #2&quot;, async () =&gt; await sleep(1000)); it (&quot;test #3&quot;, async () =&gt; { error(1000); await sleep(1000); }); it (&quot;test #4&quot;, async () =&gt; await sleep(1000)); it (&quot;test #5&quot;, async () =&gt; await sleep(1000)); it (&quot;test #6&quot;, async () =&gt; await sleep(1000)); }); Run and get something at first sight incomprehensible: $ mocha uncaught.js scope 1) test #1 # in console it colored as red (failed) I was sleeping 1000 ms âˆš test #1 (1012ms) 2) test #3 # in console it colored as red (failed) I was sleeping 1000 ms I was sleeping 1000 ms âˆš test #4 âˆš test #4 I was sleeping 1000 ms I was sleeping 1000 ms I was sleeping 1000 ms âˆš test #6 (1002ms) âˆš test #6 (1002ms) âˆš test #6 (1003ms) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15At first, please note that test #1 is marked twice: as passed and as failed! Second, test #2 and test #5 are absent in the report. Third, begins simultaneous delivery of messages I was sleeping 1000 ms, first 1 time, then 2 times, then 3 times. Now consider why this is so. The problem is that mocha default handles uncaught exceptions. If such an exception occurs, mocha fails current test, no matter whether with him or even uncaught exception was generated by an asynchronous call to a lot of tests ago (e.g. due to forgotten / hanging timers, etc.). And since this processor is implemented via a listener, then in my example it is a very interesting thing: On one hand in the test after 1 second uncaught exception happens and invokes its handler, on the other side the test explicitly waits for 1 second end of sleep and marks the test as passed. Because of the async of JavaScript, we have two concurrent test processors, which leads to twice appearance of a report of test #1. Moreover, from now on, we have two places which emit event to start a new test. And in fact, one queue was splitted to 2 queues! In test #3 the situation is repeated, leading to further division of the queue. And we have 3 competitive operating test queues! This can be observed by the increment of the number of messages I was sleeping 1000 ms. In our work, we periodically met such split of queue, so this example is based on a real existing problem. In the end, the whole run was in the trash, because due to queue splitting test results weren't correct. How to fixSimple and working variant to suppress uncaught exception. var Mocha = require(&quot;mocha&quot;); Mocha.Runner.prototype.uncaught = function (err) { logger.error(&quot;UNCAUGHT ERROR&quot;, err); };Better to get one failed test, and in finalizers to close all descriptors, proxies, to kill processes, etc., to suppress and log uncaught exception, and then analyze the logs for their presence. Than to collapse the queue and get failed report of all night run. In my work this approach was really helpful. That's why glace supports own variants to process uncaught exceptions (see CLI option --uncaught). P. S. mocha has the option --allow-enable - uncaught uncaught errors to propagate. But I did not understand what it is, because it certainly does not solve the problem. Ã— Search results Close "},"tutorial-parameterization.html":{"id":"tutorial-parameterization.html","title":"Tutorial: Tests parameterization","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Tests parameterization Ã— Search results Close "},"tutorial-plugins.html":{"id":"tutorial-plugins.html","title":"Tutorial: How plugins work","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest How plugins work Ã— Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Release Notes v2.0.4 Migrated to rehire. v2.0.3 Fixed bugs with error diff calculation. v2.0.2 Added feature to print diffs between objects in errors. v2.0.1 Added dots reporter. v2.0.0 Fixed bug in rewire caller path calculation. v1.9.9 Fixed bug that rewire didn't work in interactive mode. v1.9.8 Updated glace-utils to fresh version. v1.9.7 Updated dependencies to latest versions. v1.9.6 Added entry points to override test comments in testrail report. v1.9.5 Added function to print function doc in interactive mode. v1.9.4 Fixed bug to use scope in session. v1.9.3 Skipped processesing of mocha root suite in reporter. v1.9.2 Moved fixtures before options in arguments, enhanced arguments usage. v1.9.1 Enhanced fixtures usage. v1.9.0 Enhanced retry mode to involve all hooks in tests session. v1.8.9 Updated log message format. v1.8.8 Updated dependencies to latest versions. v1.8.7 Match retries with allure report. v1.8.6 Fixed bug that in scope default fixtures were initialized as empty object instead of empty array. Fixed bug that mocha grep passed all tests on retry. v1.8.5 Extended tests coverage &gt; 90%. Refactoring. v1.8.4 Fixed bug that session errors were cleaned after retry. v1.8.3 Fixed critical bug that on session failure glace run eternal retry. Capture session errors. Extended tests coverage. v1.8.2 Extended tests coverage. Achieved green result bigger than 80%. Ridden of SS and $$. Started to use $ only. v1.8.1 Added mechanism to launch tests in separated processes in parallel via CLI option --slaves. v1.8.0 Refactored reporting subsystem in order to clear reference to current test after testEnd() in all reporters. v1.7.9 Fixed bug that session wasn't marked as passed after each retry. Fixed bug that tests weren't retried on session fail. Fixed bug that exit code was successful on uncaught errors. Refactored pass reporter. Refactored fail reporter. v1.7.8 Switched to promises in testrail reporter. Fixed bug that test retry is stopped if session before hook is failed on retry. v1.7.7 Provided custom help message in debug mode. Provided global function search in debug mode. v1.7.6 Fixed that after relaunch only failed tests glace didn't save previously passed chunk ids. v1.7.5 Rid of context in failed tests relaunch. v1.7.4 Retry only failed chunks. v1.7.3 Fixed wrong error message in debug mode. v1.7.2 Disable chunk timeout and optional reports on --debug-on-fail. v1.7.1 Fixed bug that all reporters are removed if try to remove some one. v1.7.0 Fixed typos in help file. v1.6.9 Fixed bug with broken allure and testrail reporter after mocha suite title patching. v1.6.8 Work around windows console gray ascii color problem. Fixed bug with undefined skip reason. v1.6.7 Removed redundant test option skipReason. v1.6.6 Fixed bug to create logs folder synchronously. v1.6.5 Fixed bug that test, scope and suite names weren't defined precisely. Code improvements and tests expansion. v1.6.4 Fixed bug that params from include file were ignored on retry after before all hook failure. v1.6.3 Create logs folder before reporting. v1.6.2 Fixed bug to ignore include and exclude options in interactive mode. v1.6.1 Included chai plugins chai-string, chai-fs, chai-datetime. v1.6.0 Added CLI option --dont-check-names. v1.5.9 Fixed bug that steps with ES6 options weren't rendered correct with --list-step CLI option. v1.5.8 Renamed reports folder. v1.5.7 Fixed bug that suite wasn't rendered in stdout report. v1.5.6 Allure reporter fixes. v1.5.5 Allure reporter fixes. v1.5.4 Added steps aliases $ and $$. Added allure reporter support. v1.5.3 Added helper stubObject. v1.5.2 Moved stdout log under reports folder. Changed project icon. Used pure javascript bayes classifier. v1.5.1 Updated dependencies. v1.5.0 Skipped registration of already registered plugin. Added API to get registered plugin names. v1.4.9 Fixed incorrect help. v1.4.8 Use global session on retry (#87). v1.4.7 Fixed failed retry mechanism. v1.4.6 Added feature to launch all retried tests in one session. v1.4.5 Implemented tests include to run. Implemented tests exclude from run. Loaded included and excluded tests from file. Saved failed tests in JSON format. Added CLI option to print errors immediately. v1.4.4 Update dependencies. v1.4.3 Update glace-utils to not kill parent process. v1.4.2 Added option to finish test run on first failure. v1.4.1 Added ability to mark chunks as skipped. Added feature to print tests time duration in human-readable format. Fixed bug with wrong exit code on non-test hook failure. v1.4.0 Fixed bug when glace returned incorrect exit code on test retry. v1.3.9 Fixed stdout in testrail check command. v1.3.8 Added CLI option to check TestRail cases consistency with implemented tests. v1.3.7 Added ability to restart only failed params even if in retry before all test was failed. v1.3.6 Fixed bug in testrail api. v1.3.5 Added relevant step docs sorting with machine learning algorithms via natural. v1.3.4 Added interactive mode. v1.3.3 Added multi-word search in docs of steps and fixtures. v1.3.2 Added full-text search in docs of steps and fixtures. v1.3.1 Fixed bug that custom steps class wasn't shown in CLI docs. v1.3.0 Used docstring style for fixtures. v1.2.9 Used js syntax highlight in steps documentation in CLI. v1.2.8 Added ability to show steps documentation in --list-steps. v1.2.7 Added CLI options --list-steps [filter], --list-tests [filter], --list-fixtures [filter]. v1.2.6 Decomposed global functions. Added option to enter to interactive debug mode on step failure. v1.2.5 Fixed bug that option --chunk-timeout no leaded to default timeout 2000. v1.2.4 Added custom path for log files. v1.2.3 Fixed bug that relative root conftest wasn't resolved correct. v1.2.2 Fixed a bug that glace raised error if steps property didn't exist. v1.2.1 Added helpers for easy integration with glace-testgen plugin. v1.2.0 Added feature to kill processes before tests run. v1.1.9 Fixed bug that on parametrized test failure failed params may be added to retry more that one time. v1.1.8 Added step to enter to interactive debug mode. v1.1.7 Patched rewire in order to add method __reset__ to restore original module state. v1.1.6 Added rewire and sinon-chai. v1.1.5 Fixed bug that matcher waitFor didn't work correct with async predicates. v1.1.4 Added chai matcher waitFor. v1.1.3 Expanded test &amp; chunk options. v1.1.2 Updated mocha to latest version. Updated glace-utils to support config parents loading. v1.1.1 Fixed typo in tests loader method to scan test modules. Added feature to show tests summary time. Added feature to capture skipped tests in reporters. Fixed bug with disorder in plugins loader. v1.1.0 Generate session ID on start. v1.0.9 Show a number of executed chunks in report. Show link to xunit report if it is active. v1.0.8 Supports xunit reporter, which may be activated with CLI option --xunit. v1.0.7 Plugin reporters are registered on reporting system loading. CLI option --chunk timeout &lt;timeout&gt; sets time (sec) to execute for all hooks and chunks. Default value is 180 sec. Test or scope option { chunkTimeout: &lt;timeout&gt; } sets time (sec) to execute for hooks and chunks inside test or scope and overrides global value. Ã— Search results Close "},"tutorial-reports.html":{"id":"tutorial-reports.html","title":"Tutorial: Test reports","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Test reports Ã— Search results Close "},"tutorial-retry.html":{"id":"tutorial-retry.html","title":"Tutorial: Tests and chunks retry","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Tests and chunks retry Ã— Search results Close "},"tutorial-steps-architecture.html":{"id":"tutorial-steps-architecture.html","title":"Tutorial: STEPS architecture","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest STEPS architecture glace approach of functional autotests development is based on next principles: Any complex test can be divided to atomic steps. For example, glace-js/tests/e2e/testProxy.js#L3: test(&quot;Proxy subsystem&quot;, () =&gt; { chunk(&quot;It should use URL via global proxy&quot;, async () =&gt; { await $.restartBrowser(); await $.openUrl(&quot;https://opennet.ru&quot;); }); chunk(&quot;It should manage global proxy inside test&quot;, async () =&gt; { await $.restartBrowser(); await $.openUrl(&quot;https://opennet.ru&quot;); await $.stopGlobalProxy(); await $.restartBrowser(); await $.openUrl(&quot;https://opennet.ru&quot;); await $.startGlobalProxy(); }); }); Almost all tests contain steps which are (or can be) used in other tests. Each step should be finished with verification that its result is correct. For example, glace-web/lib/steps/browser.js#L508: openUrl: async function (webUrl, opts) { opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); var timeout = U.defVal(opts.timeout, CONF.web.pageTimeout) * 1000; allure.step(`Open URL &quot;${webUrl}&quot; in browser`); LOG.info(`Openning URL &quot;${webUrl}&quot; in browser...`); await this.webdriver.url(webUrl); if (check) { var errMsg = `Browser did not navigate to &quot;${webUrl}&quot; ` + `during ${timeout} ms`; await this.webdriver.waitUntil(async () =&gt; { var curUrl = await this.webdriver.getUrl(); LOG.debug(`Compare current URL &quot;${curUrl}&quot; with expected &quot;${webUrl}&quot;`); return curUrl.startsWith(webUrl); }, timeout, errMsg); }; LOG.info(&quot;URL is opened&quot;); allure.pass(); }, Verification of step can be disabled if it needs for negative scenarios. Steps are separated to change-steps, get-steps, check-steps. change-step changes state of system. For example, it creates / updates / removes resource (object / value): createUser, launchBrowser. get-step returns resource. For example: getBrowser, getWindows. check-step checks state of resource. For example, checkBrowserPresence, checkUserExistence. change-step should return true if it was executed and doesn't return another step-specific value. For example, glace-web/lib/steps/browser.js#L440: LOG.info(&quot;Browser is closed&quot;); allure.pass(); return true; // HERE }, change-step should return false if it wasn't executed. For example, glace-web/lib/steps/browser.js#L411: if (!this._webdrivers().top()) { LOG.debug(&quot;No one browser is launched yet&quot;); return false; // HERE }; change-steps can be connected to opposite pair: start &amp; finish. For example: launchBrowser &amp; closeBrowser. if start-step wasn't executed, finish-step shouldn't be executed. For example, glace-web/lib/fixtures.js#L41: global.fxBrowser = func =&gt; { var isStarted; before(async () =&gt; { isStarted = await $.launchBrowser(); }); func(); after(async () =&gt; { if (!isStarted) return; // HERE await $.closeBrowser(); }); }; Ã— Search results Close "},"tutorial-steps-protocol.html":{"id":"tutorial-steps-protocol.html","title":"Tutorial: Plugins system & STEPS protocol","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Plugins system &amp; STEPS protocol Plugins are used to outfit glace-core with steps for specific functionality which is missing in the core. Currently glace ecosystem provides next plugins which are assembled in project glace-js: glace-image - to process images &amp; screenshots; glace-proxy - to manage http &amp; mitm proxy servers; glace-testgen - to generate (auto)tests with ML; glace-video - to capture &amp; process video; glace-web - to launch web tests in browser; glace-xvfb - to launch tests in virtual display (headless); Core Extension PointsMain task of any plugin to provide additional steps, but it also can supply config, help, fixtures, which are involved in extension points in glace-core. Configurating is a first stage in glace-core, all other happens after. And plugin configs also will be loaded right after core configuration in glace-core/lib/config.js#L271: if (args.pluginsDir) config.plugins.dir = path.join(U.cwd, args.pluginsDir); config.plugins.disableDefault = U.defVal(args.disableDefaultPlugins, false); plugins.getModules(&quot;config&quot;); // HERE config.tools = U.defVal(config.tools, {});Plugin steps are loaded in glace-core/lib/steps/index.js#L153: Steps.register(require(&quot;./timer&quot;)); /* Load plugins steps */ Steps.register.apply(Steps, plugins.getModules(&quot;Steps&quot;)); // HERE /** * Set up debug mode for glace.Plugin helps are loaded in glace-core/lib/help.js#L264: }); for (var help of plugins.getModules(&quot;pluginHelp&quot;)) { // HERE result = help(result, d); }Plugin configs &amp; helps can include options which are used as inside plugin as in a project, which involve core &amp; plugins. For example, CLI option --global-proxy is defined in glace-proxy plugin but isn't used inside the plugin, because the plugin doesn't know when global proxy should be activated. But it's involved in glace-js which knows precisely when global proxy should start, glace-js/lib/globals.js#L26: if (CONF.web.use &amp;&amp; !CONF.cluster.slavesNum) fixtures.push(fxKillWebdriver); if (CONF.xvfb.use) fixtures.push(fxXvfb); if (CONF.proxy.global) fixtures.push(fxGlobalProxy); // HERE if (CONF.proxy.http) fixtures.push(fxHttpProxy);Fixtures are not loaded via an extension point. Cause they are global objects and wrappers over steps, they should be initialized with fixtures import in plugin steps, like glace-proxy/lib/steps.js#L22: var U = require(&quot;glace-utils&quot;); require(&quot;./fixtures&quot;); // HERE var GlobalProxy = require(&quot;./globalProxy&quot;); var HttpProxy = require(&quot;./httpProxy&quot;);Plugins Lazy Loadglace-core loads a found plugin by name and takes objects from a module, marked as main in plugin package.json. This module includes all objects, which are provided by plugin. In such case in order to avoid all objects initialisation on first request, like steps together with config, plugins should use lazy load on demand, like in glace-image/lib/index.js#L10: Object.defineProperties(exports, { /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {pluginHelp} */ pluginHelp: { get: function () { pluginHelp = pluginHelp || require(&quot;./pluginHelp&quot;); return pluginHelp; } }, /** * @type {ImageSteps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, });And commonly lazy load is a good practice to load required stuff when it's required only. Plugin StepsPlugin steps are mixin objects and don't have a constructor. For example, glace-proxy/lib/steps.js#L28: var ProxySteps = { __GlobalProxy: GlobalProxy, __HttpProxy: HttpProxy, registerProxy: function (opts) { /** * Helper to register proxy classes.Steps designed in plugin should also follow STEPS-architecture and can refer to steps and properties defined in other plugins or core under Steps instance. Approach to design &amp; deliver steps together with other plugin stuff is named STEPS-protocol. Plugins Autodiscoveryglace-core automatically loads plugin if it's located in npm-folders and its name starts with glace- prefix (exceptions are glace-core, glace-js, glace-utils). Register custom plugins with CLIIf plugin has name or location ineligible for autodiscovery, it can be loaded explicitly with CLI option --plugins-dir &lt;/path/to/dir/of/plugins&gt;. Plugins inside the folder can be as a .js file as a folder within index.js and will be loaded by their names. Register custom plugins programmaticallyIf there is a wrapper over glace-core runner, any custom plugin can be registered programmatically there as well, like glace-web/tests/run#L5: var path = require(&quot;path&quot;); var glace = require(&quot;glace-core&quot;); glace.plugins.register(path.resolve(__dirname, &quot;..&quot;, &quot;lib&quot;)); // HERE glace.run(process.exit);List found pluginsWith CLI option --list-plugins it's possible to print all available plugins and their location, for example: âžœ glace-js git:(master) âœ— ./bin/glace --list-plugins 1. glace-image /home/user/projects/glace/glace-js/node_modules/glace-image 2. glace-proxy /home/user/projects/glace/glace-js/node_modules/glace-proxy 3. glace-testgen /home/user/projects/glace/glace-js/node_modules/glace-testgen 4. glace-video /home/user/projects/glace/glace-js/node_modules/glace-video 5. glace-web /home/user/projects/glace/glace-js/node_modules/glace-web 6. glace-xvfb /home/user/projects/glace/glace-js/node_modules/glace-xvfb Ã— Search results Close "},"tutorial-test-fixtures.html":{"id":"tutorial-test-fixtures.html","title":"Tutorial: Test fixtures","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Test fixtures If you need to provide some before and/or after hooks in tests or group of tests, in order to avoid copy-paste you may develop and reuse fixtures. var myFixture = func =&gt; { before(() =&gt; { console.log(&quot;called before&quot;); }); func(); after(() =&gt; { console.log(&quot;called after&quot;); }); }; test(&quot;My test&quot;, /* options */ null, [myFixture], () =&gt; { chunk(() =&gt; {}); }); scope(&quot;My tests&quot;, /* options */ null, [myFixture], () =&gt; { test(&quot;#1&quot;, () =&gt; { chunk(() =&gt; {}); }); test(&quot;#2&quot;, () =&gt; { chunk(() =&gt; {}); }); }); Ã— Search results Close "},"tutorial-test-options.html":{"id":"tutorial-test-options.html","title":"Tutorial: Test & chunk options","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest Test &amp; chunk options When you develop a test you may pass options to test or chunk, which override config values for concrete test or chunk. Test optionsskip unwanted testtest(&quot;My test&quot;, { skip: true }, () =&gt; { chunk(() =&gt; { // payload }); });test(&quot;My test&quot;, { skip: &quot;Opened bug http://tracker.com/bugs/121&quot; }, () =&gt; { chunk(() =&gt; { // payload }); });retry failed testtest(&quot;My test&quot;, { retry: 2 }, () =&gt; { chunk(() =&gt; { // payload }); })retry failed chunkstest(&quot;My test&quot;, { chunkRetry: 2 }, () =&gt; { chunk(() =&gt; { // payload }); });chunks execution timeouttest(&quot;My test&quot;, { chunkTimeout: 1 }, () =&gt; { chunk(() =&gt; { // payload }); });Chunk optionsretry failed chunktest(&quot;My test&quot;, () =&gt; { chunk({ retry: 2 }, () =&gt; { // payload }); });chunk execution timeouttest(&quot;My test&quot;, () =&gt; { chunk({ timeout: 1 }, () =&gt; { // payload }); }); Ã— Search results Close "},"tutorial-tests-loading.html":{"id":"tutorial-tests-loading.html","title":"Tutorial: How glace loads tests","body":" GlaceJS Namespaces GlaceConfig Modules allureclassifiercliclustererrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/dotsreporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtoolsutils Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials Commonly Used FunctionsGlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architecturePlugins system &amp; STEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterafterChunkallurebeforebeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrunscopesessionsinonstubObjectsuitetest How glace loads tests By default glace tries to load tests from folder tests in the same folder where command glace was called. Tests are loaded from folder recursively from subfolders too. It's possible to explicitly specify path to tests folder, for example: glace /path/to/tests/dir, or to sequence of folders: glace /path/to/dir1 /path/to/dir2. In folder, test files should have prefix test, for example: testMainPage.js, tests.js, etc. Otherwise they will be missed. Also it's possible to specify path to test file or sequence of test files (prefix test isn't require in such case): glace /path/to/myTests.js /path/to/otherTests.js. Or to mix folders and files: glace /path/to/tests/dir /path/to/myTests.js. conftest.jsconftest.js is a special file which will be loaded before tests loading and usually contains some preparation stuff. Conftest may be located in any folder inside test folder hierarchy. If conftest is located on one level with tests folder it will be loaded before tests session start and global objects initialization. It's possible to specify root conftest path via CLI option --root-conftest which will be loaded before top level conftests, but after programmatically configured preloads. Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
