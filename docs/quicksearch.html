<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"globals_index.js.html":{"id":"globals_index.js.html","title":"Source: globals/index.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/index.js &quot;use strict&quot;; /** * Contains global framework functions and helpers. * * @module */ var util = require(&quot;util&quot;); var chai = require(&quot;chai&quot;); var sinon = require(&quot;sinon&quot;); chai.use(require(&quot;chai-as-promised&quot;)); chai.use(require(&quot;chai-datetime&quot;)); chai.use(require(&quot;chai-fs&quot;)); chai.use(require(&quot;chai-string&quot;)); chai.use(require(&quot;sinon-chai&quot;)); require(&quot;../matcher&quot;); var CONF = require(&quot;../config&quot;); var plugins = require(&quot;../plugins&quot;); var Steps = require(&quot;../steps&quot;); var ScopeType = require(&quot;../testing&quot;).ScopeType; var _scope = require(&quot;./scope&quot;); /** * `chaijs` `expect` function. * * @global * @function * @arg {*} actualValue - Some actual value which should be checked. * @see {@link http://chaijs.com/|chaijs} to get more details about * `expect` usage. * @example expect(1).to.be.equal(1); expect(2).to.be.gte(0); */ global.expect = chai.expect; /** * `SinonJS` is pretty nice lib for mocking. * * @global */ global.sinon = sinon; var stubObject = (obj, returns, processed) =&gt; { processed = processed || []; processed.push(obj); for (var prop in obj) { if (prop.startsWith(&quot;__&quot;) || [&quot;prototype&quot;, &quot;constructor&quot;].includes(prop)) { continue; } if (util.isFunction(obj[prop])) { obj[prop] = sinon.stub(); if (returns) { if (util.isObject(returns)) { if (prop in returns) obj[prop].returns(returns[prop]); } else { obj[prop].returns(returns); } } } if (util.isObject(obj[prop]) &amp;&amp; !processed.includes(obj[prop])) { obj[prop] = stubObject(obj[prop], returns, processed); } } return obj; }; /** * Stubs object with its properties recursively. * * @global * @arg {object} obj - Object to stub. * @arg {object|number|string} returns - Returned values. * @return {object} Object with stubbed functions. */ global.stubObject = stubObject; global.rewire = require(&quot;./rewire&quot;); /** * `GlaceJS` config. * * @global * @see {@link module:config|config} to get more details about its options. */ global.CONF = CONF; /** * Allure helper. * * @global */ global.allure = require(&quot;../allure&quot;); /** * Steps collection. * * @global * @type {Steps} * @see {@link module:steps/index|steps} to get more details about its methods. */ global.$ = global.$$ = global.SS = Steps.getInstance(); global.scope = (name, opts, fixtures, func) =&gt; { _scope(new ScopeType(name).setType(&quot;scope&quot;), opts, fixtures, func); }; global.suite = (name, opts, fixtures, func) =&gt; { _scope(new ScopeType(name).setType(&quot;suite&quot;), opts, fixtures, func); }; global.session = require(&quot;./session&quot;).session; global.test = require(&quot;./test&quot;); global.jaki = global.jaki_chunk = global.chunk = require(&quot;./chunk&quot;); global.forEachLanguage = require(&quot;./forEachLanguage&quot;); /** * Executes before each test chunk. * * @global * @function * @arg {string} name - Name of test case. * @arg {function} func - Hook function. * @example test(&quot;Some test&quot;, () =&gt; { beforeChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); */ global.beforeChunk = beforeEach; /** * Executes after each test chunk. * * @global * @function * @arg {string} name - Name of test case. * @arg {function} func - Hook function. * @example test(&quot;Some test&quot;, () =&gt; { afterChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); */ global.afterChunk = afterEach; /* Load globals from plugins */ plugins.getModules(&quot;globals&quot;); × Search results Close "},"globals_test.js.html":{"id":"globals_test.js.html","title":"Source: globals/test.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/test.js &quot;use strict&quot;; const path = require(&quot;path&quot;); const _ = require(&quot;lodash&quot;); const U = require(&quot;glace-utils&quot;); const LOG = U.logger; const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const ScopeType = require(&quot;../testing&quot;).ScopeType; const retryTests = require(&quot;./session&quot;).retryTests; const _scope = require(&quot;./scope&quot;); let GID = 0; /** * Helper to set actual log file. * * @function */ const setLog = () =&gt; { const testName = CONF.test.curCase ? U.toKebab(CONF.test.curCase.name) : &quot;&quot;; const logFile = path.resolve(CONF.report.logsDir, testName, &quot;logs&quot;, &quot;test.log&quot;); LOG.setFile(logFile); }; setLog(); // Set log immediately. /** * Basis for any test case. * * If test with the same was registered already, this test will be omitted * with corresponding error in log. * * If retries amount is specified and this test was failed, the test will be * added to queue in separated session with title containing `Retry` and its * number. * * @abstract * @function * @arg {string} name - Name of test case. * @arg {object} [opts] - Options. * @arg {boolean|string} [opts.skip=false] - Flag to skip test or skip reason. * @arg {number} [opts.retry=0] - Number of retries on failure. Overrides * config value for concrete test. * @arg {number} [opts.chunkRetry=0] - Number of chunk retries on failure. * Overrides config value for concrete test chunks. * @arg {?number} [opts.chunkTimeout=null] - Time to execute chunk or hook, sec. * @arg {function[]} [fixtures] - Involved fixtures list. * @arg {function} func - Test function. */ const baseTest = (names =&gt; { return (name, opts, fixtures, func) =&gt; { GID++; let preloaded_chunk_ids; const o = {}; if (CONF.filter.include) { let isIncluded = false; for (const include of CONF.filter.include) { if (isFilterMatched(name, include.name)) { preloaded_chunk_ids = include.passed_chunk_ids; isIncluded = true; break; } } if (!isIncluded) return; } if (CONF.filter.exclude) { for (const exclude of CONF.filter.exclude) { if (isFilterMatched(name, exclude.name)) return; } } if (CONF.test.checkNames) { if (names.includes(name)) { throw new Error(`Test case '${name}' is added already`); } names.push(name); } if (opts instanceof Function) { func = opts; opts = {}; fixtures = []; } if (fixtures instanceof Function) { func = fixtures; fixtures = []; } opts = opts || {}; o.fixtures = fixtures || []; o.func = func; o.name = name; const skip = !!opts.skip; const skipReason = _.isString(opts.skip) ? opts.skip : null; o.retries = U.defVal(opts.retry, CONF.test.retries, 0); o.testOpts = {}; o.testOpts.chunkRetry = U.defVal(opts.chunkRetry, CONF.test.chunkRetries, 0); o.testOpts.chunkTimeout = U.defVal(opts.chunkTimeout); o.testCase = new TestCase(name, GID); o.testCase.addPassedChunkIds(preloaded_chunk_ids || []); CONF.test.cases.push(o.testCase); if (skip) { o.testCase.status = TestCase.SKIPPED; if (skipReason) o.testCase.addDetails(skipReason); return; } testFunc(o); }; })([]); const testFunc = o =&gt; { CONF.counters.testId = o.testCase.id; CONF.counters.chunkId = 0; _scope(new ScopeType(o.name).setType(&quot;test&quot;), o.testOpts, () =&gt; { before(beforeCb(o)); U.wrap(o.fixtures, o.func)(); after(afterCb(o)); }); }; const beforeCb = o =&gt; () =&gt; { o.testCase.reset(); o.testCase.start(); CONF.test.curCase = o.testCase; setLog(); // Current test case is started, need to reinit log }; const afterCb = o =&gt; () =&gt; { if (o.testCase.errors.length) { o.testCase.end(TestCase.FAILED); } else { o.testCase.end(TestCase.PASSED); } CONF.test.curCase = null; setLog(); // Current test case is finished, need to reinit log if (o.testCase.status !== TestCase.FAILED || o.retries &lt;= 0) { return; } o.retries--; retryTests.push({ func: testFunc, args: o }); }; /** * Executes test case. * * @global * @function * @arg {string} name - Name of test case. * @arg {object} [opts] - Options. * @arg {boolean|string} [opts.skip=false] - Flag to skip test or skip reason. * @arg {number} [opts.retry=0] - Number of retries on failure. Overrides * config value for concrete test. * @arg {number} [opts.chunkRetry=0] - Number of chunk retries on failure. * Overrides config value for concrete test chunks. * @arg {?number} [opts.chunkTimeout=null] - Time to execute chunk or hook, sec. * @arg {function[]} [fixtures] - Involved fixtures list. * @arg {function} func - Test function. * @example * * test(&quot;Some test&quot;, () =&gt; { * chunk(&quot;Some chunk&quot;, () =&gt; { * someFunc(); * }); * }); * */ const test = (name, opts, fixtures, func) =&gt; { if (opts instanceof Function) { func = opts; opts = {}; fixtures = []; } if (fixtures instanceof Function) { func = fixtures; fixtures = []; } opts = opts || {}; fixtures = fixtures || []; baseTest(name, opts, fixtures, func); }; const isFilterMatched = (testName, filterName) =&gt; { if (CONF.filter.precise) { return testName.toLowerCase() === filterName.toLowerCase(); } else { return testName.toLowerCase().includes(filterName.toLowerCase()); } }; module.exports = test; × Search results Close "},"globals_chunk.js.html":{"id":"globals_chunk.js.html","title":"Source: globals/chunk.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/chunk.js &quot;use strict&quot;; var util = require(&quot;util&quot;); var CONF = require(&quot;../config&quot;); /** * Defines test chunk. * * Contains actions and verifications, which will be executed separatly * from another chunks. This function is used to organize test * structure and to allocate independent test actions. * * @global * @function * @arg {string} [name] - Name of chunk. * @arg {object} [opts] - Chunk options. * @arg {number} [opts.retry] - Number of chunk retries on failure. * @arg {number} [opts.timeout] - Time limit to execute chunk, sec. * @arg {function} func - Callback function with test payload. * * @example &lt;caption&gt;&lt;b&gt;Anonymous chunk&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(() =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Named chunk&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(&quot;My chunk&quot;, () =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); * * @example &lt;caption&gt;&lt;b&gt;Chunk with options&lt;/b&gt;&lt;/caption&gt; * * test(&quot;My test&quot;, () =&gt; { * chunk(&quot;My chunk&quot;, { retry: 2, timeout: 1 }, () =&gt; { * var a = 5; * expect(a).to.be.equal(2); * }); * }); */ var chunk = (name, opts, func) =&gt; { if (name instanceof Function) { func = name; name = &quot;&quot;; opts = {}; } if (opts instanceof Function) { func = opts; opts = {}; } if (name instanceof Object) { opts = name; name = &quot;&quot;; } name = name || &quot;&quot;; opts = opts || {}; CONF.counters.chunkId++; const chunkId = CONF.counters.testId + &quot;_&quot; + CONF.counters.chunkId; if (CONF.counters.passedChunkIds.includes(chunkId)) return; it(name, _chunkCb(name, chunkId, opts, func)); }; /** * Chunk callback. * @ignore */ var _chunkCb = (name, chunkId, opts, func) =&gt; function () { CONF.test.curCase.addChunk(name); CONF.counters.curChunkId = chunkId; if (opts.retry) this.retries(opts.retry); if (opts.timeout) this.timeout(opts.timeout * 1000); var result = func(); if (util.isObject(result) &amp;&amp; util.isFunction(result.then)) { result = result.then(r =&gt; { if (r === false) CONF.test.curCase.skipChunk = name; return r; }); } else { if (result === false) CONF.test.curCase.skipChunk = name; } return result; }; module.exports = chunk; × Search results Close "},"globals_forEachLanguage.js.html":{"id":"globals_forEachLanguage.js.html","title":"Source: globals/forEachLanguage.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/forEachLanguage.js &quot;use strict&quot;; var U = require(&quot;glace-utils&quot;); var CONF = require(&quot;../config&quot;); /** * Iterates test chunks through all languages specified in config or options. * * It's applicable for multilingual application. If list of languages is * specified, it will be used firstly. Otherwise from configuration. * * @global * @function * @arg {object} [ctx] - Test case context. * @arg {object} [opts] - Options. * @arg {?string[]} [opts.languages] - List of tested languages. * @arg {function[]} [fixtures] - Involved fixtures list. * @arg {function} func - Function with test steps. * @example * * test(&quot;Some test&quot;, ctx =&gt; { * forEachLanguage(ctx, lang =&gt; { * chunk(() =&gt; { * // payload * }); * }); * }); */ var forEachLanguage = (name, opts, fixtures, func) =&gt; { if (name instanceof Function) { func = name; name = null; opts = {}; fixtures = []; } if (opts instanceof Function) { func = opts; opts = {}; fixtures = []; } if (fixtures instanceof Function) { func = fixtures; fixtures = []; } name = name || null; opts = opts || {}; fixtures = fixtures || []; (opts.languages || CONF.test.languages).forEach(_langCb(name, fixtures, func)); }; var _langCb = (name, fixtures, func) =&gt; lang =&gt; { name = name || &quot;for language&quot;; scope(`${name} &quot;${lang}&quot;`, () =&gt; { before(() =&gt; { if (CONF.test.curCase) { CONF.test.curCase.testParams.language = lang; } }); U.wrap(fixtures, () =&gt; func(lang))(); }); }; module.exports = forEachLanguage; × Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: config.js &quot;use strict&quot;; /** * Configures `GlaceJS` before tests run. * * @namespace GlaceConfig * @prop {object} session - Session namespace. * @prop {string} session.name - Session name. By default contains timestamp. * Can be overridden with CLI option `--session-name`. * @prop {string} session.id - Session ID. Default is timestamp. * @prop {boolean} [session.isPassed=false] - Flag to define if tests session * run is passed or no. * @prop {array&lt;string&gt;} [session.preloads=[]] - Array of paths to `js` modules * which will be loaded before tests session run. * @prop {boolean} [session.interactive=false] - Flag to launch interactive * session. Can be overridden with CLI option `-i / --interactive`. * @prop {boolean} [session.debugOnFail=false] - Flag to enter to interactive * mode on step failure. Can be overridden with CLI option `--debug-on-fail`. * @prop {boolean} [session.exitOnFail=false] - Flag to break tests session on * first test failure. Can be overridden with CLI option `--exit-on-fail`. * @prop {string} [session.uncaughtException=log] - Strategy to process uncaught * exceptions. Available values are `log`, `fail`, `mocha`. Can be overridden * with CLI option `--uncaught`. * @prop {string} session.rootConftest - Path to `js` module which will be * loaded right after preloads. Can be overridden with CLI * option `--root-conftest`. * @prop {array&lt;string&gt;} session.killProcs - Array of process names which will * be killed before tests session run. Can be overridden with CLI * option `--kill-procs`. * @prop {object} test - Test namespace. * @prop {?TestCase} [test.curCase=null] - Currently executed test case. * @prop {array&lt;TestCase&gt;} [test.cases=[]] - Array of session test cases. * @prop {array&lt;string&gt;} [test.languages=[]] - Array of language names. Can be * overridden with CLI option `--languages`. * @prop {array&lt;string&gt;} [test.dirs=[]] - Array of test files or folders. Can * be overridden with CLI arguments or option `--targets` separated with comma. * @prop {boolean} [test.checkNames=true] - Flag to check test names uniqueness. * Can be overridden with CLI option `--dont-check-names`. * @prop {integer} [test.retries=0] - Number of test retries on failure. Can * be overridden with CLI option `--retry`. * @prop {integer} [test.chunkRetries=0] - Number of chunk retries on failure. * Can be overridden with CLI option `--chunk-retry`. * @prop {integer} [test.chunkTimeout=180000] - Timeout of chunk execution, ms. * Can be overridden with CLI option `--chunk-timeout`, sec. * @prop {object} report - Report namespace. * @prop {string} [report.dir=cwd/report] - Folder to save tests session report. * @prop {string} [report.logsDir=report.dir] - Folder to save test logs. Can * be overridden with CLI option `--report-dir`. * @prop {boolean} [report.clear=true] - Flag to clear report before tests run. * Can be overridden with CLI option `--dont-clear-report`. * @prop {boolean} [report.errorsNow=false] - Flag to print test error right * after its capture. Can be overridden with CLI option `--errors-now`. * @prop {string} [report.failedTestsPath=cwd/failed-tests.json] - Path to file * where info about failed tests will be saved to. Can be overridden with CLI * option `--failed-tests-path`. * @prop {object} [xunit] - xUnit report namespace. * @prop {boolean} [xunit.use=false] - Flag to activate xUnit report. Can be * overridden with CLI option `--xunit`. * @prop {string} [xunit.path=report.dir/xunit.xml] - Path to xUnit report. Can * be overridden with CLI option `--xunit-path`. * @prop {string} [xunit.suiteName=session.name] - xUnit suite name. Can be * overridden with CLI option `--xunit-suite-name`. * @prop {object} [allure] - Allure report namespace. * @prop {boolean} [allure.use=false] - Flag to activate allure report. Can be * overridden with CLI option `--allure`. * @prop {string} [allure.dir=report.dir/allure] - Folder to save allure report. * Can be overridden with CLI option `--allure-dir`. * @prop {string} [allure.suiteName=session.name] - Allure suite name. Can be * overridden with CLI option `--allure-suite-name`. * @prop {object} testrail - Testrail report namespace. * @prop {boolean} [testrail.use=false] - Flag to activate testrail report. Can * be overridden with CLI option `--testrail`. * @prop {string} testrail.host - Testrail host. Can be overridden with CLI * option `--testrail-host`. * @prop {string} testrail.user - Testrail user name or email. Can be overridden * with CLI option `--testrail-user`. * @prop {string} testrail.token - Testrail auth token. Can be overridden with * CLI option `--testrail-token`. * @prop {string} testrail.projectId - Testrail project ID. Can be overridden * with CLI option `--testrail-project-id`. * @prop {string} testrail.suiteId - Testrail suite ID. Can be overridden with * CLI option `--testrail-suite-id`. * @prop {string} testrail.runName - Testrail run name. Can be overridden with * CLI option `--testrail-run-name`. * @prop {string} testrail.runDescription - Testrail run description. Can be * overridden with CLI option `--testrail-run-description`. * @prop {object} plugins - Plugins namespace. * @prop {string} plugins.dir - Folder with custom plugins. Can be overridden * with CLI option `--plugins-dir`. * @prop {object} filter - Tests filter namespace. * @prop {string} filter.grep - Mocha grep option to filter tests, scopes and * suites. Can be overridden with CLI option `-g / --grep`. * @prop {array&lt;string&gt;} filter.include - List of test names which should be * included to tests session. Can be overridden with CLI option `--include`. * @prop {array&lt;string&gt;} filter.exclude - List of test names which should be * excluded from tests session. Can be overridden with CLI option `--exclude`. * @prop {boolean} [filter.precise=false] - Flag for precise tests inclusion or * exclusion (not substring pattern). Can be overridden with CLI option * `--precise`. * @prop {object} tools - Tools namespace. * @prop {boolean} [tools.stepsList=false] - Flag to list available steps only. * Can be overridden with CLI option `--list-steps`. * @prop {string} tools.stepsFilter - String to filter steps. Can be overridden * with CLI option `--list-steps`. * @prop {boolean} [tools.testsList=false] - Flag to list implemented tests * only. Can be overridden with CLI option `--list-tests`. * @prop {string} tools.testsFilter - String to filter tests. Can be overridden * with CLI option `--list-tests`. * @prop {boolean} [tools.fixturesList=false] - Flag to list available fixtures * only. Can be overridden with CLI option `--list-fixtures`. * @prop {string} tools.fixturesFilter - String to filter fixtures. Can be * overridden with CLI option `--list-fixtures`. * @prop {boolean} [tools.checkTestrail=false] - Flag to check matching of * testrail cases with implemented tests only. Can be overridden with CLI * option `--testrail-check`. */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); require(&quot;colors&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const U = require(&quot;glace-utils&quot;); U.docString(); const plugins = require(&quot;./plugins&quot;); let config = U.config; const args = config.args; if (U.config.__testmode) config = {}; // not affect global config in test mode config.counters = U.defVal(config.counters, {}); config.counters.testId = 0; config.counters.chunkId = 0; config.counters.curChunkId = null; config.counters.passedChunkIds = []; config.session = U.defVal(config.session, {}); const date = new Date(); config.session.name = U.defVal(args.sessionName, `Session ${date.toLocaleString()}`); config.session.id = date.getTime(); config.session.isPassed = false; config.session.preloads = []; config.session.interactive = args.i || args.interactive || false; config.session.debugOnFail = args.debugOnFail || false; config.session.exitOnFail = args.exitOnFail || false; config.session.uncaughtException = (args.uncaught || &quot;log&quot;).toLowerCase(); expect([ &quot;log&quot;, &quot;fail&quot;, &quot;mocha&quot; ], &quot;Invalid `--uncaught` option&quot;).include(config.session.uncaughtException); if (args.rootConftest) config.session.rootConftest = path.resolve(U.cwd, args.rootConftest); if (args.killProcs) config.session.killProcs = U.splitBy(args.killProcs, &quot;,&quot;); const get_targets = () =&gt; { let tt; if (args._ &amp;&amp; args._.length) { tt = args._; } else if (args.targets &amp;&amp; args.targets.length) { tt = U.splitBy(args.targets, &quot;,&quot;); } else { tt = [&quot;tests&quot;]; }; return tt.map(t =&gt; path.resolve(U.cwd, t)); }; config.test = U.defVal(config.test, {}); config.test.curCase = null; config.test.cases = []; config.test.languages = []; if (args.languages) config.test.languages = U.splitBy(args.languages, &quot;,&quot;); config.test.dirs = get_targets(); config.test.checkNames = !args.dontCheckNames; config.test.retries = U.defVal(args.retry, 0); expect(config.test.retries, &quot;Invalid `--retry` option&quot;).to.be.gte(0); config.test.chunkRetries = U.defVal(args.chunkRetry, 0); expect(config.test.chunkRetries, &quot;Invalid `--chunk-retry` option&quot;).to.be.gte(0); config.test.chunkTimeout = (args.chunkTimeout || 180) * 1000 || Infinity; config.test.__chunkId = [0 /* test id */, 0 /* chunk id in test */]; config.test.__curChunkId = null; config.report = U.defVal(config.report, {}); config.report.dir = path.resolve(U.cwd, U.defVal(args.reportDir, &quot;report&quot;)); config.report.logsDir = config.report.dir; config.report.clear = !args.dontClearReport; config.report.errorsNow = args.errorsNow || false; config.report.failedTestsPath = path.resolve(config.report.dir, U.defVal(args.failedTestsPath, &quot;failed-tests.json&quot;)); if (!config.report.failedTestsPath.endsWith(&quot;.json&quot;)) config.report.failedTestsPath += &quot;.json&quot;; const tests_filter = filter =&gt; { const filePath = path.resolve(U.cwd, filter); if (fs.existsSync(filePath)) { config.filter.precise = true; return U.loadJson(filePath); } else { return U.splitBy(filter, &quot;|&quot;).map(e =&gt; { return { name: e }; }); } }; config.filter = U.defVal(config.filter, {}); config.filter.grep = args.g || args.grep; config.filter.precise = args.precise || false; if (args.include) config.filter.include = tests_filter(args.include); if (args.exclude) config.filter.exclude = tests_filter(args.exclude); if (config.filter.include) { for (const include of config.filter.include) { if (!include.passed_chunk_ids) continue; config.counters.passedChunkIds = config.counters.passedChunkIds.concat(include.passed_chunk_ids); } } config.xunit = U.defVal(config.xunit, {}); config.xunit.use = U.defVal(args.xunit, false); config.xunit.path = path.resolve(config.report.dir, U.defVal(args.xunitPath, &quot;xunit.xml&quot;)); config.xunit.suiteName = U.defVal(args.xunitSuiteName, config.session.name); config.allure = U.defVal(config.allure, {}); config.allure.use = U.defVal(args.allure, false); config.allure.dir = path.resolve(config.report.dir, U.defVal(args.allureDir, &quot;allure&quot;)); config.allure.suiteName = U.defVal(args.allureSuiteName, config.session.name); config.testrail = U.defVal(config.testrail, {}); config.testrail.use = U.defVal(args.testrail, false); config.testrail.host = U.defVal(args.testrailHost); config.testrail.user = U.defVal(args.testrailUser); config.testrail.token = U.defVal(args.testrailToken); config.testrail.projectId = U.defVal(args.testrailProjectId); config.testrail.suiteId = U.defVal(args.testrailSuiteId); config.testrail.runName = U.defVal(args.testrailRunName); config.testrail.runDescription = U.defVal(args.testrailRunDesc); config.plugins = U.defVal(config.plugins, {}); if (args.pluginsDir) config.plugins.dir = path.join(U.cwd, args.pluginsDir); config.plugins.disableDefault = U.defVal(args.disableDefaultPlugins, false); plugins.getModules(&quot;config&quot;); config.tools = U.defVal(config.tools, {}); config.tools.stepsList = !!args.listSteps; config.tools.stepsFilter = typeof(args.listSteps) === &quot;string&quot; ? args.listSteps : null; config.tools.testsList = !!args.listTests; config.tools.testsFilter = typeof(args.listTests) === &quot;string&quot; ? args.listTests : null; config.tools.fixturesList = !!args.listFixtures; config.tools.fixturesFilter = typeof(args.listFixtures) === &quot;string&quot; ? args.listFixtures : null; config.tools.pluginsList = !!args.listPlugins; config.tools.checkTestrail = U.defVal(args.testrailCheck, false); if (config.session.debugOnFail) { config.test.chunkTimeout = Infinity; config.xunit.use = false; config.allure.use = false; config.testrail.use = false; } if (config.session.interactive) { const temp = require(&quot;temp&quot;).track(); const tempPath = temp.path({ prefix: &quot;test&quot;, suffix: &quot;.js&quot; }); const tempData = &quot;test('interactive', () =&gt; chunk(async () =&gt; await $.debug()));&quot;; fs.writeFileSync(tempPath, tempData); config.test.dirs = [tempPath]; config.test.chunkTimeout = Infinity; config.filter.grep = null; config.filter.include = null; config.filter.exclude = null; config.xunit.use = false; config.allure.use = false; config.testrail.use = false; } let userConfig = {}; const userConfigPath = path.resolve(U.cwd, (args.userConfig || &quot;config.js&quot;)); if (fs.existsSync(userConfigPath)) userConfig = require(userConfigPath); _.assign(config, userConfig); module.exports = config; × Search results Close "},"reporter_base.js.html":{"id":"reporter_base.js.html","title":"Source: reporter/base.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/base.js &quot;use strict&quot;; /** * `GlaceJS` common reporter. * * @class * @name GlaceReporter * @arg {object} runner - `MochaJS` runner. */ const fs = require(&quot;fs&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const MochaReporter = require(&quot;mocha&quot;).reporters.base; const U = require(&quot;glace-utils&quot;); const LOG = U.logger; const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; /** * Registered reporters. * * @type {object[]} */ let reporters = []; let sessErrsNum = 0; // number of errors happened outside of test cases const GlaceReporter = function (runner) { MochaReporter.call(this, runner); runner.on(&quot;start&quot;, () =&gt; { for (const reporter of reporters) { if (reporter.start) reporter.start(); } }); runner.on(&quot;end&quot;, () =&gt; { if (!CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED).length &amp;&amp; !sessErrsNum) { CONF.session.isPassed = true; } if (fs.existsSync(CONF.report.dir)) { U.clearEmptyFolders(CONF.report.dir); } for (const reporter of reporters) { if (reporter.end) reporter.end(); } }); runner.on(&quot;suite&quot;, mochaSuite =&gt; { const methodName = { suite: &quot;suite&quot;, scope: &quot;scope&quot;, test: &quot;test&quot;, }[mochaSuite.title.type]; for (const reporter of reporters) { if (reporter[methodName]) reporter[methodName](mochaSuite); } }); runner.on(&quot;suite end&quot;, mochaSuite =&gt; { const methodName = { suite: &quot;suiteEnd&quot;, scope: &quot;scopeEnd&quot;, test: &quot;testEnd&quot;, }[mochaSuite.title.type]; for (const reporter of reporters) { if (reporter[methodName]) reporter[methodName](mochaSuite); } }); runner.on(&quot;test&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.chunk) reporter.chunk(mochaTest); } }); runner.on(&quot;test end&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.chunkEnd) reporter.chunkEnd(mochaTest); } }); runner.on(&quot;hook&quot;, mochaHook =&gt; { for (const reporter of reporters) { if (reporter.hook) reporter.hook(mochaHook); } }); runner.on(&quot;hook end&quot;, mochaHook =&gt; { for (const reporter of reporters) { if (reporter.hookEnd) reporter.hookEnd(mochaHook); } }); runner.on(&quot;pass&quot;, mochaTest =&gt; { if (CONF.counters.curChunkId &amp;&amp; !CONF.counters.passedChunkIds.includes(CONF.counters.curChunkId)) { CONF.counters.passedChunkIds.push(CONF.counters.curChunkId); if (CONF.test.curCase) { CONF.test.curCase.addPassedChunkId(CONF.counters.curChunkId); } CONF.counters.curChunkId = null; } if (CONF.test.curCase &amp;&amp; CONF.test.curCase.skipChunk === mochaTest.title) { mochaTest.state = &quot;skipped&quot;; CONF.test.curCase.skipChunk = null; } const method = mochaTest.state === &quot;skipped&quot; ? &quot;skip&quot; : &quot;pass&quot;; for (const reporter of reporters) { if (reporter[method]) reporter[method](mochaTest); } }); runner.on(&quot;fail&quot;, (mochaTest, err) =&gt; { if (CONF.test.curCase) { let errMsg = mochaTest.title; if (!_.isEmpty(CONF.test.curCase.testParams)) { errMsg += &quot;\\n&quot; + util.format(CONF.test.curCase.testParams); } if (err.message) { errMsg += &quot;\\nmessage: &quot; + err.message; } if (err.stack) { errMsg += &quot;\\nstack: &quot; + err.stack; } if (err.seleniumStack) { errMsg += &quot;\\nselenium: &quot; + JSON.stringify(err.seleniumStack, null, &quot;\\t&quot;); } CONF.test.curCase.addError(errMsg); } else { sessErrsNum++; } for (const reporter of reporters) { if (reporter.fail) reporter.fail(mochaTest, err); } if (CONF.session.exitOnFail) { CONF.test.curCase.end(TestCase.FAILED); runner.emit(&quot;end&quot;); } }); runner.on(&quot;pending&quot;, mochaTest =&gt; { for (const reporter of reporters) { if (reporter.pending) reporter.pending(mochaTest); } }); }; util.inherits(GlaceReporter, MochaReporter); module.exports = GlaceReporter; /** * Finalizes reporting. * * @function * @async * @arg {Array.&lt;*&gt;} failures - Tests failures. * @arg {function} fn - Finalizator. */ GlaceReporter.prototype.done = function (failures, fn) { let prms = Promise.resolve(); reporters.forEach(reporter =&gt; { if (reporter.done) { prms = prms .then(() =&gt; reporter.done()) .catch(e =&gt; LOG.error(e)); } }); return prms.then(() =&gt; fn(failures)); }; /** * Registers reporters if they are not. * * @method * @static * @arg {...object} reporters - Sequence of reporters to register. */ GlaceReporter.register = function () { for (const reporter of arguments) { if (!reporters.includes(reporter)) { reporters.push(reporter); } } }; /** * Removes reporters if they are registered. * * @method * @static * @arg {...object} reporters - Sequence of reporters to remove. */ GlaceReporter.remove = function () { const args = Array.from(arguments); args.unshift(reporters); reporters = _.without.apply(_, args); }; × Search results Close "},"run.js.html":{"id":"run.js.html","title":"Source: run.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: run.js &quot;use strict&quot;; /** * Runs tests. * * - executes `runner.js` file, which is entry point to load and execute * files with tests * - connects custom reporter to `mochajs`. * * @function * @name run * @arg {function} cb - Callback. */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var fse = require(&quot;fs-extra&quot;); var Mocha = require(&quot;mocha&quot;); var CONF = require(&quot;./config&quot;); var hacking = require(&quot;./hacking&quot;); var tools = require(&quot;./tools&quot;); var run = cb =&gt; { resetReport(); if (CONF.session.uncaughtException !== &quot;mocha&quot;) hacking.suppressMochaUncaught(); var mocha = new Mocha({ grep: CONF.filter.grep, timeout: CONF.test.chunkTimeout, retries: CONF.chunkRetries, reporter: path.resolve(__dirname, &quot;reporter&quot;) }); mocha.addFile(path.resolve(__dirname, &quot;loader.js&quot;)); if (cb) { _run(mocha, cb); } else { return new Promise(resolve =&gt; _run(mocha, resolve)); } }; /** * Runs mocha. * * @ignore */ var _run = (mocha, fin) =&gt; { mocha.run(code =&gt; { var clampedCode = Math.min(code, 255); if (CONF.session.isPassed) clampedCode = 0; fin(clampedCode); }); }; /** * Resets report folder. * * @ignore */ var resetReport = () =&gt; { if (CONF.report.clear &amp;&amp; fs.existsSync(CONF.report.dir)) { fse.removeSync(CONF.report.dir); } fse.mkdirsSync(CONF.report.dir); }; /** * Runs glace framework. * * @arg {function} cb - Callback. */ var glaceRun = cb =&gt; { if (CONF.tools.stepsList) { tools.listSteps(CONF.tools.stepsFilter); return cb(); } else if (CONF.tools.fixturesList) { tools.listFixtures(CONF.tools.fixturesFilter); return cb(); } else if (CONF.tools.testsList) { tools.listTests(CONF.tools.testsFilter); return cb(); } else if (CONF.tools.checkTestrail) { return tools.checkTestrail(cb); } else if (CONF.tools.pluginsList) { return tools.listPlugins(cb); } else { return run(cb); } }; module.exports = glaceRun; × Search results Close "},"help.js.html":{"id":"help.js.html","title":"Source: help.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: help.js &quot;use strict&quot;; /** * Help description. * * @function * @name help * @arg {function} d - Function to process option description. * @arg {function} cb - Callback to expand default help. */ require(&quot;colors&quot;); var U = require(&quot;glace-utils&quot;); var plugins = require(&quot;./plugins&quot;); module.exports = (d, cb) =&gt; { d = d || U.switchColor(); cb = cb || (o =&gt; o); var result = U.help(d) .usage(&quot;\\nglace [options] [sequence-of-test-files-or-folders]&quot;.white.bold) .options({ /* configuration */ &quot;user-config [path]&quot;: { describe: d(&quot;Path to JS file with configuration which will be&quot;, &quot;merged with override default configuration.&quot;, &quot;Default is 'cwd/config.js' (if it exists).&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;session-name [name]&quot;: { describe: d(&quot;Tests run session name.&quot;, &quot;Default value includes word 'session' and datetime.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;grep &lt;pattern&gt;&quot;: { alias: &quot;g&quot;, describe: d(&quot;Filter tests by name or name chunk (by mocha).&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;include &lt;sequence&gt;&quot;: { describe: d(&quot;Sequence of test name chunks separated by ' | '&quot;, &quot;in order to choose tests for run. Or path to json file&quot;, &quot;with test names and params.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;exclude &lt;sequence&gt;&quot;: { describe: d(&quot;Sequence of test name chunks separated by ' | '&quot;, &quot;in order to exclude tests from run. Or path to json file&quot;, &quot;with test names.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;precise&quot;: { describe: d(&quot;Precise tests inclusion or exclusion (not substring pattern).&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;report-dir [path]&quot;: { describe: d(&quot;Path to report folder. Default is 'cwd/report'.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;dont-clear-report&quot;: { describe: d(&quot;Don't clear previous report on tests run.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;dont-check-names&quot;: { describe: d(&quot;Don't check test names uniqueness&quot;, &quot;(usually useful in unit testing).&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;failed-tests-path [path]&quot;: { describe: d(&quot;Path to save failed tests in JSON format.&quot;, &quot;Default is 'cwd/report/failed-tests.json'.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;root-conftest &lt;path&gt;&quot;: { describe: d(&quot;Path to root conftest.js which will be loaded&quot;, &quot;before all.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;languages &lt;sequence&gt;&quot;: { describe: d(&quot;List of tested languages separated with comma.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;retry [times]&quot;: { describe: d(&quot;Number of times to retry failed test.&quot;, &quot;Default is 0.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;chunk-retry [times]&quot;: { describe: d(&quot;Number of times to retry failed chunk.&quot;, &quot;Default is 0.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;chunk-timeout [sec]&quot;: { describe: d(&quot;Time to execute chunk or hook, sec.&quot;, &quot;Default is 180.&quot;), type: &quot;number&quot;, group: &quot;Core:&quot;, }, &quot;uncaught [type]&quot;: { describe: d(&quot;Strategy to process uncaught exceptions.&quot;, &quot;Default value is 'log'. See details in&quot;, &quot;https://glacejs.github.io/glace-core&quot;), type: &quot;string&quot;, choices: [ &quot;log&quot;, &quot;fail&quot;, &quot;mocha&quot; ], group: &quot;Core:&quot;, }, &quot;kill-procs &lt;sequence&gt;&quot;: { describe: d(&quot;List of process names separated with comma,&quot;, &quot;which will be killed before tests run.&quot;), type: &quot;string&quot;, group: &quot;Core:&quot;, }, &quot;debug-on-fail&quot;: { describe: d(&quot;Enter to interactive debug mode on step failure.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;exit-on-fail&quot;: { describe: d(&quot;Finish test run on first failure.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;errors-now&quot;: { describe: d(&quot;Print error message immediately when it happened.&quot;), type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, &quot;interactive&quot;: { describe: d(&quot;Launch interactive mode to execute steps&quot;, &quot;manually in terminal.&quot;), alias: &quot;i&quot;, type: &quot;boolean&quot;, group: &quot;Core:&quot;, }, /* plugins */ &quot;list-plugins&quot;: { describe: d(&quot;List plugins end exit.&quot;), type: &quot;boolean&quot;, group: &quot;Plugins:&quot;, }, &quot;plugins-dir [path]&quot;: { describe: d(&quot;Path to custom plugins folder. By default it searches&quot;, &quot;plugins inside folder, where 'glace-core' is installed.&quot;), type: &quot;string&quot;, group: &quot;Plugins:&quot;, }, &quot;disable-default-plugins&quot;: { describe: d(&quot;Disable default plugins.&quot;), type: &quot;boolean&quot;, group: &quot;Plugins:&quot;, }, /* xunit */ &quot;xunit&quot;: { describe: d(&quot;Activate xUnit reporter.&quot;), type: &quot;boolean&quot;, group: &quot;xUnit:&quot;, }, &quot;xunit-path [path]&quot;: { describe: d(&quot;Path to xUnit report. Default is 'cwd/report/xunit.xml'.&quot;), type: &quot;string&quot;, group: &quot;xUnit:&quot;, }, &quot;xunit-suite-name [name]&quot;: { describe: d(&quot;Tests suite name in xUnit report.&quot;, &quot;By default it's the same as session name.&quot;), type: &quot;string&quot;, group: &quot;xUnit:&quot;, }, /* allure */ &quot;allure&quot;: { describe: d(&quot;Activate Allure reporter.&quot;), type: &quot;boolean&quot;, group: &quot;Allure:&quot;, }, &quot;allure-dir [path]&quot;: { describe: d(&quot;Path to allure report folder. Default is 'cwd/report/allure'.&quot;), type: &quot;string&quot;, group: &quot;Allure:&quot;, }, /* testrail */ &quot;testrail&quot;: { describe: d(&quot;Activate TestRail reporter.&quot;), type: &quot;boolean&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-host &lt;host&gt;&quot;: { describe: d(&quot;TestRail host.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-user &lt;user&gt;&quot;: { describe: d(&quot;TestRail username or email.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-token &lt;token&gt;&quot;: { describe: d(&quot;TestRail token.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-project-id &lt;id&gt;&quot;: { describe: d(&quot;TestRail project id.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-suite-id &lt;id&gt;&quot;: { describe: d(&quot;TestRail suite id.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-run-name &lt;name&gt;&quot;: { describe: d(&quot;TestRail run name.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, &quot;testrail-run-desc &lt;description&gt;&quot;: { describe: d(&quot;TestRail run description.&quot;), type: &quot;string&quot;, group: &quot;TestRail:&quot;, }, /* tools */ &quot;testrail-check&quot;: { describe: d(&quot;Check TestRail cases consistency with&quot;, &quot;implemented tests.&quot;), type: &quot;boolean&quot;, group: &quot;Tools:&quot;, }, &quot;list-steps [filter]&quot;: { describe: d(&quot;List available steps and exit.&quot;), group: &quot;Tools:&quot;, }, &quot;list-tests [filter]&quot;: { describe: d(&quot;List collected tests and exit.&quot;), group: &quot;Tools:&quot;, }, &quot;list-fixtures [filter]&quot;: { describe: d(&quot;List available fixtures and exit.&quot;), group: &quot;Tools:&quot;, }, }); for (var help of plugins.getModules(&quot;pluginHelp&quot;)) { result = help(result, d); } result = cb(result); result.epilog(&quot;Have a green test ;)&quot;.green.bold).argv; }; × Search results Close "},"allure.js.html":{"id":"allure.js.html","title":"Source: allure.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: allure.js &quot;use strict&quot;; /** * [Allure](http://allure.qatools.ru/) wrapper. * * @module */ const fs = require(&quot;fs&quot;); const Allure = require(&quot;allure-js-commons&quot;); const Step = require(&quot;allure-js-commons/beans/step&quot;); const CONF = require(&quot;./config&quot;); let allure; if (CONF.allure.use) { allure = new Allure(); allure.setOptions({ targetDir: CONF.allure.dir }); allure.PASSED = &quot;passed&quot;; allure.FAILED = &quot;failed&quot;; allure.SKIPPED = &quot;skipped&quot;; /** * Defines if allure helper has steps or no. * * @memberOf module:allure * @method * @return {boolean} `true` if it has steps, `false` otherwise. */ allure.hasSteps = function () { return this.getCurrentSuite().currentStep instanceof Step; }; /** * Defines if test is started or no. * * @memberOf module:allure * @method * @return {boolean} `true` if test is started, `false` otherwise. */ allure.isTestStarted = function () { return !!(this.getCurrentSuite() &amp;&amp; this.getCurrentTest() &amp;&amp; !this.getCurrentTest().status); }; /** * Starts step if test is started. * * @memberOf module:allure * @method * @arg {string} name - Step name. */ allure.step = function () { if (this.isTestStarted()) this.startStep.apply(this, arguments); }; /** * Ends step as passed if test is started. * * @memberOf module:allure * @method */ allure.pass = function () { if (this.isTestStarted()) this.endStep(this.PASSED); }; /** * Adds test story if test is started. * * @memberOf module:allure * @method * @arg {string} name - Story name. */ allure.story = function (name) { if (!this.isTestStarted()) return; this.getCurrentTest().addLabel(&quot;story&quot;, name); }; /** * Adds test feature if test is started. * * @memberOf module:allure * @method * @arg {string} name - Feature name. */ allure.feature = function (name) { if (!this.isTestStarted()) return; this.getCurrentTest().addLabel(&quot;feature&quot;, name); }; /** * Adds test environment value if test is started. * * @memberOf module:allure * @method * @arg {string} name - Environment name. * @arg {string} value - Environment value. */ allure.addEnvironment = function (name, value) { if (!this.isTestStarted()) return; this.getCurrentTest().addParameter(&quot;environment-variable&quot;, name, value); }; /** * Adds test description if test is started. * * @memberOf module:allure * @method * @arg {string} desc - Description. * @arg {string} type - Mime type. */ allure.addDescription = function (desc, type) { if (!this.isTestStarted()) return; this.getCurrentTest().setDescription(desc, type); }; /** * Attach content to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Content name. * @arg {string} content - Content body. * @arg {string} type - Mime type. */ allure.attach = function (name, content, type) { if (!this.isTestStarted()) return; this.addAttachment(name, Buffer.from(content), type); }; /** * Attach JSON to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - JSON name. * @arg {string} obj - Object to convert to JSON. */ allure.attachJson = function (name, obj) { if (!this.isTestStarted()) return; this.attach(name, JSON.stringify(obj, null, &quot; &quot;), &quot;application/json&quot;); }; /** * Attach image to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Image name. * @arg {string} imgPath - Image path. */ allure.attachImage = function (name, imgPath) { if (!this.isTestStarted()) return; this.attach(name, fs.readFileSync(imgPath), &quot;image/png&quot;); }; /** * Attach video to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Video name. * @arg {string} videoPath - Video path. */ allure.attachVideo = function (name, videoPath) { if (!this.isTestStarted()) return; this.attach(name, fs.readFileSync(videoPath), &quot;video/mp4&quot;); }; /** * Attach text to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - Text name. * @arg {string} txt - Text content. */ allure.attachText = function (name, txt) { this.attach(name, txt, &quot;text/plain&quot;); }; /** * Attach HTML to test if test is started. * * @memberOf module:allure * @method * @arg {string} name - HTML name. * @arg {string} html - HTML content. */ allure.attachHtml = function (name, html) { this.attach(name, html, &quot;application/html&quot;); }; } else { allure = new Proxy({}, { get: () =&gt; () =&gt; {} }); }; module.exports = allure; × Search results Close "},"classifier.js.html":{"id":"classifier.js.html","title":"Source: classifier.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: classifier.js &quot;use strict&quot;; /** * Wrapper on bayes classifier. * * @module */ var bayes = require(&quot;bayes&quot;); module.exports = () =&gt; { var classifier = bayes(); classifier.isTrained = false; classifier.train = function () { this.isTrained = true; }; classifier.getClassifications = function (text) { var tokens = this.tokenizer(text); var frequencyTable = this.frequencyTable(tokens); var result = []; for (var category in this.categories) { var item = { label: category, value: 0 }; result.push(item); for (var [token, frequency] of Object.entries(frequencyTable)) { var tokenProbability = this.tokenProbability(token, category); item.value += frequency * tokenProbability; }; }; result.sort((a, b) =&gt; b.value - a.value); return result; }; return classifier; }; × Search results Close "},"cli.js.html":{"id":"cli.js.html","title":"Source: cli.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: cli.js &quot;use strict&quot;; /** * Contains functions to execute tests via command line interface. * * @module */ var run = require(&quot;./run&quot;); /* allow plugins registration in runner before help call */ require(&quot;./help&quot;)(); /** * Runs `GlaceJS` in CLI. * * @function */ module.exports.run = () =&gt; run(process.exit); × Search results Close "},"error.js.html":{"id":"error.js.html","title":"Source: error.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: error.js &quot;use strict&quot;; /** * Contains `GlaceJS` errors. * * @module */ var util = require(&quot;util&quot;); var GlaceError = require(&quot;glace-utils&quot;).GlaceError; /** * Error which is thrown when configuration is wrong. * * @class * @arg {string} message - Error message. */ var ConfigError = module.exports.ConfigError = function (message) { GlaceError.call(this, message); }; util.inherits(ConfigError, GlaceError); /** * Error which is thrown when step execution is wrong. * * @class * @arg {string} message - Error message. */ var StepError = module.exports.StepError = function (message) { GlaceError.call(this, message); }; util.inherits(StepError, GlaceError); × Search results Close "},"hacking.js.html":{"id":"hacking.js.html","title":"Source: hacking.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: hacking.js &quot;use strict&quot;; /** * Contains hacks for test run. * * @module */ const _ = require(&quot;lodash&quot;); const LOG = require(&quot;glace-utils&quot;).logger; const Mocha = require(&quot;mocha&quot;); const Pending = require(&quot;mocha/lib/pending&quot;); const utils = require(&quot;mocha/lib/utils&quot;); utils.isString = _.isString; const CONF = require(&quot;./config&quot;); /** * Patches original `Mocha.Runner.prototype.uncaught` in order to skip * exceptions from proxy server `res.send()`. * * @function */ module.exports.suppressMochaUncaught = () =&gt; { Mocha.Runner.prototype.uncaught = function (err) { LOG.error(&quot;UNCAUGHT EXCEPTION&quot;, err); if (CONF.session.uncaughtException === &quot;fail&quot;) { if (CONF.test.curCase) { var errMsg = &quot;Uncaught exception&quot;; if (err.message) { errMsg += &quot;\\nmessage: &quot; + err.message; } if (err.stack) { errMsg += &quot;\\nstack: &quot; + err.stack; } if (err.seleniumStack) { errMsg += &quot;\\nselenium: &quot; + JSON.stringify(err.seleniumStack, null, &quot;\\t&quot;); } CONF.test.curCase.addError(errMsg); } } return; }; }; /** * Mocha runner. * * @type {Runner} */ var _mochaRunner; (grep =&gt; { Mocha.Runner.prototype.grep = function() { _mochaRunner = this; return grep.apply(this, arguments); }; })(Mocha.Runner.prototype.grep); /** * Gets mocha runner. * * @function */ module.exports.getRunner = () =&gt; _mochaRunner; /** * Patches mocha runner to allow multiple independent `after`-calls. */ Mocha.Runner.prototype.hook = function (name, fn) { var suite = this.suite; var hooks = suite[&quot;_&quot; + name]; var self = this; function next (i) { var hook = hooks[i]; if (!hook) { return fn(); } self.currentRunnable = hook; hook.ctx.currentTest = self.test; self.emit(&quot;hook&quot;, hook); if (!hook.listeners(&quot;error&quot;).length) { hook.on(&quot;error&quot;, function (err) { self.failHook(hook, err); }); } hook.run(function (err) { var testError = hook.error(); if (testError) { self.fail(self.test, testError); } if (err) { if (err instanceof Pending) { if (name === &quot;beforeEach&quot; || name === &quot;afterEach&quot;) { self.test.pending = true; } else { suite.tests.forEach(function (test) { test.pending = true; }); // a pending hook won't be executed twice. hook.pending = true; } } else { self.failHook(hook, err); // stop executing hooks, notify callee of hook err if (!name.startsWith(&quot;after&quot;)) return fn(err); } } self.emit(&quot;hook end&quot;, hook); delete hook.ctx.currentTest; next(++i); }); } Mocha.Runner.immediately(function () { next(0); }); }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: index.js &quot;use strict&quot;; /** * `GlaceJS` main module. * * @module * * @prop {object} config - {@link module:config|Config} module. * @prop {object} error - {@link module:error|Error} module. * @prop {function} help - {@link module:help|Help} module. * @prop {object} reporter - {@link module:reporter/index|Reporter} module. * @prop {object} run - {@link module:run|run} module. * @prop {object} Steps - {@link module:steps|Steps} module. */ var allure, config, error, help, plugins, reporter, run, Steps; Object.defineProperties(exports, { allure: { get: function () { allure = allure || require(&quot;./allure&quot;); return allure; }, }, /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, error: { get: function() { error = error || require(&quot;./error&quot;); return error; }, }, /** * Help. */ help: { get: function () { help = help || require(&quot;./help&quot;); return help; }, }, plugins: { get: function () { plugins = plugins || require(&quot;./plugins&quot;); return plugins; }, }, /** * @type {GlaceReporter} */ reporter: { get: function() { reporter = reporter || require(&quot;./reporter&quot;); return reporter; }, }, /** * @type {run} */ run: { get: function() { run = run || require(&quot;./run&quot;); return run; }, }, /** * @type {Steps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); × Search results Close "},"loader.js.html":{"id":"loader.js.html","title":"Source: loader.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: loader.js /* global before session */ &quot;use strict&quot;; /** * Makes tests root session. * * - runner loads root `conftest.js` if it is located on one level with * each of `CONF.test.dirs`; * - if each of `CONF.test.dirs` is file with tests, runner loads and executes it; * - if each of `CONF.test.dirs` is folder runner loads files inside recursive if * file name starts with `test` and ends with `.js`; * - inside each subfolder of each of `CONF.test.dirs` runner loads `conftest.js` * file if it is present; * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const U = require(&quot;glace-utils&quot;); require(&quot;./globals&quot;); const CONF = require(&quot;./config&quot;); const ConfigError = require(&quot;./error&quot;).ConfigError; /** * Loads special `preloads` files before main conftests and test files. * * Preloads are specified in `CONF.preloads` array. It may be managed only * programmatically and needs as extension point to load some custom files * before tests. * * After preloads it loads root (the mainest) conftest file, which may be set * via CLI. */ const preloads = () =&gt; { const pre = _.clone(CONF.session.preloads); if (CONF.session.rootConftest &amp;&amp; !pre.includes(CONF.session.rootConftest)) { pre.push(CONF.session.rootConftest); } for (const preload of pre) { expect( fs.existsSync(preload) &amp;&amp; fs.statSync(preload).isFile(), `Preloader '${preload}' isn't a file or doesn't exist` ).to.be.true; require(preload); } }; /** * Main conftests are loaded before tests session creation and may used for * objects management, for example to created custom instance of global `SS`. * * Main conftest is `conftest.js` file which is located on one hierarchy level * with each specified tests folder or file. */ const mainConftests = () =&gt; { for (const testDir of CONF.test.dirs) { if (!fs.existsSync(testDir)) { throw new ConfigError( `Tests file or folder '${testDir}' doesn't exist`); } const siblingConftest = path.resolve(path.dirname(testDir), &quot;conftest.js&quot;); if (fs.existsSync(siblingConftest)) { require(siblingConftest); } } }; /** * Callback to create tests session. * * It kills some processes before all if they are specified. */ const sessFunc = () =&gt; { if (CONF.session.killProcs) { before(async () =&gt; { for (const procName of CONF.session.killProcs) { await U.killProcs(procName); } }); } for (const testDir of CONF.test.dirs) { if (!fs.statSync(testDir).isDirectory()) { require(testDir); continue; } loadTests(testDir); } }; /** * Loads test files recursively. Test file name should start with `test` and * end with `.js`. * * @function * @arg {string} dir - Folder with test files. */ const loadTests = dir =&gt; { for (const fileName of fs.readdirSync(dir)) { const filePath = path.resolve(dir, fileName); const fileStat = fs.statSync(filePath); if (fileStat.isDirectory()) { loadTests(filePath); } if (fileStat.isFile()) { if (fileName === &quot;conftest.js&quot;) require(filePath); if (fileName.startsWith(&quot;test&quot;) &amp;&amp; fileName.endsWith(&quot;.js&quot;)) { require(filePath); } } } }; if (!CONF.__testmode) { /* Starts session */ preloads(); mainConftests(); session(sessFunc); } × Search results Close "},"matcher.js.html":{"id":"matcher.js.html","title":"Source: matcher.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: matcher.js &quot;use strict&quot;; /** * Matchers. * * @module */ var _ = require(&quot;lodash&quot;); var Assertion = require(&quot;chai&quot;).Assertion; var U = require(&quot;glace-utils&quot;); /** * Checks expectation corresponds to condition. * * @method * @arg {string} cond - conditions for assertion. * @arg {string} [msg] - message to throw in case of wrong conditions. * @example await SS.checkBalance({ &quot;to be not equal&quot;: 100 }) Steps.prototype.checkBalance = async function (condition) { var currBalance = await this.getBalance(); expect(currBalance).correspond(condition, &quot;Invalid user balance&quot;); }; */ Assertion.prototype.correspond = function (cond, msg) { var matchers, expVal; if (msg) this.__flags.message = msg; if (typeof(cond) === &quot;object&quot;) { if (Object.keys(cond).length !== 1) { throw new Error(&quot;Condition should contain only one key-value pair&quot;); } matchers = Object.keys(cond)[0]; expVal = Object.values(cond)[0]; } else if (typeof(cond) === &quot;string&quot;) { matchers = cond; } else { throw new Error(&quot;Condition should be string or object only&quot;); } matchers = _.filter(_.split(matchers, &quot; &quot;)); var predicate = this; for (var matcher of matchers) { predicate = predicate[matcher]; if (!predicate) throw new TypeError(`Undefined matcher '${matcher}'`); } if (expVal) predicate.call(this, expVal); return this; }; /** * Checks expectation corresponds to condition during timeout. * * @arg {string|object} cond - Condition for assertion. * @arg {number} [timeout=1] - Timeout to wait for matching. * @arg {string} [msg] - Error message. * @throws {Error} If condition wasn't matched during timeout. */ Assertion.prototype.waitFor = async function (cond, timeout, msg) { var err = null; var predicate = async () =&gt; { try { return await new Assertion( await this.__flags.object(), this.__flags.message).correspond(cond, msg); } catch (e) { err = e; return false; } }; var result = await U.waitFor(predicate, { timeout: timeout }); if (result) return this; if (err) { throw err; } else { throw new Error(&quot;Unexpected matcher error&quot;); } }; × Search results Close "},"plugins.js.html":{"id":"plugins.js.html","title":"Source: plugins.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: plugins.js &quot;use strict&quot;; /** * Plugins. * * @module */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var expect = require(&quot;chai&quot;).expect; var U = require(&quot;glace-utils&quot;); const CONF = U.config; // HACK to avoid cross-import between config.js and plugins.js var LOG = U.logger; var systemPlugins = null; // plugins cache var customPlugins = []; /** * Gets modules from plugins. * * @arg {string} moduleName - Name of module to request from plugins. * @return {object[]} - List of modules requested from plugins. */ module.exports.getModules = moduleName =&gt; { var modules = []; for (var plugin of Object.values(getPlugins())) { var mod = plugin.module[moduleName]; if (mod) modules.push(mod); } return modules; }; var getPlugins = module.exports.get = () =&gt; { if (!systemPlugins) { var fileName; systemPlugins = []; var systemNames = []; if (CONF.plugins.dir) { expect(fs.existsSync(CONF.plugins.dir), `Plugins folder '${CONF.plugins.dir}' doesn't exist`) .to.be.true; for (fileName of fs.readdirSync(CONF.plugins.dir).reverse()) { if (!systemNames.includes(fileName)) { systemNames.push(fileName); systemPlugins.push({ name: fileName, path: path.resolve(CONF.plugins.dir, fileName), }); } } } if (!CONF.plugins.disableDefault) { var skipped = [ &quot;glace-js&quot;, &quot;glace-core&quot;, &quot;glace-utils&quot; ]; for (var pluginDir of _getPluginDirs()) { if (!fs.existsSync(pluginDir)) continue; for (fileName of fs.readdirSync(pluginDir).reverse()) { if (fileName.startsWith(&quot;glace-&quot;) &amp;&amp; !skipped.includes(fileName) &amp;&amp; !systemNames.includes(fileName)) { systemNames.push(fileName); systemPlugins.push({ name: fileName, path: path.resolve(pluginDir, fileName), }); } } } } systemPlugins.reverse(); for (var plugin of _.clone(systemPlugins)) { try { plugin.module = require(plugin.path); } catch (e) { LOG.warn(`Can't load plugin '${plugin.path}'`); systemPlugins.splice(systemPlugins.indexOf(plugin), 1); } } } var customNames = Object.values(customPlugins).map(p =&gt; p.name); return systemPlugins .filter(p =&gt; !customNames.includes(p.name)) .concat(customPlugins); }; /** * Clear plugins cache. * * @function */ module.exports.clearCache = () =&gt; systemPlugins = null; /** * Registers custom plugin. * * @function * @arg {string} name - Name of plugin module. */ module.exports.register = name =&gt; { var customNames = Object.values(customPlugins).map(p =&gt; p.name); if (customNames.includes(name)) { LOG.warn(`Plugin '${name}' is registered already`); return; } customPlugins.push({ name: name, path: require.resolve(name), module: require(name), }); }; /** * Gets names of registered custom plugins. * * @function * @return {array&lt;string&gt;} Plugin names. */ module.exports.getRegistered = () =&gt; { return customPlugins.map(p =&gt; p.name); }; /** * Gets plugin dirs. * * @ignore * @function * @return {string[]} - List of paths. */ var _getPluginDirs = () =&gt; { var pluginDirs = _.clone(module.paths); if (require.main) { var mainDir = path.dirname(require.main.filename); if (!pluginDirs.includes(mainDir)) { pluginDirs.unshift(mainDir); } } if (!pluginDirs.includes(U.cwd)) { pluginDirs.unshift(U.cwd); } return pluginDirs; }; × Search results Close "},"reporter_allure.js.html":{"id":"reporter_allure.js.html","title":"Source: reporter/allure.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/allure.js &quot;use strict&quot;; /** * Allure reporter. * * @module */ require(&quot;colors&quot;); const allure = require(&quot;../allure&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; module.exports = { start: () =&gt; { allure.startSuite(CONF.allure.suiteName); }, end: () =&gt; { const skipped = CONF.test.cases.filter(t =&gt; t.status === TestCase.SKIPPED); for (const skip of skipped) { allure.startCase(skip.name); if (skip.rawInfo[0]) { allure.endCase(allure.SKIPPED, { message: skip.rawInfo[0] }); } else { allure.endCase(allure.SKIPPED); } } allure.endSuite(); console.log(); const reportMsg = &quot;Allure report is &quot; + CONF.allure.dir; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, suite: suite =&gt; { allure.startSuite(suite.title); }, suiteEnd: () =&gt; { allure.endSuite(); }, scope: scope =&gt; { if (!allure.isTestStarted()) return; allure.startStep(scope.title); allure.getCurrentSuite().currentStep.isScope = true; // small hack }, scopeEnd: () =&gt; { if (allure.isTestStarted()) allure.endStep(); }, test: test =&gt; { allure.startCase(test.title); }, testEnd: test =&gt; { const testCase = CONF.test.cases.filter(t =&gt; t.name == test.title)[0]; if (testCase.status === TestCase.PASSED) { allure.endCase(allure.PASSED); } if (testCase.status === TestCase.FAILED) { allure.endCase(allure.FAILED, getErrors(testCase)); } }, chunk: chunk =&gt; { allure.startStep(chunk.title); }, skip: () =&gt; { while (allureNotScope()) allure.endStep(allure.SKIPPED); }, pass: () =&gt; { while (allureNotScope()) allure.endStep(allure.PASSED); }, fail: () =&gt; { while (allureNotScope()) allure.endStep(allure.FAILED); }, }; const allureNotScope = () =&gt; allure.hasSteps() &amp;&amp; !allure.getCurrentSuite().currentStep.isScope; const getErrors = testCase =&gt; { const result = {}; const errMsgs = getErrMsgs(testCase.errors); if (errMsgs.length === 0) { result.message = &quot;Show details ➤&quot;; } else if (errMsgs.length === 1) { result.message = errMsgs[0]; } else { let n = 0; result.message = errMsgs.map(i =&gt; `${++n}. ${i}`).join(&quot;\\r&quot;); } result.stack = testCase.errors.map(e =&gt; e.split(&quot;\\n&quot;).join(&quot;\\r&quot;)).join(&quot;\\n\\r&quot;); return result; }; const getErrMsgs = errs =&gt; { const result = []; for (const err of errs) { for (const line of err.split(&quot;\\n&quot;)) { if (line.startsWith(&quot;message: &quot;)) { result.push(line.substr(9)); break; }; } } return result; }; × Search results Close "},"reporter_index.js.html":{"id":"reporter_index.js.html","title":"Source: reporter/index.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/index.js &quot;use strict&quot;; /** * GlaceJS reporter package. * * @module */ const CONF = require(&quot;../config&quot;); const plugins = require(&quot;../plugins&quot;); const base = require(&quot;./base&quot;); const main = () =&gt; { base.register(require(&quot;./stdout&quot;)); if (CONF.testrail.use) base.register(require(&quot;./testrail&quot;)); if (CONF.xunit.use) base.register(require(&quot;./xunit&quot;)); if (CONF.allure.use) base.register(require(&quot;./allure&quot;)); for (const reporter of plugins.getModules(&quot;reporter&quot;)) { base.register(reporter); } return base; }; module.exports = CONF.__testmode ? main : main(); × Search results Close "},"reporter_stdout.js.html":{"id":"reporter_stdout.js.html","title":"Source: reporter/stdout.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/stdout.js &quot;use strict&quot;; /** * `GlaceJS` stdout reporter. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const colors = require(&quot;colors&quot;); const fse = require(&quot;fs-extra&quot;); const LOG = require(&quot;glace-utils&quot;).logger; const MochaReporter = require(&quot;mocha&quot;).reporters.base; const prettyms = require(&quot;pretty-ms&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; const sessionErrors = []; let indents = 0; const indent = () =&gt; Array(indents).join(&quot; &quot;); fse.mkdirsSync(CONF.report.logsDir); const report = fs.createWriteStream( path.resolve(CONF.report.logsDir, &quot;stdout.log&quot;), { flags : &quot;w&quot; }); const stdout = function() { report.write(colors.strip(util.format.apply(util, arguments)) + &quot;\\n&quot;); console.log.apply(console, arguments); }; const epilogue = () =&gt; { let msg; const indent = &quot; &quot;, passedTests = [], failedTests = [], skippedTests = []; for (const testCase of CONF.test.cases) { if (testCase.status === TestCase.FAILED) { failedTests.push(testCase); } if (testCase.status === TestCase.PASSED) { passedTests.push(testCase); } if (testCase.status === TestCase.SKIPPED) { skippedTests.push(testCase); } } if (passedTests.length !== 0) { msg = &quot;passed test&quot; + (passedTests.length === 1 ? &quot;&quot; : &quot;s&quot;); stdout((indent + MochaReporter.symbols.ok + &quot; &quot; + String(passedTests.length).bold + &quot; &quot; + msg).green); } if (failedTests.length !== 0) { msg = &quot;failed test&quot; + (failedTests.length === 1 ? &quot;&quot; : &quot;s&quot;); stdout((indent + MochaReporter.symbols.err + &quot; &quot; + String(failedTests.length).bold + &quot; &quot; + msg).red); } const execChunks = CONF.test.cases.reduce((a, b) =&gt; a + b.chunks.length, 0); if (execChunks !== 0) { msg = &quot;executed chunk&quot; + (execChunks === 1 ? &quot;&quot; : &quot;s&quot;); stdout((indent + execChunks + &quot; &quot; + msg).white); } let execTime = CONF.test.cases .map(t =&gt; t.duration) .reduce((a, b) =&gt; a + b, 0); if (execTime &gt; 0) { execTime = (execTime &lt; 60000 ? `${execTime / 1000} sec` : prettyms(execTime)).white.bold; stdout(); stdout(indent + &quot;Summary tests time is&quot;.white, execTime); } if (skippedTests.length !== 0) { msg = &quot;skipped test&quot; + (skippedTests.length === 1 ? &quot;&quot; : &quot;s&quot;); stdout(); // HACK https://github.com/glacejs/glace-core/issues/136 stdout(indent + &quot;# &quot;.gray + String(skippedTests.length).gray.bold + &quot; &quot; + msg.gray); for (const skip of skippedTests) { msg = `* '${skip.name}'`; if (skip.rawInfo[0]) { msg += &quot; - &quot; + skip.rawInfo[0].bold; } stdout(indent + indent + msg.gray); } } if (fs.existsSync(CONF.report.failedTestsPath)) { try { fs.unlinkSync(CONF.report.failedTestsPath); } catch (e) { LOG.error(`Can't remove file '${CONF.report.failedTestsPath}'`, e); } }; if (failedTests.length) { const failedTestsJson = []; stdout(); stdout(&quot;TEST FAILURES:&quot;.bold); for (const testCase of failedTests) { stdout(); stdout((&quot;test: &quot; + testCase.name).cyan.bold); for(const err of testCase.errors) { stdout(); stdout(err.red.bold); } const data = { name: testCase.name }; if (!_.isEmpty(testCase.passedChunkIds)) { data.passed_chunk_ids = testCase.passedChunkIds; } failedTestsJson.push(data); } try { fs.writeFileSync( CONF.report.failedTestsPath, JSON.stringify(failedTestsJson, null, &quot; &quot;)); } catch (e) { LOG.error(`Can't write file '${CONF.report.failedTestsPath}'`, e); } } if (sessionErrors.length) { stdout(); stdout(&quot;OUTTEST FAILURES:&quot;.bold); for (const error of sessionErrors) { stdout(); stdout(error.red.bold); } } }; module.exports = { /** * Called before tests end. * * @method * @instance */ end: () =&gt; { epilogue(); stdout(); const reportMsg = &quot;Local report is &quot; + CONF.report.dir; stdout(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); stdout(reportMsg.yellow); }, /** * Called on scope start. * * @method * @instance * @arg {object} scope - `MochaJS` suite. */ scope: scope =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;scope: &quot; + scope.title).cyan); } }, /** * Called before scope end. * * @method * @instance */ scopeEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on suite start. * * @method * @instance * @arg {object} suite - `MochaJS` suite. */ suite: suite =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;suite: &quot; + suite.title).cyan); } }, /** * Called before suite end. * * @method * @instance */ suiteEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on test start. * * @method * @instance * @arg {object} test - `MochaJS` suite. */ test: test =&gt; { ++indents; if (indents) { stdout(); stdout((indent() + &quot;test: &quot; + test.title).cyan.bold); } }, /** * Called on test end. * * @method * @instance */ testEnd: () =&gt; { --indents; if (!indents) stdout(); }, /** * Called on chunk passed. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ pass: chunk =&gt; { let msg = indent() + &quot; &quot; + MochaReporter.symbols.ok + &quot; chunk&quot;; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.green); }, /** * Called on chunk skipped. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ skip: chunk =&gt; { let msg = indent() + &quot; # chunk&quot;; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.gray); }, /** * Called on chunk or hook failed. * * @method * @instance * @arg {object} chunk - `MochaJS` test. */ fail: (chunk, err) =&gt; { let errMsg; if (!CONF.test.curCase) { errMsg = chunk.title; if (err.message) { errMsg += &quot;\\nmessage: &quot; + err.message; } if (err.stack) { errMsg += &quot;\\nstack: &quot; + err.stack; } if (err.seleniumStack) { errMsg += &quot;\\nselenium: &quot; + JSON.stringify(err.seleniumStack, null, &quot;\\t&quot;); } sessionErrors.push(errMsg); } else { errMsg = _.last(CONF.test.curCase.errors); }; let msg = indent() + &quot; &quot; + MochaReporter.symbols.err + &quot; chunk&quot;; if (chunk.title) msg += &quot;: &quot; + chunk.title; stdout(msg.red); if (CONF.report.errorsNow) { stdout(errMsg.red.bold); } }, /** * Called on report finalizing. * * @method * @instance */ done: () =&gt; new Promise(resolve =&gt; report.end(resolve)), }; × Search results Close "},"reporter_testrail.js.html":{"id":"reporter_testrail.js.html","title":"Source: reporter/testrail.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/testrail.js &quot;use strict&quot;; /** * TestRail reporter. * * @module */ const expect = require(&quot;chai&quot;).expect; const Testrail = require(&quot;testrail-api&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; for (const opt in CONF.testrail) { expect(CONF.testrail[opt], `TestRail option '${opt}' isn't specified in config`) .to.exist; } const testrail = new Testrail({ host: CONF.testrail.host, user: CONF.testrail.user, password: CONF.testrail.token }); let testrailFailed = false; const Results = { PASSED: 1, BLOCKED: 2, UNTESTED: 3, RETEST: 4, FAILED: 5 }; const cases = {}; let report = Promise.resolve(); module.exports = { /** * Called on tests start. * * @method * @instance */ start: () =&gt; { report = report.then(() =&gt; { return new Promise((resolve, reject) =&gt; { testrail.getCases( CONF.testrail.projectId, { suite_id: CONF.testrail.suiteId }, (err, response, _cases) =&gt; { if (err) return reject(err); for (const _case of _cases) { if (cases[_case.title]) { return reject(new Error( &quot;Detect duplicated cases with name &quot; + `'${_case.title}'. Only unique names ` + &quot;should be.&quot;)); } cases[_case.title] = { id: _case.id }; } resolve(); }); }); }).then(() =&gt; { return new Promise((resolve, reject) =&gt; { testrail.addRun( CONF.testrail.projectId, { suite_id: CONF.testrail.suiteId, name: CONF.testrail.runName, description: CONF.testrail.runDescription }, (err, response, run) =&gt; { if (err) return reject(err); CONF.testrail.runId = run.id; resolve(); }); }); }) .catch(e =&gt; { testrailFailed = true; console.log(&quot;Error to init TestRail report:&quot;, e); }); }, /** * Called before tests end. * * @method * @instance */ end: () =&gt; { if (testrailFailed) return; console.log(); const reportMsg = &quot;TestRail report is &quot; + CONF.testrail.host + &quot;/index.php?/runs/view/&quot; + CONF.testrail.runId; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, /** * Called on test end. * * @method * @instance * @arg {object} test - `MochaJS` suite. */ testEnd: test =&gt; { if (testrailFailed) return; const testCase = CONF.test.cases.filter(t =&gt; t.name == test.title)[0]; const testrailCase = cases[test.title]; if (!testrailCase) return; const testResult = { status_id: Results.PASSED, comment: &quot;&quot; }; if (testCase.screenshots.length) { testResult.comment += &quot;Screenshots:&quot;; for (const screen of testCase.screenshots) { testResult.comment += &quot;\\n&quot; + screen; } } if (testCase.videos.length) { testResult.comment += &quot;\\n\\nVideos:&quot;; for (const video of testCase.videos) { testResult.comment += &quot;\\n&quot; + video; } } if (testCase.rawInfo.length) { testResult.comment += &quot;\\n\\nExtra details:&quot;; for (const info of testCase.rawInfo) { testResult.comment += &quot;\\n&quot; + info; } } if (testCase.status === TestCase.SKIPPED) { testResult.status_id = Results.BLOCKED; } if (testCase.status === TestCase.FAILED) { testResult.status_id = Results.FAILED; testResult.comment += &quot;\\n\\nErrors:&quot;; for (const error of testCase.errors) { testResult.comment += &quot;\\n&quot; + error; } } report = report.then(() =&gt; { return new Promise((resolve, reject) =&gt; { testrail.addResultForCase( CONF.testrail.runId, testrailCase.id, testResult, (err, res) =&gt; { if (err) return reject(err); resolve(res); }); }); }).catch(e =&gt; { console.log( `Error to publish test '${test.title}' report to TestRail:`, e); }); }, /** * Called on report finalizing. * * @method * @instance */ done: () =&gt; report, }; × Search results Close "},"reporter_xunit.js.html":{"id":"reporter_xunit.js.html","title":"Source: reporter/xunit.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: reporter/xunit.js &quot;use strict&quot;; /** * `GlaceJS` xunit reporter. * * @module */ const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); require(&quot;colors&quot;); const escape = require(&quot;mocha&quot;).utils.escape; const fse = require(&quot;fs-extra&quot;); const CONF = require(&quot;../config&quot;); const TestCase = require(&quot;../testing&quot;).TestCase; let stream; module.exports = { start: () =&gt; { if (fs.existsSync(CONF.xunit.path)) { fs.unlinkSync(CONF.xunit.path); } }, end: () =&gt; { fse.mkdirsSync(path.dirname(CONF.xunit.path)); stream = fs.createWriteStream(CONF.xunit.path); write(tag(&quot;testsuite&quot;, { name: CONF.xunit.suiteName, tests: CONF.test.cases.length, failures: CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED).length, errors: CONF.test.cases.filter(t =&gt; t.status === TestCase.FAILED).length, skipped: CONF.test.cases.filter(t =&gt; t.status === TestCase.SKIPPED).length, timestamp: new Date().toUTCString(), time: (CONF.test.cases.map(t =&gt; t.duration).reduce((a, b) =&gt; a + b, 0) / 1000) || 0 }, false)); CONF.test.cases.forEach(t =&gt; writeTest(t)); write(&quot;&lt;/testsuite&gt;&quot;); console.log(); const reportMsg = &quot;xUnit report is &quot; + CONF.xunit.path; console.log(Array(reportMsg.length + 1).join(&quot;-&quot;).yellow); console.log(reportMsg.yellow); }, done: () =&gt; new Promise(resolve =&gt; stream.end(resolve)), }; /** * Writes a line. * * @arg {string} line - Report text line. */ const write = line =&gt; { stream.write(line + &quot;\\n&quot;); }; /** * Writes a test. * * @arg {TestCase} test - Test case. */ const writeTest = test =&gt; { const attrs = { classname: test.name, name: test.name, time: (test.duration / 1000) || 0 }; if (test.status === TestCase.FAILED) { const err = test.errors.join(&quot;\\n&quot;); write(tag(&quot;testcase&quot;, attrs, false, tag(&quot;failure&quot;, {}, false, escape(err)))); } else if (test.status === TestCase.SKIPPED) { write(tag(&quot;testcase&quot;, attrs, false, tag(&quot;skipped&quot;, {}, true))); } else { write(tag(&quot;testcase&quot;, attrs, true)); } }; /** * HTML tag helper. (copied from mochajs) * * @ignore * @param name * @param attrs * @param close * @param content * @return {string} */ function tag (name, attrs, close, content) { const end = close ? &quot;/&gt;&quot; : &quot;&gt;&quot;; const pairs = []; let tag; for (const key in attrs) { if (Object.prototype.hasOwnProperty.call(attrs, key)) { pairs.push(key + &quot;=\\&quot;&quot; + escape(attrs[key]) + &quot;\\&quot;&quot;); } } tag = &quot;&lt;&quot; + name + (pairs.length ? &quot; &quot; + pairs.join(&quot; &quot;) : &quot;&quot;) + end; if (content) { tag += content + &quot;&lt;/&quot; + name + end; } return tag; } × Search results Close "},"testing.js.html":{"id":"testing.js.html","title":"Source: testing.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: testing.js &quot;use strict&quot;; /** * Contains classes and functions to save executed tests data. * * @module */ var expect = require(&quot;chai&quot;).expect; /** * Test case data structure. * * Contains full information and history about test case. * * @class * @arg {string} name - Test name. * @prop {string} name - Test name. * @prop {string} [status=NOT_STARTED] - Test status. * @prop {?string} [skipChunk=null] - Name of currently skipped chunk. * @prop {string[]} [screenshots=[]] - List of test screenshot paths. * @prop {string[]} [videos=[]] - List of test video paths. * @prop {string[]} [errors=[]] - List of test errors. * @prop {string[]} [rawInfo=[]] - List of additional test details. * @prop {object} [testParams={}] - Dict of test parameters. */ var TestCase = module.exports.TestCase = function (name, id) { this.duration = 0; this.name = name; this.id = id; this.status = TestCase.NOT_STARTED; this.skipChunk = null; this.chunks = []; this.passedChunkIds = []; this.reset(); }; /** * Starts test case. * * @method */ TestCase.prototype.start = function () { expect(this.status, `test case '${this.name}' is started already`) .to.not.be.equal(TestCase.IN_PROGRESS); this._startTime = new Date(); this.status = TestCase.IN_PROGRESS; }; /** * Ends test case. * * @method * @arg {string} status - Test case status. */ TestCase.prototype.end = function (status) { expect(this.status, `test case '${this.name}' isn't started yet`) .to.be.equal(TestCase.IN_PROGRESS); this.duration += new Date() - this._startTime; this.status = status; }; /** * Resets test case info. * * @method */ TestCase.prototype.reset = function () { this.screenshots = []; this.videos = []; this.errors = []; this.rawInfo = []; this.testParams = {}; }; /** * Adds passed chunk id. * * @method * @arg {string} chunkId - Chunk id. */ TestCase.prototype.addPassedChunkId = function (chunkId) { if (!chunkId || this.passedChunkIds.includes(chunkId)) return; this.passedChunkIds.push(chunkId); }; /** * Adds passed chunk ids. * * @method * @arg {array&lt;string&gt;} chunkIds - Chunk ids. */ TestCase.prototype.addPassedChunkIds = function (chunkIds) { for (const chunkId of chunkIds) this.addPassedChunkId(chunkId); }; /** * Adds error to test case. * * @method * @arg {Error} err - Test error. */ TestCase.prototype.addError = function (err) { this.errors.push(err); }; /** * Adds screenshot. * * @method * @arg {string} imagePath - Path to saved screenshot. */ TestCase.prototype.addScreenshot = function (imagePath) { this.screenshots.push(imagePath); }; /** * Adds video. * * @method * @arg {string} videoPath - Path to saved video. */ TestCase.prototype.addVideo = function (videoPath) { this.videos.push(videoPath); }; /** * Adds additional information. * * @method * @arg {string} info - Additional information. */ TestCase.prototype.addDetails = function (info) { this.rawInfo.push(info); }; /** * Adds chunk. * * @method * @arg {string} chunkName - Name of chunk. */ TestCase.prototype.addChunk = function (chunkName) { this.chunks.push(chunkName); }; TestCase.NOT_STARTED = &quot;not started&quot;; TestCase.IN_PROGRESS = &quot;in progress&quot;; TestCase.FAILED = &quot;failed&quot;; TestCase.PASSED = &quot;passed&quot;; TestCase.SKIPPED = &quot;skipped&quot;; /** * Class defining mochajs scope name and type. */ class ScopeType extends String { /** * Set mochajs scope type. * @arg {string} type - Supported values are `scope`, `suite`, `test`. */ setType (type) { this.type = type; return this; } }; module.exports.ScopeType = ScopeType; × Search results Close "},"tools.js.html":{"id":"tools.js.html","title":"Source: tools.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: tools.js &quot;use strict&quot;; /** * Glace tools. * * @module */ const util = require(&quot;util&quot;); require(&quot;colors&quot;); const _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; const highlight = require(&quot;cli-highlight&quot;).highlight; const Testrail = require(&quot;testrail-api&quot;); const U = require(&quot;glace-utils&quot;); const classifier = require(&quot;./classifier&quot;)(); const plugins = require(&quot;./plugins&quot;); const d = U.switchColor(); const self = module.exports; const all_steps = []; all_steps.isFilled = false; self.listSteps = (filter, namesOnly) =&gt; { namesOnly = namesOnly || false; global.$ || global.$$ || global.SS || load(); let steps = []; for (const key in $) { steps.push(key); }; steps = _.union( steps, Object.getOwnPropertyNames($), Object.getOwnPropertyNames(Object.getPrototypeOf($)) ).sort() .filter(i =&gt; !i.startsWith(&quot;_&quot;)) .filter(i =&gt; /^\\w+$/.test(i)) .filter(i =&gt; /^\\D/.test(i)); let filtered_steps = []; for (const s of steps) { if (all_steps.isFilled &amp;&amp; !filter) break; const func = $[s]; if (!util.isFunction(func)) continue; const doc = getDoc(func); const tmp = { name: s, description: ` ${func_desc(func)}`, doc: doc, }; if (!all_steps.isFilled) all_steps.push(tmp); if (doc &amp;&amp; !classifier.isTrained) { classifier.learn(doc, s); } if (namesOnly) { if (!U.textContains(s, filter)) continue; } else { if (!(U.textContains(s, filter) || U.textContains(doc, filter))) continue; } filtered_steps.push(tmp); }; all_steps.isFilled = true; if (!classifier.isTrained) { classifier.train(); } if (filter &amp;&amp; !namesOnly) { filtered_steps = getRelevant( all_steps, filtered_steps, classifier.getClassifications(filter)); } let i = 0; for (const s of (filter ? filtered_steps : all_steps)) { console.log(d(`${++i}. ${s.name}:`)); console.log(d(s.description)); if (s.doc) console.log(highlight(s.doc, { language: &quot;js&quot; })); } if (i === 0) { console.log(&quot;No steps are found&quot;.yellow); }; }; /** * Print list of implemented test cases. * * &lt;img src=&quot;./list_tests.gif&quot; title=&quot;listTests example&quot; /&gt; * * @memberOf module:tools * @name listTests * @function * @arg {string} filter - String chunk to filter test cases. */ self.listTests = filter =&gt; { load(); const conf = require(&quot;./config&quot;); let i = 0; for (const testCase of conf.test.cases) { if (!U.textContains(testCase.name, filter)) continue; console.log(d(`${++i}. ${testCase.name}`)); }; if (i === 0) { console.log(&quot;No tests are found&quot;.yellow); }; }; /** * Print list of available plugins. * * &lt;img src=&quot;./list_plugins.gif&quot; title=&quot;listPlugins example&quot; /&gt; * * @memberOf module:tools * @name listPlugins * @function */ self.listPlugins = () =&gt; { const pluginsList = plugins.get(); if (_.isEmpty(pluginsList)) { console.log(&quot;No plugins are detected&quot;.yellow); } else { for (const plugin of pluginsList) { console.log(plugin.name.yellow, plugin.path.white); } } }; self.checkTestrail = cb =&gt; { let noErrors = true; const conf = require(&quot;./config&quot;); for (const opt in conf.testrail) { expect(conf.testrail[opt], `TestRail option '${opt}' isn't specified in config`) .to.exist; } load(); console.log(&quot;TestRail connecting...&quot;.yellow); const testrail = new Testrail({ host: conf.testrail.host, user: conf.testrail.user, password: conf.testrail.token }); testrail.getCases( conf.testrail.projectId, { suite_id: conf.testrail.suiteId }, (err, response, cases) =&gt; { if (err) { console.log(err); cb(1); return; } let t; let testrailNames = [], testrailDups = []; cases.forEach(t =&gt; { if (testrailNames.includes(t.title)) { testrailDups.push(t.title); } else { testrailNames.push(t.title); } }); testrailDups = _.uniq(testrailDups); if (testrailDups.length) { noErrors = false; console.log(&quot;\\nTestRail duplicated cases:&quot;.magenta.bold); for (t of testrailDups) { console.log(` - ${t}`.cyan.bold); } } const testNames = conf.test.cases.map(t =&gt; t.name); const absentTests = _.difference(testrailNames, testNames); const absentCases = _.difference(testNames, testrailNames); if (absentTests.length) { noErrors = false; console.log(&quot;\\nNot implemented TestRail cases:&quot;.magenta.bold); for (t of absentTests) { console.log(` - ${t}`.cyan.bold); } } if (absentCases.length) { noErrors = false; console.log(&quot;\\nAbsent TestRail cases:&quot;.magenta.bold); for (t of absentCases) { console.log(` - ${t}`.cyan.bold); } } if (noErrors) { console.log(&quot;TestRail cases correspond current tests&quot;.green.bold); } console.log( &quot;\\nTestRail suite is&quot;, `${conf.testrail.host}/index.php?/suites/view/${conf.testrail.suiteId}`.yellow); cb(noErrors ? 0 : 1); }); }; self.listFixtures = (filter, namesOnly) =&gt; { namesOnly = namesOnly || false; load(); let i = 0; for (const fx in global) { if (!fx.startsWith(&quot;fx&quot;)) continue; const doc = getDoc(global[fx]); if (namesOnly) { if (!U.textContains(fx, filter)) continue; } else { if (!(U.textContains(fx, filter) || U.textContains(doc, filter))) continue; } console.log(d(`${++i}. ${fx}`)); if (doc) { console.log(highlight(doc, { language: &quot;js&quot; })); } }; if (i === 0) { console.log(&quot;No fixtures are found&quot;.yellow); }; }; const getRelevant = (all, filtered, classified) =&gt; { if (classified.map(i =&gt; i.value).reduce((j, i) =&gt; j === i ? j : NaN)) { return filtered; } classified = classified.slice(0, 3); const result = []; for (const cls of classified) { result.push(getStep(all, cls.label)); }; for (const f of filtered) { if (getStep(result, f.name)) continue; result.push(f); }; return result.reverse(); }; const getStep = (bucket, name) =&gt; { for (const b of bucket) { if (b.name === name) return b; } return null; }; const getDoc = func =&gt; { const doc = func .__doc__ .split(&quot;\\n&quot;) .map(i =&gt; i.trim()) .filter(i =&gt; i) .map(i =&gt; ` ${i}`) .join(&quot;\\n&quot;); if (!doc) return doc; return ` /**\\n${doc}\\n */`; }; const load = () =&gt; { global.before = () =&gt; {}; global.after = () =&gt; {}; global.beforeEach = () =&gt; {}; global.afterEach = () =&gt; {}; global.it = () =&gt; {}; global.describe = (name, cb) =&gt; { cb.call({ retries: () =&gt; {}, timeout: () =&gt; {}, }); }; require(&quot;./globals&quot;); require(&quot;./loader&quot;); }; const func_desc = func =&gt; { return func.toString().replace(&quot;\\n&quot;, &quot; &quot;).split(/\\) *\\{/)[0] + &quot;) {...}&quot;; }; × Search results Close "},"globals_rewire.js.html":{"id":"globals_rewire.js.html","title":"Source: globals/rewire.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/rewire.js &quot;use strict&quot;; var path = require(&quot;path&quot;); var _rewire = require(&quot;rewire&quot;); /** * `rewire` is great lib for monkey patching, but it should be a bit patched too :) * * @global */ var rewire = filename =&gt; { var _ = Error.prepareStackTrace; Error.prepareStackTrace = (_, stack) =&gt; stack; var stack = new Error().stack.slice(1); Error.prepareStackTrace = _; var callerPath = stack[0].getFileName(); var callerDir = path.dirname(callerPath); filename = path.resolve(callerDir, filename); var mod = _rewire(filename); var cache = {}; var set = mod.__set__; mod.__set__ = function (name, stub) { if (!Object.keys(cache).includes(name)) { cache[name] = this.__get__(name); } set.call(this, name, stub); }; mod.__reset__ = function () { for (var [k, v] of Object.entries(cache)) { this.__set__(k, v); } cache = {}; }; return mod; }; module.exports = rewire; × Search results Close "},"globals_scope.js.html":{"id":"globals_scope.js.html","title":"Source: globals/scope.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/scope.js &quot;use strict&quot;; var U = require(&quot;glace-utils&quot;); /** * Execute tests scope. * * @global * @function * @arg {string} name - Scope name. * @arg {object} [opts] - Scope options. * @arg {number} [opts.chunkRetry] - Number of chunk retries on failure. * @arg {number} [opts.chunkTimeout] - Time to execute chunk or hook, sec. * @arg {function[]} [fixtures] - List of fixtures. * @arg {function} func - Function with test cases. * @example scope(&quot;Some test scope&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); */ var scope = (name, opts, fixtures, func) =&gt; { if (opts instanceof Function) { func = opts; opts = {}; fixtures = []; } if (fixtures instanceof Function) { func = fixtures; fixtures = []; } opts = opts || {}; fixtures = fixtures || {}; describe(name, function () { if (opts.chunkRetry) this.retries(opts.chunkRetry); if (opts.chunkTimeout) this.timeout(opts.chunkTimeout * 1000); U.wrap(fixtures, func)(); }); }; module.exports = scope; × Search results Close "},"globals_session.js.html":{"id":"globals_session.js.html","title":"Source: globals/session.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: globals/session.js &quot;use strict&quot;; var U = require(&quot;glace-utils&quot;); var CONF = require(&quot;../config&quot;); var hacking = require(&quot;../hacking&quot;); /** * Executed sessions counter. * * @type {Number} */ var sessNum = 0; var retryTests = []; /** * Executes tests session. * * @global * @function * @arg {string} [name] - Session name. By default it includes start date time. * @arg {object} [ctx] - Session context. By default it's empty. * @arg {function} func - Function with test cases. * @example session(() =&gt; { test(&quot;Test #1&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); test(&quot;Test #2&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); }); */ var session = (name, ctx, fixtures, func) =&gt; { if (name instanceof Function) { func = name; name = CONF.session.name; ctx = {}; fixtures = []; } if (ctx instanceof Function) { func = ctx; ctx = {}; fixtures = []; } if (fixtures instanceof Function) { func = fixtures; fixtures = []; } name = name || CONF.session.name; ctx = ctx || {}; fixtures = fixtures || []; sessNum++; ctx.sessionNumber = sessNum; suite(name, () =&gt; { U.wrap(fixtures, func)(); after(() =&gt; { if (!retryTests.length) return; var sessName = `Retry #${sessNum}`; /* Hack to pass mocha grep */ var mochaRunner = hacking.getRunner(); if (mochaRunner._grep !== mochaRunner._defaultGrep) { sessName += &quot; - &quot; + mochaRunner._grep.source; } var sessCtx = { retryNumber: sessNum }; global.session(sessName, sessCtx, null, () =&gt; { while(retryTests.length) { var retry = retryTests.shift(); retry.func(retry.args); }; }); }); }); }; module.exports.session = session; module.exports.retryTests = retryTests; × Search results Close "},"steps_index.js.html":{"id":"steps_index.js.html","title":"Source: steps/index.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: steps/index.js &quot;use strict&quot;; /** * Creates new instance of `Steps` class. * * @class * @classdesc Contains collection of steps which may be called inside tests via * its instance [SS](global.html#SS). It mixes steps from plugins too. * @name Steps * @mixes TimerSteps * @prop {object} ctx - Storage to share some data between steps. */ var util = require(&quot;util&quot;); require(&quot;colors&quot;); var _ = require(&quot;lodash&quot;); var U = require(&quot;glace-utils&quot;); var CONF = require(&quot;../config&quot;); var plugins = require(&quot;../plugins&quot;); var tools = require(&quot;../tools&quot;); var Steps = function () { this.ctx = {}; }; module.exports = Steps; Steps.prototype.resetCtx = function () { /** * Helper to reset steps context. * * @memberOf Steps * @method resetCtx * @instance */ this.ctx = {}; }; Steps.prototype.isTestFailed = function () { /** * Helper to check whether test was failed before current step. * * @memberOf Steps * @method isTestFailed * @instance * @return {undefined|boolean} `undefined` if test is absent, * `true` if test was failed, `false` otherwise. */ if (!CONF.test.curCase) return; return !!CONF.test.curCase.errors.length; }; Steps.prototype.debug = async function () { /** * Step to enter to interactive debugging mode. May be used inside test if you * need to debug test in runtime. * * @async * @memberOf Steps * @method debug * @instance * @return {Promise&lt;void&gt;} * @example * * test(&quot;my test&quot;, () =&gt; { * chunk(async () =&gt; { * await SS.debug(); * }); * }); */ var onFail = CONF.session.debugOnFail; CONF.session.debugOnFail = false; await U.debug(); CONF.session.debugOnFail = onFail; }; Steps.prototype.listSteps = function (filter, namesOnly) { /** * Step to list available steps [debug mode]. * * @memberOf Steps * @method listSteps * @instance * @arg {string} filter - Steps filter. * @arg {boolean} [namesOnly=false] - Search among step names only. By default * full-text search is used. */ tools.listSteps(filter, namesOnly); }; /** * Registers steps (mixes them). * * @method * @static * @arg {...object} steps - Sequence of steps to register. * @example * * var MyStepsMixin = require(&quot;./my-steps-mixin&quot;); * var AnotherStepsMixin = require(&quot;./another-steps-mixin&quot;); * * Steps.register(MyStepsMixin, AnotherStepsMixin); */ Steps.register = function () { for (var obj of arguments) { _.assign(this.prototype, obj); } }; /** * Helper to get steps instance. * * It wraps steps class with proxy object. Proxy observes steps call and in * debug mode if steps is failed it entered test to interactive debug mode. * * @method * @static * @arg {function} [cls] - Class with steps. By default original glace `Steps` * will be used. * @return {Proxy} Wrapped steps instance. */ Steps.getInstance = function (cls) { return new Proxy( new (cls || Steps), { get: (target, property) =&gt; { var func = target[property]; if (!util.isFunction(func)) return func; if (property === &quot;debug&quot; || !CONF.session.debugOnFail) { return func; } return async function () { try { var result = await func.apply(target, arguments); } catch (e) { console.log(util.format(e).red); await target.debug(); throw e; } return result; }; }, }); }; Steps.register(require(&quot;./timer&quot;)); /* Load plugins steps */ Steps.register.apply(Steps, plugins.getModules(&quot;Steps&quot;)); × Search results Close "},"steps_timer.js.html":{"id":"steps_timer.js.html","title":"Source: steps/timer.js","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Source: steps/timer.js /* global expect */ &quot;use strict&quot;; /** * Steps to measure time. * * These methods will be mixed with glacejs [Steps](https://glacejs.github.io/glace-core/Steps.html) * class and available via its instance [SS](https://glacejs.github.io/glace-core/global.html#SS) * in tests. * * @mixin TimerSteps */ var util = require(&quot;util&quot;); var U = require(&quot;glace-utils&quot;); var LOG = U.logger; var A = require(&quot;../allure&quot;); var TimerSteps = { pause: async function (timeout, message) { /** * Step to make pause in another step or test case. **Good style** is * to not use directly in test case, only inside another step. * * @async * @memberOf TimerSteps * @method pause * @instance * @arg {number} timeout - Pause time, sec. * @arg {string} message - Pause reason. * @return {Promise&lt;void&gt;} * @throws {AssertionError} If pause message isn't defined. * @example * * await SS.pause(1, &quot;wait for server start&quot;); */ A.step(`Sleep ${timeout} sec because ${message}`); expect(message, &quot;Pause message is not defined&quot;).to.not.be.undefined; LOG.warn(&quot;Sleep&quot;, timeout, &quot;sec, reason:&quot;, message); await U.sleep(timeout * 1000); A.pass(); }, startTimer: function () { /** * Step to start timer. * Each time when it will be called, timer will be reset. * * @memberOf TimerSteps * @method startTimer * @instance * @example * * SS.startTimer(); * await SS.pause(1, &quot;sleep a bit&quot;); * var elapsedSeconds = SS.getTimer(); */ A.step(&quot;Start timer&quot;); this._timer = new Date(); A.pass(); }, stopTimer: function () { /** * Step to stop timer. * * @memberOf TimerSteps * @method stopTimer * @instance * @example * * SS.stopTimer(); */ A.step(&quot;Stop timer&quot;); this._timer = null; A.pass(); }, getTimer: function () { /** * Step to get timer. * * @memberOf TimerSteps * @method getTimer * @instance * @return {number} Number of seconds since timer starts. * @throws {AssertionError} If timer isn't started. * @example * * SS.startTimer(); * await SS.pause(1, &quot;sleep a bit&quot;); * var elapsedSeconds = SS.getTimer(); */ A.step(&quot;Get timer value&quot;); expect(this._timer, &quot;Timer isn't started&quot;).to.exist; var result = (new Date() - this._timer) / 1000; A.pass(); return result; }, checkTimer: function (condition) { /** * Step to check timer. * * @memberOf TimerSteps * @method checkTimer * @instance * @arg {string|object} condition - [chaijs](http://chaijs.com/) condition. * @throws {AssertionError} If timer verification was failed. * @example * * SS.startTimer(); * SS.checkTimer(&quot;to exist&quot;); * * SS.startTimer(); * await SS.pause(1, &quot;sleep a bit&quot;); * SS.checkTimer({ &quot;to be gte&quot;: 1 }); */ if (typeof(condition) === &quot;string&quot;) { var stepMsg = `Check timer ${condition}`; } else { stepMsg = util.format(&quot;Check timer with condition&quot;, condition); } A.step(stepMsg); expect(this.getTimer(), &quot;Timing is failed&quot;).to.correspond(condition); A.pass(); }, }; module.exports = TimerSteps; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Global Members $ :Steps Steps collection. Type: Steps Source: globals/index.js, line 110 See: steps to get more details about its methods. allure Allure helper. Source: globals/index.js, line 102 CONF GlaceJS config. Source: globals/index.js, line 95 See: config to get more details about its options. reporters :Array.&lt;object&gt; Registered reporters. Type: Array.&lt;object&gt; Source: reporter/base.js, line 25 sessNum :Number Executed sessions counter. Type: Number Source: globals/session.js, line 13 sinon SinonJS is pretty nice lib for mocking. Source: globals/index.js, line 47 stubObject Stubs object with its properties recursively. Source: globals/index.js, line 85 Methods afterChunk(name, func) Executes after each test chunk. Parameters: Name Type Description name string Name of test case. func function Hook function. Source: globals/index.js, line 168 Example test(&quot;Some test&quot;, () =&gt; { afterChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); &lt;abstract&gt; baseTest(name [, opts] [, fixtures], func) Basis for any test case. If test with the same was registered already, this test will be omitted with corresponding error in log. If retries amount is specified and this test was failed, the test will be added to queue in separated session with title containing Retry and its number. Parameters: Name Type Argument Description name string Name of test case. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description skip boolean | string &lt;optional&gt; false Flag to skip test or skip reason. retry number &lt;optional&gt; 0 Number of retries on failure. Overrides config value for concrete test. chunkRetry number &lt;optional&gt; 0 Number of chunk retries on failure. Overrides config value for concrete test chunks. chunkTimeout number &lt;optional&gt; &lt;nullable&gt; null Time to execute chunk or hook, sec. fixtures Array.&lt;function()&gt; &lt;optional&gt; Involved fixtures list. func function Test function. Source: globals/test.js, line 53 beforeChunk(name, func) Executes before each test chunk. Parameters: Name Type Description name string Name of test case. func function Hook function. Source: globals/index.js, line 145 Example test(&quot;Some test&quot;, () =&gt; { beforeChunk(() =&gt; { someFunc(); }); chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); chunk( [name] [, opts], func) Defines test chunk. Contains actions and verifications, which will be executed separatly from another chunks. This function is used to organize test structure and to allocate independent test actions. Parameters: Name Type Argument Description name string &lt;optional&gt; Name of chunk. opts object &lt;optional&gt; Chunk options. Properties Name Type Argument Description retry number &lt;optional&gt; Number of chunk retries on failure. timeout number &lt;optional&gt; Time limit to execute chunk, sec. func function Callback function with test payload. Source: globals/chunk.js, line 49 Examples Anonymous chunk test(&quot;My test&quot;, () =&gt; { chunk(() =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); Named chunk test(&quot;My test&quot;, () =&gt; { chunk(&quot;My chunk&quot;, () =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); Chunk with options test(&quot;My test&quot;, () =&gt; { chunk(&quot;My chunk&quot;, { retry: 2, timeout: 1 }, () =&gt; { var a = 5; expect(a).to.be.equal(2); }); }); expect(actualValue) chaijs expect function. Parameters: Name Type Description actualValue * Some actual value which should be checked. Source: globals/index.js, line 41 See: chaijs to get more details about `expect` usage. Example expect(1).to.be.equal(1); expect(2).to.be.gte(0); forEachLanguage( [ctx] [, opts] [, fixtures], func) Iterates test chunks through all languages specified in config or options. It's applicable for multilingual application. If list of languages is specified, it will be used firstly. Otherwise from configuration. Parameters: Name Type Argument Description ctx object &lt;optional&gt; Test case context. opts object &lt;optional&gt; Options. Properties Name Type Argument Description languages Array.&lt;string&gt; &lt;optional&gt; &lt;nullable&gt; List of tested languages. fixtures Array.&lt;function()&gt; &lt;optional&gt; Involved fixtures list. func function Function with test steps. Source: globals/forEachLanguage.js, line 30 Example test(&quot;Some test&quot;, ctx =&gt; { forEachLanguage(ctx, lang =&gt; { chunk(() =&gt; { // payload }); }); }); glaceRun(cb) Runs glace framework. Parameters: Name Type Description cb function Callback. Source: run.js, line 72 help(d, cb) Help description. Parameters: Name Type Description d function Function to process option description. cb function Callback to expand default help. Source: help.js, line 2 rewire() rewire is great lib for monkey patching, but it should be a bit patched too :) Source: globals/rewire.js, line 11 run(cb) Runs tests. executes runner.js file, which is entry point to load and execute files with tests connects custom reporter to mochajs. Parameters: Name Type Description cb function Callback. Source: run.js, line 2 scope(name [, opts] [, fixtures], func) Execute tests scope. Parameters: Name Type Argument Description name string Scope name. opts object &lt;optional&gt; Scope options. Properties Name Type Argument Description chunkRetry number &lt;optional&gt; Number of chunk retries on failure. chunkTimeout number &lt;optional&gt; Time to execute chunk or hook, sec. fixtures Array.&lt;function()&gt; &lt;optional&gt; List of fixtures. func function Function with test cases. Source: globals/scope.js, line 33 Example scope(&quot;Some test scope&quot;, () =&gt; { test(&quot;Some test name&quot;, () =&gt; { before(() =&gt; { someFunc(); }); chunk(&quot;chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;chunk #2&quot;, () =&gt; { someFunc(); }); }); }); session( [name] [, ctx], func) Executes tests session. Parameters: Name Type Argument Description name string &lt;optional&gt; Session name. By default it includes start date time. ctx object &lt;optional&gt; Session context. By default it's empty. func function Function with test cases. Source: globals/session.js, line 45 Example session(() =&gt; { test(&quot;Test #1&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); test(&quot;Test #2&quot;, () =&gt; { chunk(&quot;Chunk #1&quot;, () =&gt; { someFunc(); }); chunk(&quot;Chunk #2&quot;, () =&gt; { someFunc(); }); }); }); setLog() Helper to set actual log file. Source: globals/test.js, line 23 test(name [, opts] [, fixtures], func) Executes test case. Parameters: Name Type Argument Description name string Name of test case. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description skip boolean | string &lt;optional&gt; false Flag to skip test or skip reason. retry number &lt;optional&gt; 0 Number of retries on failure. Overrides config value for concrete test. chunkRetry number &lt;optional&gt; 0 Number of chunk retries on failure. Overrides config value for concrete test chunks. chunkTimeout number &lt;optional&gt; &lt;nullable&gt; null Time to execute chunk or hook, sec. fixtures Array.&lt;function()&gt; &lt;optional&gt; Involved fixtures list. func function Test function. Source: globals/test.js, line 179 Example test(&quot;Some test&quot;, () =&gt; { chunk(&quot;Some chunk&quot;, () =&gt; { someFunc(); }); }); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Modules Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Classes Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Namespaces Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Mixins Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Tutorials Classes GlaceReporter ConfigError StepError ScopeType TestCase Steps Mixins TimerSteps Namespaces GlaceConfig × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest | Source Code | Release Notes Glace (fr. glacé — ice, frozen) is a cold drink based on coffee with addition of ice cream. Annotationglace-core is a quick-start functional &amp; unit testing framework based on mocha and extensible with plugins (how plugins work). Why it is Firstly it's R&amp;D project for me to dive deeply to programming and software architecture. Current testing frameworks like mocha or jasmine look cool for unit testing but are not flexible for complex functional scenarios. Quick start Make sure you have installed node &gt;= v8.9 &amp; npm &gt;= v5.5. Install glace-core globally npm i -g glace-core or locally npm i glace-core. Create file tests.js with next content: &quot;use strict&quot;; test(&quot;My first test&quot;, () =&gt; { chunk(() =&gt; { console.log(&quot;hello world&quot;); }); }); test(&quot;My second test&quot;, () =&gt; { chunk(() =&gt; { throw new Error(&quot;BOOM!&quot;); }); }); About test, chunk and other key words read here. Launch tests with command glace tests.js if you installed glace-core globally or with ./node_modules/glace-core/bin/glace tests.js if locally and get the result. Features Cross-platform Based on STEPS-architecture and STEPS-protocol May be extended with plugins implemented STEPS-protocol Oriented to complex functional scenarios Indepentently executed chunks inside a test Parameterization inside and outside of test Mechanism to retry failed tests Mechanism to retry failed chunks Mechanism to process uncaught exceptions (mocha mechanism is unreliable but supported) Fixtures support similar to pytest fixtures Conftest and preloads support Test &amp; chunk options Multiple reporting system Stdout reporter in-box TestRail reporter in-box Easy to provide custom reporter May read CLI arguments from JSON file May be extended with custom JavaScript config May be used as platform for own testing frameworks development How to useglace [options] [sequence-of-test-files-or-folders]How glace loads tests ➤ CLI optionsCommon --version - Show version number. -h, --help - Show help. Arguments --config [path], -c - Path to JSON file with CLI arguments. Default is cwd/config.json (if it exists). Note! All options below may be set via .json file (see option --config above). Log --stdout-log - Print log messages to stdout. --log [path] - Path to log file. Default is cwd/glace.log. --log-level [level] - Log level. Supported values are error, warn, info, verbose, debug, silly. Default is debug. Core --user-config [path] - Path to JS file with configuration which will be merged with override default configuration. Default is cwd/config.js (if it exists). --session-name [name] - Tests run session name. Default value includes word session and datetime. --grep &lt;pattern&gt;, -g - Filter tests by name or name chunk. --include &lt;sequence&gt; - Sequence of test name chunks separated by | in order to choose tests for run. --exclude &lt;sequence&gt; - Sequence of test name chunks separated by | in order to exclude tests from run. --precise - Precise tests inclusion or exclusion (not substring pattern). --report [path] - Path to reports folder. Default is cwd/report. --dont-clear-report - Don't clear previous report on tests run. --dont-check-names - Don't check test names uniqueness (usually useful in unit testing). --failed-tests-path [path] - Path to save failed tests in JSON format. Default is cwd/report/failed-tests.json. --root-conftest &lt;path&gt; - Path to root conftest.js which will be loaded before all. --languages &lt;sequence&gt; - List of tested languages separated with comma. --retry [times] - Number of times to retry failed test. Default is 0. --chunk-retry [times] - Number of times to retry failed chunk. Default is 0. --chunk-timeout [sec] - Time to execute chunk or hook, sec. Default is 180. --uncaught [type] - Strategy to process uncaught exceptions. Default value is log. Supported values are log just to log uncaught exceptions, fail to fail test if uncaught exception happened, mocha to use default mocha mechanism (unreliable). --kill-procs &lt;sequence&gt; - List of process names separated with comma, which will be killed before tests run. --debug-on-fail - Enter to interactive debug mode on step failure. --exit-on-fail - Finish test run on first failure. --errors-now - Print error message immediately when it happened. --interactive, -i - Launch interactive mode to execute steps manually in terminal. Plugins --list-plugins - Show plugins only. --plugins-dir [path] - Path to custom plugins folder. By default it searches plugins inside folder, where glace-core is installed. --disable-default-plugins - Disable default plugins. xUnit --xunit - Activate xUnit reporter. --xunit-path [path] - Path to xUnit report. Default is cwd/report/xunit.xml. --xunit-suite-name [name] - Tests suite name in xUnit report. By default it's the same as session name. Allure --allure - Activate Allure reporter. --allure-dir [path] - Path to allure reports folder. Default is cwd/report/allure. TestRail --testrail - Activate TestRail reporter. --testrail-host &lt;host&gt; - TestRail host. --testrail-user &lt;user&gt; - TestRail username or email. --testrail-token &lt;token&gt; - TestRail token. --testrail-project-id &lt;id&gt; - TestRail project id. --testrail-suite-id &lt;id&gt; - TestRail suite id. --testrail-run-name &lt;name&gt; - TestRail run name. --testrail-run-desc &lt;description&gt; - TestRail run description. Tools --testrail-check - Check TestRail cases consistency with implemented tests. --list-steps [filter] - List available steps and exit. --list-tests [filter] - List collected tests and exit. --list-fixtures [filter] - List available fixtures and exit. Test examplesSee integration tests in order to explore examples. Frameworks platformGlaceJS may be used as platform for own testing frameworks development. Simple example: require(&quot;colors&quot;); require(&quot;glace-core&quot;).run().then(errCode =&gt; { if (!errCode) { console.log(&quot;It's passed! 🙂&quot;.green.bold); } else { console.log(&quot;It's failed! 🙁&quot;.red.bold); }; process.exit(errCode); });Tests coveragePlease see here GuidelinesHow to retry tests or chunksIn order to retry failed tests or chunks you may pass CLI options --retry or --chunk-retry to affect all tests or chunks or to specify retry option for concrete test or chunk. How to use fixturesIn order to avoid copy/paste with before and after hooks in tests you may use fixtures... Read more ➤ × Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Namespace: GlaceConfig GlaceConfig Configures GlaceJS before tests run. Properties: Name Type Argument Description session object Session namespace. Properties Name Type Argument Default Description name string Session name. By default contains timestamp. Can be overridden with CLI option --session-name. id string Session ID. Default is timestamp. isPassed boolean &lt;optional&gt; false Flag to define if tests session run is passed or no. preloads array.&lt;string&gt; &lt;optional&gt; [] Array of paths to js modules which will be loaded before tests session run. interactive boolean &lt;optional&gt; false Flag to launch interactive session. Can be overridden with CLI option -i / --interactive. debugOnFail boolean &lt;optional&gt; false Flag to enter to interactive mode on step failure. Can be overridden with CLI option --debug-on-fail. exitOnFail boolean &lt;optional&gt; false Flag to break tests session on first test failure. Can be overridden with CLI option --exit-on-fail. uncaughtException string &lt;optional&gt; log Strategy to process uncaught exceptions. Available values are log, fail, mocha. Can be overridden with CLI option --uncaught. rootConftest string Path to js module which will be loaded right after preloads. Can be overridden with CLI option --root-conftest. killProcs array.&lt;string&gt; Array of process names which will be killed before tests session run. Can be overridden with CLI option --kill-procs. test object Test namespace. Properties Name Type Argument Default Description curCase TestCase &lt;optional&gt; &lt;nullable&gt; null Currently executed test case. cases array.&lt;TestCase&gt; &lt;optional&gt; [] Array of session test cases. languages array.&lt;string&gt; &lt;optional&gt; [] Array of language names. Can be overridden with CLI option --languages. dirs array.&lt;string&gt; &lt;optional&gt; [] Array of test files or folders. Can be overridden with CLI arguments or option --targets separated with comma. checkNames boolean &lt;optional&gt; true Flag to check test names uniqueness. Can be overridden with CLI option --dont-check-names. retries integer &lt;optional&gt; 0 Number of test retries on failure. Can be overridden with CLI option --retry. chunkRetries integer &lt;optional&gt; 0 Number of chunk retries on failure. Can be overridden with CLI option --chunk-retry. chunkTimeout integer &lt;optional&gt; 180000 Timeout of chunk execution, ms. Can be overridden with CLI option --chunk-timeout, sec. report object Report namespace. Properties Name Type Argument Default Description dir string &lt;optional&gt; cwd/report Folder to save tests session report. logsDir string &lt;optional&gt; report.dir Folder to save test logs. Can be overridden with CLI option --report-dir. clear boolean &lt;optional&gt; true Flag to clear report before tests run. Can be overridden with CLI option --dont-clear-report. errorsNow boolean &lt;optional&gt; false Flag to print test error right after its capture. Can be overridden with CLI option --errors-now. failedTestsPath string &lt;optional&gt; cwd/failed-tests.json Path to file where info about failed tests will be saved to. Can be overridden with CLI option --failed-tests-path. xunit object &lt;optional&gt; xUnit report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate xUnit report. Can be overridden with CLI option --xunit. path string &lt;optional&gt; report.dir/xunit.xml Path to xUnit report. Can be overridden with CLI option --xunit-path. suiteName string &lt;optional&gt; session.name xUnit suite name. Can be overridden with CLI option --xunit-suite-name. allure object &lt;optional&gt; Allure report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate allure report. Can be overridden with CLI option --allure. dir string &lt;optional&gt; report.dir/allure Folder to save allure report. Can be overridden with CLI option --allure-dir. suiteName string &lt;optional&gt; session.name Allure suite name. Can be overridden with CLI option --allure-suite-name. testrail object Testrail report namespace. Properties Name Type Argument Default Description use boolean &lt;optional&gt; false Flag to activate testrail report. Can be overridden with CLI option --testrail. host string Testrail host. Can be overridden with CLI option --testrail-host. user string Testrail user name or email. Can be overridden with CLI option --testrail-user. token string Testrail auth token. Can be overridden with CLI option --testrail-token. projectId string Testrail project ID. Can be overridden with CLI option --testrail-project-id. suiteId string Testrail suite ID. Can be overridden with CLI option --testrail-suite-id. runName string Testrail run name. Can be overridden with CLI option --testrail-run-name. runDescription string Testrail run description. Can be overridden with CLI option --testrail-run-description. plugins object Plugins namespace. Properties Name Type Description dir string Folder with custom plugins. Can be overridden with CLI option --plugins-dir. filter object Tests filter namespace. Properties Name Type Argument Default Description grep string Mocha grep option to filter tests, scopes and suites. Can be overridden with CLI option -g / --grep. include array.&lt;string&gt; List of test names which should be included to tests session. Can be overridden with CLI option --include. exclude array.&lt;string&gt; List of test names which should be excluded from tests session. Can be overridden with CLI option --exclude. precise boolean &lt;optional&gt; false Flag for precise tests inclusion or exclusion (not substring pattern). Can be overridden with CLI option --precise. tools object Tools namespace. Properties Name Type Argument Default Description stepsList boolean &lt;optional&gt; false Flag to list available steps only. Can be overridden with CLI option --list-steps. stepsFilter string String to filter steps. Can be overridden with CLI option --list-steps. testsList boolean &lt;optional&gt; false Flag to list implemented tests only. Can be overridden with CLI option --list-tests. testsFilter string String to filter tests. Can be overridden with CLI option --list-tests. fixturesList boolean &lt;optional&gt; false Flag to list available fixtures only. Can be overridden with CLI option --list-fixtures. fixturesFilter string String to filter fixtures. Can be overridden with CLI option --list-fixtures. checkTestrail boolean &lt;optional&gt; false Flag to check matching of testrail cases with implemented tests only. Can be overridden with CLI option --testrail-check. Source: config.js, line 2 × Search results Close "},"GlaceReporter.html":{"id":"GlaceReporter.html","title":"Class: GlaceReporter","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: GlaceReporter GlaceReporter new GlaceReporter(runner) GlaceJS common reporter. Parameters: Name Type Description runner object MochaJS runner. Source: reporter/base.js, line 2 Methods &lt;static&gt; register(reporters) Registers reporters if they are not. Parameters: Name Type Argument Description reporters object &lt;repeatable&gt; Sequence of reporters to register. Source: reporter/base.js, line 190 &lt;static&gt; remove(reporters) Removes reporters if they are registered. Parameters: Name Type Argument Description reporters object &lt;repeatable&gt; Sequence of reporters to remove. Source: reporter/base.js, line 204 &lt;async&gt; done(failures, fn) Finalizes reporting. Parameters: Name Type Description failures Array.&lt;*&gt; Tests failures. fn function Finalizator. Source: reporter/base.js, line 172 × Search results Close "},"module-allure.html":{"id":"module-allure.html","title":"Module: allure","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: allure Allure wrapper. Source: allure.js, line 3 Methods &lt;static&gt; allure.addDescription(desc, type) Adds test description if test is started. Parameters: Name Type Description desc string Description. type string Mime type. Source: allure.js, line 105 &lt;static&gt; allure.addEnvironment(name, value) Adds test environment value if test is started. Parameters: Name Type Description name string Environment name. value string Environment value. Source: allure.js, line 93 &lt;static&gt; allure.attach(name, content, type) Attach content to test if test is started. Parameters: Name Type Description name string Content name. content string Content body. type string Mime type. Source: allure.js, line 118 &lt;static&gt; allure.attachHtml(name, html) Attach HTML to test if test is started. Parameters: Name Type Description name string HTML name. html string HTML content. Source: allure.js, line 177 &lt;static&gt; allure.attachImage(name, imgPath) Attach image to test if test is started. Parameters: Name Type Description name string Image name. imgPath string Image path. Source: allure.js, line 142 &lt;static&gt; allure.attachJson(name, obj) Attach JSON to test if test is started. Parameters: Name Type Description name string JSON name. obj string Object to convert to JSON. Source: allure.js, line 130 &lt;static&gt; allure.attachText(name, txt) Attach text to test if test is started. Parameters: Name Type Description name string Text name. txt string Text content. Source: allure.js, line 166 &lt;static&gt; allure.attachVideo(name, videoPath) Attach video to test if test is started. Parameters: Name Type Description name string Video name. videoPath string Video path. Source: allure.js, line 154 &lt;static&gt; allure.feature(name) Adds test feature if test is started. Parameters: Name Type Description name string Feature name. Source: allure.js, line 81 &lt;static&gt; allure.hasSteps() Defines if allure helper has steps or no. Source: allure.js, line 31 Returns: true if it has steps, false otherwise. Type boolean &lt;static&gt; allure.isTestStarted() Defines if test is started or no. Source: allure.js, line 41 Returns: true if test is started, false otherwise. Type boolean &lt;static&gt; allure.pass() Ends step as passed if test is started. Source: allure.js, line 60 &lt;static&gt; allure.step(name) Starts step if test is started. Parameters: Name Type Description name string Step name. Source: allure.js, line 51 &lt;static&gt; allure.story(name) Adds test story if test is started. Parameters: Name Type Description name string Story name. Source: allure.js, line 70 × Search results Close "},"module-classifier.html":{"id":"module-classifier.html","title":"Module: classifier","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: classifier Wrapper on bayes classifier. Source: classifier.js, line 3 × Search results Close "},"module-cli.html":{"id":"module-cli.html","title":"Module: cli","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: cli Contains functions to execute tests via command line interface. Source: cli.js, line 2 Methods &lt;static&gt; run() Runs GlaceJS in CLI. Source: cli.js, line 16 × Search results Close "},"module-error.html":{"id":"module-error.html","title":"Module: error","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: error Contains GlaceJS errors. Source: error.js, line 2 Classes ConfigError StepError × Search results Close "},"module-error-ConfigError.html":{"id":"module-error-ConfigError.html","title":"Class: ConfigError","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: ConfigError error~ ConfigError new ConfigError(message) Error which is thrown when configuration is wrong. Parameters: Name Type Description message string Error message. Source: error.js, line 16 × Search results Close "},"module-error-StepError.html":{"id":"module-error-StepError.html","title":"Class: StepError","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: StepError error~ StepError new StepError(message) Error which is thrown when step execution is wrong. Parameters: Name Type Description message string Error message. Source: error.js, line 26 × Search results Close "},"module-globals_index.html":{"id":"module-globals_index.html","title":"Module: globals/index","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: globals/index Contains global framework functions and helpers. Source: globals/index.js, line 3 × Search results Close "},"module-hacking.html":{"id":"module-hacking.html","title":"Module: hacking","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: hacking Contains hacks for test run. Source: hacking.js, line 2 Members &lt;inner&gt; _mochaRunner :Runner Mocha runner. Type: Runner Source: hacking.js, line 49 Methods &lt;static&gt; getRunner() Gets mocha runner. Source: hacking.js, line 61 &lt;static&gt; suppressMochaUncaught() Patches original Mocha.Runner.prototype.uncaught in order to skip exceptions from proxy server res.send(). Source: hacking.js, line 22 × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: index GlaceJS main module. Properties: Name Type Description config object Config module. error object Error module. help function Help module. reporter object Reporter module. run object run module. Steps object Steps module. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 27 &lt;inner&gt; help Help. Source: index.js, line 42 &lt;inner&gt; reporter :GlaceReporter Type: GlaceReporter Source: index.js, line 57 &lt;inner&gt; run :run Type: run Source: index.js, line 66 &lt;inner&gt; Steps :Steps Type: Steps Source: index.js, line 75 × Search results Close "},"module-loader.html":{"id":"module-loader.html","title":"Module: loader","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: loader Makes tests root session. runner loads root conftest.js if it is located on one level with each of CONF.test.dirs; if each of CONF.test.dirs is file with tests, runner loads and executes it; if each of CONF.test.dirs is folder runner loads files inside recursive if file name starts with test and ends with .js; inside each subfolder of each of CONF.test.dirs runner loads conftest.js file if it is present; Source: loader.js, line 5 Methods &lt;inner&gt; loadTests(dir) Loads test files recursively. Test file name should start with test and end with .js. Parameters: Name Type Description dir string Folder with test files. Source: loader.js, line 110 &lt;inner&gt; mainConftests() Main conftests are loaded before tests session creation and may used for objects management, for example to created custom instance of global SS. Main conftest is conftest.js file which is located on one hierarchy level with each specified tests folder or file. Source: loader.js, line 63 &lt;inner&gt; preloads() Loads special preloads files before main conftests and test files. Preloads are specified in CONF.preloads array. It may be managed only programmatically and needs as extension point to load some custom files before tests. After preloads it loads root (the mainest) conftest file, which may be set via CLI. Source: loader.js, line 40 &lt;inner&gt; sessFunc() Callback to create tests session. It kills some processes before all if they are specified. Source: loader.js, line 84 × Search results Close "},"module-matcher.html":{"id":"module-matcher.html","title":"Module: matcher","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: matcher Matchers. Source: matcher.js, line 2 × Search results Close "},"module-plugins.html":{"id":"module-plugins.html","title":"Module: plugins","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: plugins Plugins. Source: plugins.js, line 2 Methods &lt;static&gt; clearCache() Clear plugins cache. Source: plugins.js, line 104 &lt;static&gt; getModules(moduleName) Gets modules from plugins. Parameters: Name Type Description moduleName string Name of module to request from plugins. Source: plugins.js, line 27 Returns: List of modules requested from plugins. Type Array.&lt;object&gt; &lt;static&gt; getRegistered() Gets names of registered custom plugins. Source: plugins.js, line 132 Returns: Plugin names. Type array.&lt;string&gt; &lt;static&gt; register(name) Registers custom plugin. Parameters: Name Type Description name string Name of plugin module. Source: plugins.js, line 111 × Search results Close "},"module-reporter_allure.html":{"id":"module-reporter_allure.html","title":"Module: reporter/allure","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: reporter/allure Allure reporter. Source: reporter/allure.js, line 3 × Search results Close "},"module-reporter_index.html":{"id":"module-reporter_index.html","title":"Module: reporter/index","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: reporter/index GlaceJS reporter package. Source: reporter/index.js, line 2 × Search results Close "},"module-reporter_stdout.html":{"id":"module-reporter_stdout.html","title":"Module: reporter/stdout","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: reporter/stdout GlaceJS stdout reporter. Source: reporter/stdout.js, line 2 Methods done() Called on report finalizing. Source: reporter/stdout.js, line 292 end() Called before tests end. Source: reporter/stdout.js, line 150 fail(chunk) Called on chunk or hook failed. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 260 pass(chunk) Called on chunk passed. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 236 scope(scope) Called on scope start. Parameters: Name Type Description scope object MochaJS suite. Source: reporter/stdout.js, line 164 scopeEnd() Called before scope end. Source: reporter/stdout.js, line 177 skip(chunk) Called on chunk skipped. Parameters: Name Type Description chunk object MochaJS test. Source: reporter/stdout.js, line 248 suite(suite) Called on suite start. Parameters: Name Type Description suite object MochaJS suite. Source: reporter/stdout.js, line 188 suiteEnd() Called before suite end. Source: reporter/stdout.js, line 201 test(test) Called on test start. Parameters: Name Type Description test object MochaJS suite. Source: reporter/stdout.js, line 212 testEnd() Called on test end. Source: reporter/stdout.js, line 225 × Search results Close "},"module-reporter_testrail.html":{"id":"module-reporter_testrail.html","title":"Module: reporter/testrail","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: reporter/testrail TestRail reporter. Source: reporter/testrail.js, line 2 Methods done() Called on report finalizing. Source: reporter/testrail.js, line 164 end() Called before tests end. Source: reporter/testrail.js, line 90 start() Called on tests start. Source: reporter/testrail.js, line 44 testEnd(test) Called on test end. Parameters: Name Type Description test object MochaJS suite. Source: reporter/testrail.js, line 105 × Search results Close "},"module-reporter_xunit.html":{"id":"module-reporter_xunit.html","title":"Module: reporter/xunit","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: reporter/xunit GlaceJS xunit reporter. Source: reporter/xunit.js, line 2 Methods &lt;inner&gt; write(line) Writes a line. Parameters: Name Type Description line string Report text line. Source: reporter/xunit.js, line 58 &lt;inner&gt; writeTest(test) Writes a test. Parameters: Name Type Description test TestCase Test case. Source: reporter/xunit.js, line 66 × Search results Close "},"module-testing.html":{"id":"module-testing.html","title":"Module: testing","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: testing Contains classes and functions to save executed tests data. Source: testing.js, line 2 Classes ScopeType TestCase × Search results Close "},"module-testing-ScopeType.html":{"id":"module-testing-ScopeType.html","title":"Class: ScopeType","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: ScopeType testing~ ScopeType Class defining mochajs scope name and type. new ScopeType() Source: testing.js, line 147 Methods setType(type) Set mochajs scope type. Parameters: Name Type Description type string Supported values are scope, suite, test. Source: testing.js, line 152 × Search results Close "},"module-testing-TestCase.html":{"id":"module-testing-TestCase.html","title":"Class: TestCase","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: TestCase testing~ TestCase new TestCase(name) Test case data structure. Contains full information and history about test case. Parameters: Name Type Description name string Test name. Properties: Name Type Argument Default Description name string Test name. status string &lt;optional&gt; NOT_STARTED Test status. skipChunk string &lt;optional&gt; &lt;nullable&gt; null Name of currently skipped chunk. screenshots Array.&lt;string&gt; &lt;optional&gt; [] List of test screenshot paths. videos Array.&lt;string&gt; &lt;optional&gt; [] List of test video paths. errors Array.&lt;string&gt; &lt;optional&gt; [] List of test errors. rawInfo Array.&lt;string&gt; &lt;optional&gt; [] List of additional test details. testParams object &lt;optional&gt; {} Dict of test parameters. Source: testing.js, line 25 Methods addChunk(chunkName) Adds chunk. Parameters: Name Type Description chunkName string Name of chunk. Source: testing.js, line 134 addDetails(info) Adds additional information. Parameters: Name Type Description info string Additional information. Source: testing.js, line 125 addError(err) Adds error to test case. Parameters: Name Type Description err Error Test error. Source: testing.js, line 98 addPassedChunkId(chunkId) Adds passed chunk id. Parameters: Name Type Description chunkId string Chunk id. Source: testing.js, line 79 addPassedChunkIds(chunkIds) Adds passed chunk ids. Parameters: Name Type Description chunkIds array.&lt;string&gt; Chunk ids. Source: testing.js, line 89 addScreenshot(imagePath) Adds screenshot. Parameters: Name Type Description imagePath string Path to saved screenshot. Source: testing.js, line 107 addVideo(videoPath) Adds video. Parameters: Name Type Description videoPath string Path to saved video. Source: testing.js, line 116 end(status) Ends test case. Parameters: Name Type Description status string Test case status. Source: testing.js, line 53 reset() Resets test case info. Source: testing.js, line 66 start() Starts test case. Source: testing.js, line 40 × Search results Close "},"module-tools.html":{"id":"module-tools.html","title":"Module: tools","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Module: tools Glace tools. Source: tools.js, line 3 Methods &lt;static&gt; listPlugins() Print list of available plugins. Source: tools.js, line 127 &lt;static&gt; listTests(filter) Print list of implemented test cases. Parameters: Name Type Description filter string String chunk to filter test cases. Source: tools.js, line 101 × Search results Close "},"Steps.html":{"id":"Steps.html","title":"Class: Steps","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Class: Steps Steps Contains collection of steps which may be called inside tests via its instance SS. It mixes steps from plugins too. new Steps() Creates new instance of Steps class. Properties: Name Type Description ctx object Storage to share some data between steps. Mixes In: TimerSteps Source: steps/index.js, line 2 Methods &lt;static&gt; getInstance( [cls]) Helper to get steps instance. It wraps steps class with proxy object. Proxy observes steps call and in debug mode if steps is failed it entered test to interactive debug mode. Parameters: Name Type Argument Description cls function &lt;optional&gt; Class with steps. By default original glace Steps will be used. Source: steps/index.js, line 125 Returns: Wrapped steps instance. Type Proxy &lt;static&gt; register(steps) Registers steps (mixes them). Parameters: Name Type Argument Description steps object &lt;repeatable&gt; Sequence of steps to register. Source: steps/index.js, line 107 Example var MyStepsMixin = require(&quot;./my-steps-mixin&quot;); var AnotherStepsMixin = require(&quot;./another-steps-mixin&quot;); Steps.register(MyStepsMixin, AnotherStepsMixin); &lt;async&gt; debug() Step to enter to interactive debugging mode. May be used inside test if you need to debug test in runtime. Source: steps/index.js, line 56 Returns: Type Promise.&lt;void&gt; Example test(&quot;my test&quot;, () =&gt; { chunk(async () =&gt; { await SS.debug(); }); }); isTestFailed() Helper to check whether test was failed before current step. Source: steps/index.js, line 41 Returns: undefined if test is absent, true if test was failed, false otherwise. Type undefined | boolean listSteps(filter [, namesOnly]) Step to list available steps [debug mode]. Parameters: Name Type Argument Default Description filter string Steps filter. namesOnly boolean &lt;optional&gt; false Search among step names only. By default full-text search is used. Source: steps/index.js, line 81 resetCtx() Helper to reset steps context. Source: steps/index.js, line 29 × Search results Close "},"TimerSteps.html":{"id":"TimerSteps.html","title":"Mixin: TimerSteps","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Mixin: TimerSteps TimerSteps Steps to measure time. These methods will be mixed with glacejs Steps class and available via its instance SS in tests. Source: steps/timer.js, line 5 Methods checkTimer(condition) Step to check timer. Parameters: Name Type Description condition string | object chaijs condition. Source: steps/timer.js, line 110 Throws: If timer verification was failed. Type AssertionError Example SS.startTimer(); SS.checkTimer(&quot;to exist&quot;); SS.startTimer(); await SS.pause(1, &quot;sleep a bit&quot;); SS.checkTimer({ &quot;to be gte&quot;: 1 }); getTimer() Step to get timer. Source: steps/timer.js, line 87 Throws: If timer isn't started. Type AssertionError Returns: Number of seconds since timer starts. Type number Example SS.startTimer(); await SS.pause(1, &quot;sleep a bit&quot;); var elapsedSeconds = SS.getTimer(); &lt;async&gt; pause(timeout, message) Step to make pause in another step or test case. Good style is to not use directly in test case, only inside another step. Parameters: Name Type Description timeout number Pause time, sec. message string Pause reason. Source: steps/timer.js, line 25 Throws: If pause message isn't defined. Type AssertionError Returns: Type Promise.&lt;void&gt; Example await SS.pause(1, &quot;wait for server start&quot;); startTimer() Step to start timer. Each time when it will be called, timer will be reset. Source: steps/timer.js, line 50 Example SS.startTimer(); await SS.pause(1, &quot;sleep a bit&quot;); var elapsedSeconds = SS.getTimer(); stopTimer() Step to stop timer. Source: steps/timer.js, line 70 Example SS.stopTimer(); × Search results Close "},"tutorial-concepts.html":{"id":"tutorial-concepts.html","title":"Tutorial: GlaceJS concepts","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest GlaceJS concepts test - test case. Wrapper on mochajs describe. Should have readable and unique name per suite. test(&quot;my test&quot;, () =&gt; { chunk(() =&gt; { // payload }); });chunk - a set of actions in test. Wrapper on mochajs it. Test should contain as minimum one chunk. Chunks are executed independently inside a test. Chunk may have name or be anonymous. /* anonymous chunk */ test(&quot;my test&quot;, () =&gt; { chunk(() =&gt; { // payload }); }); /* named chunks */ test(&quot;my test&quot;, () =&gt; { chunk(&quot;#1&quot;, () =&gt; { // payload }); chunk(&quot;#2&quot;, () =&gt; { // payload }); });scope - the scope of tests or chunks, which is used for grouping. Wrapper on mochajs describe. If you have more than one file with tests, it will be a good style to wrap all tests inside file under one scope for visual grouping in stdout report. /* scope of tests */ scope(&quot;Auth&quot;, () =&gt; { test(&quot;is passed&quot;, () =&gt; { // test case }); test(&quot;is failed&quot;, () =&gt; { // test case }); }); /* scope of chunks */ test(&quot;Auth&quot;, () =&gt; { scope(&quot;is passed&quot;, () =&gt; { chunk(&quot;for user&quot;, () =&gt; { // payload }); chunk(&quot;for admin&quot;, () =&gt; { // payload }); }); });before - mochajs before. after - mochajs after. beforeChunk - wrapper on mochajs beforeEach. afterChunk - wrapper on mochajs afterEach. × Search results Close "},"tutorial-mocha-uncaught.html":{"id":"tutorial-mocha-uncaught.html","title":"Tutorial: Mocha broken queue with uncaught exceptions","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Mocha broken queue with uncaught exceptions In mocha it's very easy to break async tests queue due to uncaught exceptions processing mechanism in mocha. Create tests file with next content: &quot;use strict&quot;; var sleep = timeout =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(`I was sleeping ${timeout} ms`); resolve(); }, timeout); }); }; var error = timeout =&gt; { setTimeout(() =&gt; { throw new Error(&quot;BOOM!!!&quot;); }, timeout); }; describe(&quot;scope&quot;, () =&gt; { it (&quot;test #1&quot;, async () =&gt; { error(1000); await sleep(1000); }); it (&quot;test #2&quot;, async () =&gt; await sleep(1000)); it (&quot;test #3&quot;, async () =&gt; { error(1000); await sleep(1000); }); it (&quot;test #4&quot;, async () =&gt; await sleep(1000)); it (&quot;test #5&quot;, async () =&gt; await sleep(1000)); it (&quot;test #6&quot;, async () =&gt; await sleep(1000)); }); Run and get something at first sight incomprehensible: $ mocha uncaught.js scope 1) test #1 # in console it colored as red (failed) I was sleeping 1000 ms √ test #1 (1012ms) 2) test #3 # in console it colored as red (failed) I was sleeping 1000 ms I was sleeping 1000 ms √ test #4 √ test #4 I was sleeping 1000 ms I was sleeping 1000 ms I was sleeping 1000 ms √ test #6 (1002ms) √ test #6 (1002ms) √ test #6 (1003ms) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 6 passing (3s) 2 failing 1) scope test #1: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15) 2) scope test #3: Uncaught Error: BOOM!!! at Timeout.setTimeout [as _onTimeout] (uncaught.js:12:15At first, please note that test #1 is marked twice: as passed and as failed! Second, test #2 and test #5 are absent in the report. Third, begins simultaneous delivery of messages I was sleeping 1000 ms, first 1 time, then 2 times, then 3 times. Now consider why this is so. The problem is that mocha default handles uncaught exceptions. If such an exception occurs, mocha fails current test, no matter whether with him or even uncaught exception was generated by an asynchronous call to a lot of tests ago (e.g. due to forgotten / hanging timers, etc.). And since this processor is implemented via a listener, then in my example it is a very interesting thing: On one hand in the test after 1 second uncaught exception happens and invokes its handler, on the other side the test explicitly waits for 1 second end of sleep and marks the test as passed. Because of the async of JavaScript, we have two concurrent test processors, which leads to twice appearance of a report of test #1. Moreover, from now on, we have two places which emit event to start a new test. And in fact, one queue was splitted to 2 queues! In test #3 the situation is repeated, leading to further division of the queue. And we have 3 competitive operating test queues! This can be observed by the increment of the number of messages I was sleeping 1000 ms. In our work, we periodically met such split of queue, so this example is based on a real existing problem. In the end, the whole run was in the trash, because due to queue splitting test results weren't correct. How to fixSimple and working variant to suppress uncaught exception. var Mocha = require(&quot;mocha&quot;); Mocha.Runner.prototype.uncaught = function (err) { logger.error(&quot;UNCAUGHT ERROR&quot;, err); };Better to get one failed test, and in finalizers to close all descriptors, proxies, to kill processes, etc., to suppress and log uncaught exception, and then analyze the logs for their presence. Than to collapse the queue and get failed report of all night run. In my work this approach was really helpful. That's why glace supports own variants to process uncaught exceptions (see CLI option --uncaught). P. S. mocha has the option --allow-enable - uncaught uncaught errors to propagate. But I did not understand what it is, because it certainly does not solve the problem. × Search results Close "},"tutorial-parameterization.html":{"id":"tutorial-parameterization.html","title":"Tutorial: Tests parameterization","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Tests parameterization × Search results Close "},"tutorial-plugins.html":{"id":"tutorial-plugins.html","title":"Tutorial: How plugins work","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest How plugins work × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Release Notes v1.7.6 Fixed that after relaunch only failed tests glace didn't save previously passed chunk ids. v1.7.5 Rid of context in failed tests relaunch. v1.7.4 Retry only failed chunks. v1.7.3 Fixed wrong error message in debug mode. v1.7.2 Disable chunk timeout and optional reports on --debug-on-fail. v1.7.1 Fixed bug that all reporters are removed if try to remove some one. v1.7.0 Fixed typos in help file. v1.6.9 Fixed bug with broken allure and testrail reporter after mocha suite title patching. v1.6.8 Work around windows console gray ascii color problem. Fixed bug with undefined skip reason. v1.6.7 Removed redundant test option skipReason. v1.6.6 Fixed bug to create logs folder synchronously. v1.6.5 Fixed bug that test, scope and suite names weren't defined precisely. Code improvements and tests expansion. v1.6.4 Fixed bug that params from include file were ignored on retry after before all hook failure. v1.6.3 Create logs folder before reporting. v1.6.2 Fixed bug to ignore include and exclude options in interactive mode. v1.6.1 Included chai plugins chai-string, chai-fs, chai-datetime. v1.6.0 Added CLI option --dont-check-names. v1.5.9 Fixed bug that steps with ES6 options weren't rendered correct with --list-step CLI option. v1.5.8 Renamed reports folder. v1.5.7 Fixed bug that suite wasn't rendered in stdout report. v1.5.6 Allure reporter fixes. v1.5.5 Allure reporter fixes. v1.5.4 Added steps aliases $ and $$. Added allure reporter support. v1.5.3 Added helper stubObject. v1.5.2 Moved stdout log under reports folder. Changed project icon. Used pure javascript bayes classifier. v1.5.1 Updated dependencies. v1.5.0 Skipped registration of already registered plugin. Added API to get registered plugin names. v1.4.9 Fixed incorrect help. v1.4.8 Use global session on retry (#87). v1.4.7 Fixed failed retry mechanism. v1.4.6 Added feature to launch all retried tests in one session. v1.4.5 Implemented tests include to run. Implemented tests exclude from run. Loaded included and excluded tests from file. Saved failed tests in JSON format. Added CLI option to print errors immediately. v1.4.4 Update dependencies. v1.4.3 Update glace-utils to not kill parent process. v1.4.2 Added option to finish test run on first failure. v1.4.1 Added ability to mark chunks as skipped. Added feature to print tests time duration in human-readable format. Fixed bug with wrong exit code on non-test hook failure. v1.4.0 Fixed bug when glace returned incorrect exit code on test retry. v1.3.9 Fixed stdout in testrail check command. v1.3.8 Added CLI option to check TestRail cases consistency with implemented tests. v1.3.7 Added ability to restart only failed params even if in retry before all test was failed. v1.3.6 Fixed bug in testrail api. v1.3.5 Added relevant step docs sorting with machine learning algorithms via natural. v1.3.4 Added interactive mode. v1.3.3 Added multi-word search in docs of steps and fixtures. v1.3.2 Added full-text search in docs of steps and fixtures. v1.3.1 Fixed bug that custom steps class wasn't shown in CLI docs. v1.3.0 Used docstring style for fixtures. v1.2.9 Used js syntax highlight in steps documentation in CLI. v1.2.8 Added ability to show steps documentation in --list-steps. v1.2.7 Added CLI options --list-steps [filter], --list-tests [filter], --list-fixtures [filter]. v1.2.6 Decomposed global functions. Added option to enter to interactive debug mode on step failure. v1.2.5 Fixed bug that option --chunk-timeout no leaded to default timeout 2000. v1.2.4 Added custom path for log files. v1.2.3 Fixed bug that relative root conftest wasn't resolved correct. v1.2.2 Fixed a bug that glace raised error if steps property didn't exist. v1.2.1 Added helpers for easy integration with glace-testgen plugin. v1.2.0 Added feature to kill processes before tests run. v1.1.9 Fixed bug that on parametrized test failure failed params may be added to retry more that one time. v1.1.8 Added step to enter to interactive debug mode. v1.1.7 Patched rewire in order to add method __reset__ to restore original module state. v1.1.6 Added rewire and sinon-chai. v1.1.5 Fixed bug that matcher waitFor didn't work correct with async predicates. v1.1.4 Added chai matcher waitFor. v1.1.3 Expanded test &amp; chunk options. v1.1.2 Updated mocha to latest version. Updated glace-utils to support config parents loading. v1.1.1 Fixed typo in tests loader method to scan test modules. Added feature to show tests summary time. Added feature to capture skipped tests in reporters. Fixed bug with disorder in plugins loader. v1.1.0 Generate session ID on start. v1.0.9 Show a number of executed chunks in report. Show link to xunit report if it is active. v1.0.8 Supports xunit reporter, which may be activated with CLI option --xunit. v1.0.7 Plugin reporters are registered on reporting system loading. CLI option --chunk timeout &lt;timeout&gt; sets time (sec) to execute for all hooks and chunks. Default value is 180 sec. Test or scope option { chunkTimeout: &lt;timeout&gt; } sets time (sec) to execute for hooks and chunks inside test or scope and overrides global value. × Search results Close "},"tutorial-reports.html":{"id":"tutorial-reports.html","title":"Tutorial: Test reports","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Test reports × Search results Close "},"tutorial-retry.html":{"id":"tutorial-retry.html","title":"Tutorial: Tests and chunks retry","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Tests and chunks retry × Search results Close "},"tutorial-steps-architecture.html":{"id":"tutorial-steps-architecture.html","title":"Tutorial: STEPS architecture","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest STEPS architecture Approach for functional autotests development based on next principles: Any complex test may be divided to atomic steps. Almost all tests contain steps which are (or may be) used in other tests. Each step should be finished with verification that its result is correct. Verification of step may be disabled if it needs for negative scenarios. Steps are separated to change-steps, get-steps, check-steps. change-step should return true if it was executed and doesn't return another step-specific value. change-step should return false if it wasn't executed. change-steps may be connected to opposite pair: start &amp; finish. if start change-step wasn't executed, finish change-step shouldn't be executed. × Search results Close "},"tutorial-steps-protocol.html":{"id":"tutorial-steps-protocol.html","title":"Tutorial: STEPS protocol","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest STEPS protocol Way to develop GlaceJS-compatible applications which may be used as GlaceJS plugins. Any application which implements STEPS protocol should follow next rules: Its modules should be lazy-loaded, for example, require(&quot;glace-web&quot;) should be empty by default It should provide Steps module, which based on STEPS architecture, for example, require(&quot;glace-web&quot;).Steps Steps module is object with functions, which will be mixed with base Steps class. It should provide globals module, for example, require(&quot;glace-web&quot;).globals, which will be loaded after main globals and may override it. It should provide pluginHelp module, for example, require(&quot;glace-web&quot;).pluginHelp, which will extend application help. It should active plugin fixtures on Steps module import. STEPS protocol is bidirectional. It means that any plugin may be easily transformed to standalone application, and any standalone application may be used as plugin. × Search results Close "},"tutorial-test-fixtures.html":{"id":"tutorial-test-fixtures.html","title":"Tutorial: Test fixtures","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Test fixtures If you need to provide some before and/or after hooks in tests or group of tests, in order to avoid copy-paste you may develop and reuse fixtures. var myFixture = func =&gt; { before(() =&gt; { console.log(&quot;called before&quot;); }); func(); after(() =&gt; { console.log(&quot;called after&quot;); }); }; test(&quot;My test&quot;, /* options */ null, [myFixture], () =&gt; { chunk(() =&gt; {}); }); scope(&quot;My tests&quot;, /* options */ null, [myFixture], () =&gt; { test(&quot;#1&quot;, () =&gt; { chunk(() =&gt; {}); }); test(&quot;#2&quot;, () =&gt; { chunk(() =&gt; {}); }); }); × Search results Close "},"tutorial-test-options.html":{"id":"tutorial-test-options.html","title":"Tutorial: Test & chunk options","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest Test &amp; chunk options When you develop a test you may pass options to test or chunk, which override config values for concrete test or chunk. Test optionsskip unwanted testtest(&quot;My test&quot;, { skip: true }, () =&gt; { chunk(() =&gt; { // payload }); });test(&quot;My test&quot;, { skip: &quot;Opened bug http://tracker.com/bugs/121&quot; }, () =&gt; { chunk(() =&gt; { // payload }); });retry failed testtest(&quot;My test&quot;, { retry: 2 }, () =&gt; { chunk(() =&gt; { // payload }); })retry failed chunkstest(&quot;My test&quot;, { chunkRetry: 2 }, () =&gt; { chunk(() =&gt; { // payload }); });chunks execution timeouttest(&quot;My test&quot;, { chunkTimeout: 1 }, () =&gt; { chunk(() =&gt; { // payload }); });Chunk optionsretry failed chunktest(&quot;My test&quot;, () =&gt; { chunk({ retry: 2 }, () =&gt; { // payload }); });chunk execution timeouttest(&quot;My test&quot;, () =&gt; { chunk({ timeout: 1 }, () =&gt; { // payload }); }); × Search results Close "},"tutorial-tests-loading.html":{"id":"tutorial-tests-loading.html","title":"Tutorial: How glace loads tests","body":" GlaseJS Namespaces GlaceConfig Modules allureclassifierclierrorglobals/indexhackingindexloadermatcherpluginsreporter/allurereporter/indexreporter/stdoutreporter/testrailreporter/xunittestingtools Classes GlaceReportererror~ConfigErrorerror~StepErrortesting~ScopeTypetesting~TestCaseSteps Mixins TimerSteps Tutorials GlaceJS conceptsMocha broken queue with uncaught exceptionsTests parameterizationHow plugins workRelease NotesTest reportsTests and chunks retrySTEPS architectureSTEPS protocolTest fixturesTest &amp; chunk optionsHow glace loads tests Global $afterChunkallurebaseTestbeforeChunkchunkCONFexpectforEachLanguageglaceRunhelpreportersrewirerunscopesessionsessNumsetLogsinonstubObjecttest How glace loads tests By default glace tries to load tests from folder tests in the same folder where command glace was called. Tests are loaded from folder recursively from subfolders too. It's possible to explicitly specify path to tests folder, for example: glace /path/to/tests/dir, or to sequence of folders: glace /path/to/dir1 /path/to/dir2. In folder, test files should have prefix test, for example: testMainPage.js, tests.js, etc. Otherwise they will be missed. Also it's possible to specify path to test file or sequence of test files (prefix test isn't require in such case): glace /path/to/myTests.js /path/to/otherTests.js. Or to mix folders and files: glace /path/to/tests/dir /path/to/myTests.js. conftest.jsconftest.js is a special file which will be loaded before tests loading and usually contains some preparation stuff. Conftest may be located in any folder inside test folder hierarchy. If conftest is located on one level with tests folder it will be loaded before tests session start and global objects initialization. It's possible to specify root conftest path via CLI option --root-conftest which will be loaded before top level conftests, but after programmatically configured preloads. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
